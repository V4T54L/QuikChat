{
  ".env.example": "# Server\nSERVER_PORT=8080\n\n# Database\nDB_HOST=localhost\nDB_PORT=5432\nDB_USER=user\nDB_PASSWORD=password\nDB_NAME=quikchat\nDB_SSLMODE=disable\n\n# Redis\nREDIS_ADDR=localhost:6379\n\n# JWT\nJWT_SECRET=a_very_secret_key\nJWT_ACCESS_TOKEN_EXP_MIN=10\nJWT_REFRESH_TOKEN_EXP_HOUR=8\n\n# File Storage\nPROFILE_PIC_DIR=./uploads/profile_pics\nSTATIC_FILES_DIR=./web/static\nPROFILE_PIC_ROUTE=/static/profile_pics/\n",
  "Makefile": ".PHONY: run docker-up docker-down\n\nrun:\n\t@echo \"Starting application...\"\n\t@go run ./backend/cmd/server/main.go\n\ndocker-up:\n\t@echo \"Starting Docker containers...\"\n\t@docker-compose up -d\n\ndocker-down:\n\t@echo \"Stopping Docker containers...\"\n\t@docker-compose down\n",
  "backend/adapter/filesystem/local_storage.go": "package filesystem\n\nimport (\n\t\"chat-app/backend/repository\"\n\t\"fmt\"\n\t\"io\"\n\t\"mime/multipart\"\n\t\"os\"\n\t\"path/filepath\"\n\n\t\"github.com/google/uuid\"\n)\n\ntype localStorage struct {\n\tstorageDir string\n\troutePath  string\n}\n\nfunc NewLocalStorage(storageDir, routePath string) repository.FileRepository {\n\treturn \u0026localStorage{\n\t\tstorageDir: storageDir,\n\t\troutePath:  routePath,\n\t}\n}\n\nfunc (l *localStorage) Save(file multipart.File, header *multipart.FileHeader) (string, error) {\n\tdefer file.Close()\n\n\text := filepath.Ext(header.Filename)\n\trandomFilename := fmt.Sprintf(\"%s%s\", uuid.New().String(), ext)\n\tfilePath := filepath.Join(l.storageDir, randomFilename)\n\n\tdst, err := os.Create(filePath)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\tdefer dst.Close()\n\n\tif _, err := io.Copy(dst, file); err != nil {\n\t\treturn \"\", err\n\t}\n\n\tfileURL := filepath.Join(l.routePath, randomFilename)\n\treturn fileURL, nil\n}\n",
  "backend/adapter/handler/http/auth_handler.go": "package http\n\nimport (\n\t\"chat-app/backend/adapter/util\"\n\t\"chat-app/backend/models\"\n\t\"encoding/json\"\n\t\"errors\"\n\t\"net/http\"\n)\n\ntype loginRequest struct {\n\tUsername string `json:\"username\"`\n\tPassword string `json:\"password\"`\n}\n\ntype loginResponse struct {\n\tAccessToken  string `json:\"accessToken\"`\n\tRefreshToken string `json:\"refreshToken\"`\n}\n\nfunc (h *AuthHandler) Login(w http.ResponseWriter, r *http.Request) {\n\tvar req loginRequest\n\tif err := json.NewDecoder(r.Body).Decode(\u0026req); err != nil {\n\t\tutil.RespondWithError(w, http.StatusBadRequest, \"Invalid request payload\")\n\t\treturn\n\t}\n\n\taccessToken, refreshToken, err := h.authUsecase.Login(r.Context(), req.Username, req.Password)\n\tif err != nil {\n\t\tif errors.Is(err, models.ErrInvalidCredentials) {\n\t\t\tutil.RespondWithError(w, http.StatusUnauthorized, err.Error())\n\t\t\treturn\n\t\t}\n\t\tutil.RespondWithError(w, http.StatusInternalServerError, \"Failed to login\")\n\t\treturn\n\t}\n\n\tutil.RespondWithJSON(w, http.StatusOK, loginResponse{\n\t\tAccessToken:  accessToken,\n\t\tRefreshToken: refreshToken,\n\t})\n}\n\ntype refreshRequest struct {\n\tRefreshToken string `json:\"refreshToken\"`\n}\n\ntype refreshResponse struct {\n\tAccessToken string `json:\"accessToken\"`\n}\n\nfunc (h *AuthHandler) Refresh(w http.ResponseWriter, r *http.Request) {\n\tvar req refreshRequest\n\tif err := json.NewDecoder(r.Body).Decode(\u0026req); err != nil {\n\t\tutil.RespondWithError(w, http.StatusBadRequest, \"Invalid request payload\")\n\t\treturn\n\t}\n\n\tnewAccessToken, err := h.authUsecase.Refresh(r.Context(), req.RefreshToken)\n\tif err != nil {\n\t\tif errors.Is(err, models.ErrSessionNotFound) || errors.Is(err, models.ErrInvalidToken) {\n\t\t\tutil.RespondWithError(w, http.StatusUnauthorized, err.Error())\n\t\t\treturn\n\t\t}\n\t\tutil.RespondWithError(w, http.StatusInternalServerError, \"Failed to refresh token\")\n\t\treturn\n\t}\n\n\tutil.RespondWithJSON(w, http.StatusOK, refreshResponse{AccessToken: newAccessToken})\n}\n\ntype logoutRequest struct {\n\tRefreshToken string `json:\"refreshToken\"`\n}\n\nfunc (h *AuthHandler) Logout(w http.ResponseWriter, r *http.Request) {\n\tvar req logoutRequest\n\tif err := json.NewDecoder(r.Body).Decode(\u0026req); err != nil {\n\t\tutil.RespondWithError(w, http.StatusBadRequest, \"Invalid request payload\")\n\t\treturn\n\t}\n\n\tif err := h.authUsecase.Logout(r.Context(), req.RefreshToken); err != nil {\n\t\t// We can choose to not return an error to the client for logout failures\n\t\t// for security reasons, but for simplicity we will.\n\t\tutil.RespondWithError(w, http.StatusInternalServerError, \"Failed to logout\")\n\t\treturn\n\t}\n\n\tutil.RespondWithJSON(w, http.StatusOK, map[string]string{\"message\": \"Logged out successfully\"})\n}\n",
  "backend/adapter/handler/http/friend_handler.go": "package http\n\nimport (\n\t\"encoding/json\"\n\t\"errors\"\n\t\"net/http\"\n\n\t\"chat-app/adapter/middleware\"\n\t\"chat-app/adapter/util\"\n\t\"chat-app/models\"\n\n\t\"github.com/go-chi/chi/v5\"\n\t\"github.com/google/uuid\"\n)\n\nfunc (h *FriendHandler) SendRequest(w http.ResponseWriter, r *http.Request) {\n\tuserID, ok := r.Context().Value(middleware.UserIDKey).(uuid.UUID)\n\tif !ok {\n\t\tutil.RespondWithError(w, http.StatusUnauthorized, \"Invalid user ID in token\")\n\t\treturn\n\t}\n\n\tvar req struct {\n\t\tUsername string `json:\"username\"`\n\t}\n\tif err := json.NewDecoder(r.Body).Decode(\u0026req); err != nil {\n\t\tutil.RespondWithError(w, http.StatusBadRequest, \"Invalid request payload\")\n\t\treturn\n\t}\n\n\terr := h.friendUsecase.SendRequest(r.Context(), userID, req.Username)\n\tif err != nil {\n\t\tswitch {\n\t\tcase errors.Is(err, models.ErrUserNotFound):\n\t\t\tutil.RespondWithError(w, http.StatusNotFound, err.Error())\n\t\tcase errors.Is(err, models.ErrAlreadyFriends), errors.Is(err, models.ErrFriendRequestExists), errors.Is(err, models.ErrCannotFriendSelf):\n\t\t\tutil.RespondWithError(w, http.StatusConflict, err.Error())\n\t\tdefault:\n\t\t\tutil.RespondWithError(w, http.StatusInternalServerError, \"Could not send friend request\")\n\t\t}\n\t\treturn\n\t}\n\n\tutil.RespondWithJSON(w, http.StatusCreated, map[string]string{\"message\": \"Friend request sent\"})\n}\n\nfunc (h *FriendHandler) RespondToRequest(w http.ResponseWriter, r *http.Request) {\n\tuserID, ok := r.Context().Value(middleware.UserIDKey).(uuid.UUID)\n\tif !ok {\n\t\tutil.RespondWithError(w, http.StatusUnauthorized, \"Invalid user ID in token\")\n\t\treturn\n\t}\n\n\trequesterIDStr := chi.URLParam(r, \"requesterID\")\n\trequesterID, err := uuid.Parse(requesterIDStr)\n\tif err != nil {\n\t\tutil.RespondWithError(w, http.StatusBadRequest, \"Invalid requester ID\")\n\t\treturn\n\t}\n\n\tvar req struct {\n\t\tAction string `json:\"action\"` // \"accept\" or \"reject\"\n\t}\n\tif err := json.NewDecoder(r.Body).Decode(\u0026req); err != nil {\n\t\tutil.RespondWithError(w, http.StatusBadRequest, \"Invalid request payload\")\n\t\treturn\n\t}\n\n\tvar usecaseErr error\n\tmessage := \"\"\n\tif req.Action == \"accept\" {\n\t\tusecaseErr = h.friendUsecase.AcceptRequest(r.Context(), userID, requesterID)\n\t\tmessage = \"Friend request accepted\"\n\t} else if req.Action == \"reject\" {\n\t\tusecaseErr = h.friendUsecase.RejectRequest(r.Context(), userID, requesterID)\n\t\tmessage = \"Friend request rejected\"\n\t} else {\n\t\tutil.RespondWithError(w, http.StatusBadRequest, \"Invalid action\")\n\t\treturn\n\t}\n\n\tif usecaseErr != nil {\n\t\tswitch {\n\t\tcase errors.Is(usecaseErr, models.ErrFriendRequestNotFound):\n\t\t\tutil.RespondWithError(w, http.StatusNotFound, usecaseErr.Error())\n\t\tdefault:\n\t\t\tutil.RespondWithError(w, http.StatusInternalServerError, \"Could not respond to friend request\")\n\t\t}\n\t\treturn\n\t}\n\n\tutil.RespondWithJSON(w, http.StatusOK, map[string]string{\"message\": message})\n}\n\nfunc (h *FriendHandler) Unfriend(w http.ResponseWriter, r *http.Request) {\n\tuserID, ok := r.Context().Value(middleware.UserIDKey).(uuid.UUID)\n\tif !ok {\n\t\tutil.RespondWithError(w, http.StatusUnauthorized, \"Invalid user ID in token\")\n\t\treturn\n\t}\n\n\tfriendIDStr := chi.URLParam(r, \"friendID\")\n\tfriendID, err := uuid.Parse(friendIDStr)\n\tif err != nil {\n\t\tutil.RespondWithError(w, http.StatusBadRequest, \"Invalid friend ID\")\n\t\treturn\n\t}\n\n\terr = h.friendUsecase.Unfriend(r.Context(), userID, friendID)\n\tif err != nil {\n\t\tswitch {\n\t\tcase errors.Is(err, models.ErrNotFriends), errors.Is(err, models.ErrFriendRequestNotFound):\n\t\t\tutil.RespondWithError(w, http.StatusNotFound, err.Error())\n\t\tdefault:\n\t\t\tutil.RespondWithError(w, http.StatusInternalServerError, \"Could not unfriend user\")\n\t\t}\n\t\treturn\n\t}\n\n\tw.WriteHeader(http.StatusNoContent)\n}\n\nfunc (h *FriendHandler) ListFriends(w http.ResponseWriter, r *http.Request) {\n\tuserID, ok := r.Context().Value(middleware.UserIDKey).(uuid.UUID)\n\tif !ok {\n\t\tutil.RespondWithError(w, http.StatusUnauthorized, \"Invalid user ID in token\")\n\t\treturn\n\t}\n\n\tfriends, err := h.friendUsecase.ListFriends(r.Context(), userID)\n\tif err != nil {\n\t\tutil.RespondWithError(w, http.StatusInternalServerError, \"Could not list friends\")\n\t\treturn\n\t}\n\n\tutil.RespondWithJSON(w, http.StatusOK, friends)\n}\n\nfunc (h *FriendHandler) ListPendingRequests(w http.ResponseWriter, r *http.Request) {\n\tuserID, ok := r.Context().Value(middleware.UserIDKey).(uuid.UUID)\n\tif !ok {\n\t\tutil.RespondWithError(w, http.StatusUnauthorized, \"Invalid user ID in token\")\n\t\treturn\n\t}\n\n\trequests, err := h.friendUsecase.ListPendingRequests(r.Context(), userID)\n\tif err != nil {\n\t\tutil.RespondWithError(w, http.StatusInternalServerError, \"Could not list pending requests\")\n\t\treturn\n\t}\n\n\tutil.RespondWithJSON(w, http.StatusOK, requests)\n}\n",
  "backend/adapter/handler/http/group_handler.go": "package http\n\nimport (\n\t\"encoding/json\"\n\t\"errors\"\n\t\"net/http\"\n\n\t\"chat-app/adapter/middleware\"\n\t\"chat-app/adapter/util\"\n\t\"chat-app/models\"\n\n\t\"github.com/go-chi/chi/v5\"\n\t\"github.com/google/uuid\"\n)\n\nconst maxGroupPhotoSize = 200 * 1024 // 200 KB\n\nfunc (h *GroupHandler) CreateGroup(w http.ResponseWriter, r *http.Request) {\n\tuserID, ok := r.Context().Value(middleware.UserIDKey).(uuid.UUID)\n\tif !ok {\n\t\tutil.RespondWithError(w, http.StatusUnauthorized, \"Invalid user ID in token\")\n\t\treturn\n\t}\n\n\tif err := r.ParseMultipartForm(maxGroupPhotoSize); err != nil {\n\t\tutil.RespondWithError(w, http.StatusBadRequest, \"Could not parse form\")\n\t\treturn\n\t}\n\n\thandle := r.FormValue(\"handle\")\n\tname := r.FormValue(\"name\")\n\tif handle == \"\" || name == \"\" {\n\t\tutil.RespondWithError(w, http.StatusBadRequest, \"Handle and name are required\")\n\t\treturn\n\t}\n\n\tfile, header, err := r.FormFile(\"photo\")\n\tif err != nil \u0026\u0026 !errors.Is(err, http.ErrMissingFile) {\n\t\tutil.RespondWithError(w, http.StatusBadRequest, \"Could not get photo\")\n\t\treturn\n\t}\n\tif file != nil {\n\t\tdefer file.Close()\n\t}\n\n\tgroup, err := h.groupUsecase.CreateGroup(r.Context(), userID, handle, name, file, header)\n\tif err != nil {\n\t\tswitch {\n\t\tcase errors.Is(err, models.ErrGroupHandleTaken):\n\t\t\tutil.RespondWithError(w, http.StatusConflict, err.Error())\n\t\tdefault:\n\t\t\tutil.RespondWithError(w, http.StatusInternalServerError, \"Could not create group\")\n\t\t}\n\t\treturn\n\t}\n\n\tutil.RespondWithJSON(w, http.StatusCreated, group)\n}\n\nfunc (h *GroupHandler) JoinGroup(w http.ResponseWriter, r *http.Request) {\n\tuserID, ok := r.Context().Value(middleware.UserIDKey).(uuid.UUID)\n\tif !ok {\n\t\tutil.RespondWithError(w, http.StatusUnauthorized, \"Invalid user ID in token\")\n\t\treturn\n\t}\n\n\tvar req struct {\n\t\tHandle string `json:\"handle\"`\n\t}\n\tif err := json.NewDecoder(r.Body).Decode(\u0026req); err != nil {\n\t\tutil.RespondWithError(w, http.StatusBadRequest, \"Invalid request payload\")\n\t\treturn\n\t}\n\n\terr := h.groupUsecase.JoinGroup(r.Context(), userID, req.Handle)\n\tif err != nil {\n\t\tswitch {\n\t\tcase errors.Is(err, models.ErrGroupNotFound):\n\t\t\tutil.RespondWithError(w, http.StatusNotFound, err.Error())\n\t\tcase errors.Is(err, models.ErrAlreadyGroupMember):\n\t\t\tutil.RespondWithError(w, http.StatusConflict, err.Error())\n\t\tdefault:\n\t\t\tutil.RespondWithError(w, http.StatusInternalServerError, \"Could not join group\")\n\t\t}\n\t\treturn\n\t}\n\n\tutil.RespondWithJSON(w, http.StatusOK, map[string]string{\"message\": \"Successfully joined group\"})\n}\n\nfunc (h *GroupHandler) LeaveGroup(w http.ResponseWriter, r *http.Request) {\n\tuserID, ok := r.Context().Value(middleware.UserIDKey).(uuid.UUID)\n\tif !ok {\n\t\tutil.RespondWithError(w, http.StatusUnauthorized, \"Invalid user ID in token\")\n\t\treturn\n\t}\n\n\tgroupIDStr := chi.URLParam(r, \"groupID\")\n\tgroupID, err := uuid.Parse(groupIDStr)\n\tif err != nil {\n\t\tutil.RespondWithError(w, http.StatusBadRequest, \"Invalid group ID\")\n\t\treturn\n\t}\n\n\terr = h.groupUsecase.LeaveGroup(r.Context(), userID, groupID)\n\tif err != nil {\n\t\tswitch {\n\t\tcase errors.Is(err, models.ErrGroupNotFound), errors.Is(err, models.ErrNotGroupMember):\n\t\t\tutil.RespondWithError(w, http.StatusNotFound, err.Error())\n\t\tdefault:\n\t\t\tutil.RespondWithError(w, http.StatusInternalServerError, \"Could not leave group\")\n\t\t}\n\t\treturn\n\t}\n\n\tutil.RespondWithJSON(w, http.StatusOK, map[string]string{\"message\": \"Successfully left group\"})\n}\n\nfunc (h *GroupHandler) AddMember(w http.ResponseWriter, r *http.Request) {\n\tadderID, ok := r.Context().Value(middleware.UserIDKey).(uuid.UUID)\n\tif !ok {\n\t\tutil.RespondWithError(w, http.StatusUnauthorized, \"Invalid user ID in token\")\n\t\treturn\n\t}\n\n\tgroupIDStr := chi.URLParam(r, \"groupID\")\n\tgroupID, err := uuid.Parse(groupIDStr)\n\tif err != nil {\n\t\tutil.RespondWithError(w, http.StatusBadRequest, \"Invalid group ID\")\n\t\treturn\n\t}\n\n\tvar req struct {\n\t\tUsername string `json:\"username\"`\n\t}\n\tif err := json.NewDecoder(r.Body).Decode(\u0026req); err != nil {\n\t\tutil.RespondWithError(w, http.StatusBadRequest, \"Invalid request payload\")\n\t\treturn\n\t}\n\n\terr = h.groupUsecase.AddMember(r.Context(), adderID, req.Username, groupID)\n\tif err != nil {\n\t\tswitch {\n\t\tcase errors.Is(err, models.ErrNotGroupMember), errors.Is(err, models.ErrUserNotFound), errors.Is(err, models.ErrNotFriends):\n\t\t\tutil.RespondWithError(w, http.StatusForbidden, err.Error())\n\t\tcase errors.Is(err, models.ErrAlreadyGroupMember):\n\t\t\tutil.RespondWithError(w, http.StatusConflict, err.Error())\n\t\tdefault:\n\t\t\tutil.RespondWithError(w, http.StatusInternalServerError, \"Could not add member\")\n\t\t}\n\t\treturn\n\t}\n\n\tutil.RespondWithJSON(w, http.StatusCreated, map[string]string{\"message\": \"Member added successfully\"})\n}\n\nfunc (h *GroupHandler) RemoveMember(w http.ResponseWriter, r *http.Request) {\n\townerID, ok := r.Context().Value(middleware.UserIDKey).(uuid.UUID)\n\tif !ok {\n\t\tutil.RespondWithError(w, http.StatusUnauthorized, \"Invalid user ID in token\")\n\t\treturn\n\t}\n\n\tgroupIDStr := chi.URLParam(r, \"groupID\")\n\tgroupID, err := uuid.Parse(groupIDStr)\n\tif err != nil {\n\t\tutil.RespondWithError(w, http.StatusBadRequest, \"Invalid group ID\")\n\t\treturn\n\t}\n\n\tmemberIDStr := chi.URLParam(r, \"memberID\")\n\tmemberID, err := uuid.Parse(memberIDStr)\n\tif err != nil {\n\t\tutil.RespondWithError(w, http.StatusBadRequest, \"Invalid member ID\")\n\t\treturn\n\t}\n\n\terr = h.groupUsecase.RemoveMember(r.Context(), ownerID, memberID, groupID)\n\tif err != nil {\n\t\tswitch {\n\t\tcase errors.Is(err, models.ErrNotGroupOwner), errors.Is(err, models.ErrCannotRemoveOwner):\n\t\t\tutil.RespondWithError(w, http.StatusForbidden, err.Error())\n\t\tcase errors.Is(err, models.ErrGroupNotFound), errors.Is(err, models.ErrNotGroupMember):\n\t\t\tutil.RespondWithError(w, http.StatusNotFound, err.Error())\n\t\tdefault:\n\t\t\tutil.RespondWithError(w, http.StatusInternalServerError, \"Could not remove member\")\n\t\t}\n\t\treturn\n\t}\n\n\tw.WriteHeader(http.StatusNoContent)\n}\n\nfunc (h *GroupHandler) SearchGroups(w http.ResponseWriter, r *http.Request) {\n\tquery := r.URL.Query().Get(\"q\")\n\tif query == \"\" {\n\t\tutil.RespondWithError(w, http.StatusBadRequest, \"Query parameter 'q' is required\")\n\t\treturn\n\t}\n\n\tgroups, err := h.groupUsecase.SearchGroups(r.Context(), query)\n\tif err != nil {\n\t\tutil.RespondWithError(w, http.StatusInternalServerError, \"Could not search for groups\")\n\t\treturn\n\t}\n\n\tutil.RespondWithJSON(w, http.StatusOK, groups)\n}\n",
  "backend/adapter/handler/http/handler.go": "package http\n\nimport (\n\t\"chat-app/usecase\"\n)\n\ntype AuthHandler struct {\n\tauthUsecase usecase.AuthUsecase\n}\n\nfunc NewAuthHandler(authUsecase usecase.AuthUsecase) *AuthHandler {\n\treturn \u0026AuthHandler{authUsecase: authUsecase}\n}\n\ntype UserHandler struct {\n\tuserUsecase usecase.UserUsecase\n}\n\nfunc NewUserHandler(userUsecase usecase.UserUsecase) *UserHandler {\n\treturn \u0026UserHandler{userUsecase: userUsecase}\n}\n\ntype FriendHandler struct {\n\tfriendUsecase usecase.FriendUsecase\n}\n\nfunc NewFriendHandler(friendUsecase usecase.FriendUsecase) *FriendHandler {\n\treturn \u0026FriendHandler{friendUsecase: friendUsecase}\n}\n\ntype GroupHandler struct {\n\tgroupUsecase usecase.GroupUsecase\n}\n\nfunc NewGroupHandler(groupUsecase usecase.GroupUsecase) *GroupHandler {\n\treturn \u0026GroupHandler{groupUsecase: groupUsecase}\n}\n",
  "backend/adapter/handler/http/user_handler.go": "package http\n\nimport (\n\t\"chat-app/backend/adapter/middleware\"\n\t\"chat-app/backend/adapter/util\"\n\t\"chat-app/backend/models\"\n\t\"encoding/json\"\n\t\"errors\"\n\t\"net/http\"\n\n\t\"github.com/go-chi/chi/v5\"\n\t\"github.com/google/uuid\"\n)\n\ntype registerRequest struct {\n\tUsername string `json:\"username\"`\n\tPassword string `json:\"password\"`\n}\n\nfunc (h *UserHandler) Register(w http.ResponseWriter, r *http.Request) {\n\tvar req registerRequest\n\tif err := json.NewDecoder(r.Body).Decode(\u0026req); err != nil {\n\t\tutil.RespondWithError(w, http.StatusBadRequest, \"Invalid request payload\")\n\t\treturn\n\t}\n\n\tuser, err := h.userUsecase.Register(r.Context(), req.Username, req.Password)\n\tif err != nil {\n\t\tif errors.Is(err, models.ErrUsernameTaken) || err.Error() == \"invalid username format\" || err.Error() == \"password is too short\" {\n\t\t\tutil.RespondWithError(w, http.StatusBadRequest, err.Error())\n\t\t\treturn\n\t\t}\n\t\tutil.RespondWithError(w, http.StatusInternalServerError, \"Failed to register user\")\n\t\treturn\n\t}\n\n\tutil.RespondWithJSON(w, http.StatusCreated, user)\n}\n\nfunc (h *UserHandler) GetUserByUsername(w http.ResponseWriter, r *http.Request) {\n\tusername := chi.URLParam(r, \"username\")\n\tif username == \"\" {\n\t\tutil.RespondWithError(w, http.StatusBadRequest, \"Username is required\")\n\t\treturn\n\t}\n\n\tuser, err := h.userUsecase.GetByUsername(r.Context(), username)\n\tif err != nil {\n\t\tif errors.Is(err, models.ErrUserNotFound) {\n\t\t\tutil.RespondWithError(w, http.StatusNotFound, err.Error())\n\t\t\treturn\n\t\t}\n\t\tutil.RespondWithError(w, http.StatusInternalServerError, \"Failed to get user\")\n\t\treturn\n\t}\n\n\tutil.RespondWithJSON(w, http.StatusOK, user)\n}\n\nfunc (h *UserHandler) UpdateProfile(w http.ResponseWriter, r *http.Request) {\n\tuserID, ok := r.Context().Value(middleware.UserIDKey).(uuid.UUID)\n\tif !ok {\n\t\tutil.RespondWithError(w, http.StatusUnauthorized, \"Unauthorized\")\n\t\treturn\n\t}\n\n\tif err := r.ParseMultipartForm(32 \u003c\u003c 20); err != nil { // 32MB max memory\n\t\tutil.RespondWithError(w, http.StatusBadRequest, \"Failed to parse multipart form\")\n\t\treturn\n\t}\n\n\tvar username, password *string\n\tif val := r.FormValue(\"username\"); val != \"\" {\n\t\tusername = \u0026val\n\t}\n\tif val := r.FormValue(\"password\"); val != \"\" {\n\t\tpassword = \u0026val\n\t}\n\n\tfile, header, err := r.FormFile(\"profilePic\")\n\tif err != nil \u0026\u0026 !errors.Is(err, http.ErrMissingFile) {\n\t\tutil.RespondWithError(w, http.StatusBadRequest, \"Invalid file upload\")\n\t\treturn\n\t}\n\tif file != nil {\n\t\tdefer file.Close()\n\t}\n\n\tuser, err := h.userUsecase.UpdateProfile(r.Context(), userID, username, password, file, header)\n\tif err != nil {\n\t\tif errors.Is(err, models.ErrUserNotFound) {\n\t\t\tutil.RespondWithError(w, http.StatusNotFound, err.Error())\n\t\t\treturn\n\t\t}\n\t\tif errors.Is(err, models.ErrUsernameTaken) {\n\t\t\tutil.RespondWithError(w, http.StatusConflict, err.Error())\n\t\t\treturn\n\t\t}\n\t\t// Check for validation errors\n\t\tif err.Error() == \"invalid username format\" || err.Error() == \"password is too short\" || err.Error() == \"file size exceeds 200KB\" || err.Error() == \"invalid file type\" {\n\t\t\tutil.RespondWithError(w, http.StatusBadRequest, err.Error())\n\t\t\treturn\n\t\t}\n\t\tutil.RespondWithError(w, http.StatusInternalServerError, \"Failed to update profile\")\n\t\treturn\n\t}\n\n\tutil.RespondWithJSON(w, http.StatusOK, user)\n}\n",
  "backend/adapter/middleware/auth.go": "package middleware\n\nimport (\n\t\"chat-app/backend/adapter/util\"\n\t\"context\"\n\t\"net/http\"\n\t\"strings\"\n\n\t\"github.com/golang-jwt/jwt/v5\"\n\t\"github.com/google/uuid\"\n)\n\ntype contextKey string\n\nconst UserIDKey contextKey = \"userID\"\n\ntype AuthMiddleware struct {\n\tjwtSecret string\n}\n\nfunc NewAuthMiddleware(jwtSecret string) *AuthMiddleware {\n\treturn \u0026AuthMiddleware{jwtSecret: jwtSecret}\n}\n\nfunc (m *AuthMiddleware) Validate(next http.Handler) http.Handler {\n\treturn http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\tauthHeader := r.Header.Get(\"Authorization\")\n\t\tif authHeader == \"\" {\n\t\t\tutil.RespondWithError(w, http.StatusUnauthorized, \"Authorization header required\")\n\t\t\treturn\n\t\t}\n\n\t\ttokenString := strings.TrimPrefix(authHeader, \"Bearer \")\n\t\tif tokenString == authHeader {\n\t\t\tutil.RespondWithError(w, http.StatusUnauthorized, \"Bearer token required\")\n\t\t\treturn\n\t\t}\n\n\t\ttoken, err := jwt.Parse(tokenString, func(token *jwt.Token) (interface{}, error) {\n\t\t\tif _, ok := token.Method.(*jwt.SigningMethodHMAC); !ok {\n\t\t\t\treturn nil, jwt.ErrSignatureInvalid\n\t\t\t}\n\t\t\treturn []byte(m.jwtSecret), nil\n\t\t})\n\n\t\tif err != nil || !token.Valid {\n\t\t\tutil.RespondWithError(w, http.StatusUnauthorized, \"Invalid or expired token\")\n\t\t\treturn\n\t\t}\n\n\t\tclaims, ok := token.Claims.(jwt.MapClaims)\n\t\tif !ok {\n\t\t\tutil.RespondWithError(w, http.StatusUnauthorized, \"Invalid token claims\")\n\t\t\treturn\n\t\t}\n\n\t\tuserIDStr, ok := claims[\"user_id\"].(string)\n\t\tif !ok {\n\t\t\tutil.RespondWithError(w, http.StatusUnauthorized, \"Invalid user ID in token\")\n\t\t\treturn\n\t\t}\n\n\t\tuserID, err := uuid.Parse(userIDStr)\n\t\tif err != nil {\n\t\t\tutil.RespondWithError(w, http.StatusUnauthorized, \"Invalid user ID format in token\")\n\t\t\treturn\n\t\t}\n\n\t\tctx := context.WithValue(r.Context(), UserIDKey, userID)\n\t\tnext.ServeHTTP(w, r.WithContext(ctx))\n\t})\n}\n",
  "backend/adapter/middleware/logging.go": "package middleware\n\nimport (\n\t\"log\"\n\t\"net/http\"\n\t\"time\"\n)\n\nfunc Logging(next http.Handler) http.Handler {\n\treturn http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\tstart := time.Now()\n\t\tnext.ServeHTTP(w, r)\n\t\tlog.Printf(\"%s %s %s\", r.Method, r.RequestURI, time.Since(start))\n\t})\n}\n",
  "backend/adapter/postgres/db.go": "package postgres\n\nimport (\n\t\"chat-app/backend/config\"\n\t\"database/sql\"\n\t\"fmt\"\n\n\t_ \"github.com/lib/pq\"\n)\n\nfunc NewDB(cfg *config.Config) (*sql.DB, error) {\n\tconnStr := fmt.Sprintf(\"host=%s port=%s user=%s password=%s dbname=%s sslmode=%s\",\n\t\tcfg.DBHost, cfg.DBPort, cfg.DBUser, cfg.DBPassword, cfg.DBName, cfg.DBSslMode)\n\n\tdb, err := sql.Open(\"postgres\", connStr)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tif err := db.Ping(); err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn db, nil\n}\n",
  "backend/adapter/postgres/friendship_repo.go": "package postgres\n\nimport (\n\t\"context\"\n\t\"database/sql\"\n\t\"errors\"\n\t\"fmt\"\n\n\t\"chat-app/models\"\n\t\"chat-app/repository\"\n\n\t\"github.com/google/uuid\"\n\t\"github.com/lib/pq\"\n)\n\ntype postgresFriendshipRepository struct {\n\tdb *sql.DB\n}\n\nfunc NewPostgresFriendshipRepository(db *sql.DB) repository.FriendshipRepository {\n\treturn \u0026postgresFriendshipRepository{db: db}\n}\n\n// normalizeUserIDs ensures that userID1 is always less than userID2\nfunc normalizeUserIDs(userID1, userID2 uuid.UUID) (uuid.UUID, uuid.UUID) {\n\tif userID1.String() \u003e userID2.String() {\n\t\treturn userID2, userID1\n\t}\n\treturn userID1, userID2\n}\n\nfunc (r *postgresFriendshipRepository) Create(ctx context.Context, friendship *models.Friendship) error {\n\tu1, u2 := normalizeUserIDs(friendship.UserID1, friendship.UserID2)\n\tquery := `INSERT INTO friendships (user_id1, user_id2, status) VALUES ($1, $2, $3)`\n\t_, err := r.db.ExecContext(ctx, query, u1, u2, friendship.Status)\n\tif err != nil {\n\t\tif pgErr, ok := err.(*pq.Error); ok \u0026\u0026 pgErr.Code == \"23505\" { // unique_violation\n\t\t\treturn models.ErrFriendRequestExists\n\t\t}\n\t\treturn fmt.Errorf(\"failed to create friendship: %w\", err)\n\t}\n\treturn nil\n}\n\nfunc (r *postgresFriendshipRepository) UpdateStatus(ctx context.Context, userID1, userID2 uuid.UUID, status models.FriendshipStatus) error {\n\tu1, u2 := normalizeUserIDs(userID1, userID2)\n\tquery := `UPDATE friendships SET status = $3 WHERE user_id1 = $1 AND user_id2 = $2`\n\tres, err := r.db.ExecContext(ctx, query, u1, u2, status)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to update friendship status: %w\", err)\n\t}\n\trowsAffected, err := res.RowsAffected()\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to get rows affected: %w\", err)\n\t}\n\tif rowsAffected == 0 {\n\t\treturn models.ErrFriendRequestNotFound\n\t}\n\treturn nil\n}\n\nfunc (r *postgresFriendshipRepository) Delete(ctx context.Context, userID1, userID2 uuid.UUID) error {\n\tu1, u2 := normalizeUserIDs(userID1, userID2)\n\tquery := `DELETE FROM friendships WHERE user_id1 = $1 AND user_id2 = $2`\n\tres, err := r.db.ExecContext(ctx, query, u1, u2)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to delete friendship: %w\", err)\n\t}\n\trowsAffected, err := res.RowsAffected()\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to get rows affected: %w\", err)\n\t}\n\tif rowsAffected == 0 {\n\t\treturn models.ErrNotFriends // Or request not found, context dependent\n\t}\n\treturn nil\n}\n\nfunc (r *postgresFriendshipRepository) Find(ctx context.Context, userID1, userID2 uuid.UUID) (*models.Friendship, error) {\n\tu1, u2 := normalizeUserIDs(userID1, userID2)\n\tquery := `SELECT user_id1, user_id2, status, created_at FROM friendships WHERE user_id1 = $1 AND user_id2 = $2`\n\tfriendship := \u0026models.Friendship{}\n\terr := r.db.QueryRowContext(ctx, query, u1, u2).Scan(\u0026friendship.UserID1, \u0026friendship.UserID2, \u0026friendship.Status, \u0026friendship.CreatedAt)\n\tif err != nil {\n\t\tif errors.Is(err, sql.ErrNoRows) {\n\t\t\treturn nil, models.ErrFriendRequestNotFound\n\t\t}\n\t\treturn nil, fmt.Errorf(\"failed to find friendship: %w\", err)\n\t}\n\treturn friendship, nil\n}\n\nfunc (r *postgresFriendshipRepository) ListByUserID(ctx context.Context, userID uuid.UUID, status models.FriendshipStatus) ([]*models.User, error) {\n\tquery := `\n\t\tSELECT u.id, u.username, u.profile_pic_url, u.created_at\n\t\tFROM users u\n\t\tJOIN friendships f ON (u.id = f.user_id1 OR u.id = f.user_id2)\n\t\tWHERE (f.user_id1 = $1 OR f.user_id2 = $1)\n\t\tAND u.id != $1\n\t\tAND f.status = $2\n\t`\n\trows, err := r.db.QueryContext(ctx, query, userID, status)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to list friends: %w\", err)\n\t}\n\tdefer rows.Close()\n\n\tvar users []*models.User\n\tfor rows.Next() {\n\t\tuser := \u0026models.User{}\n\t\tif err := rows.Scan(\u0026user.ID, \u0026user.Username, \u0026user.ProfilePicURL, \u0026user.CreatedAt); err != nil {\n\t\t\treturn nil, fmt.Errorf(\"failed to scan user row: %w\", err)\n\t\t}\n\t\tusers = append(users, user)\n\t}\n\treturn users, nil\n}\n",
  "backend/adapter/postgres/group_repo.go": "package postgres\n\nimport (\n\t\"context\"\n\t\"database/sql\"\n\t\"errors\"\n\t\"fmt\"\n\n\t\"chat-app/models\"\n\t\"chat-app/repository\"\n\n\t\"github.com/google/uuid\"\n\t\"github.com/lib/pq\"\n)\n\ntype postgresGroupRepository struct {\n\tdb *sql.DB\n}\n\nfunc NewPostgresGroupRepository(db *sql.DB) repository.GroupRepository {\n\treturn \u0026postgresGroupRepository{db: db}\n}\n\nfunc (r *postgresGroupRepository) Create(ctx context.Context, group *models.Group) error {\n\ttx, err := r.db.BeginTx(ctx, nil)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to begin transaction: %w\", err)\n\t}\n\tdefer tx.Rollback()\n\n\tquery := `INSERT INTO groups (id, handle, name, photo_url, owner_id) VALUES ($1, $2, $3, $4, $5)`\n\t_, err = tx.ExecContext(ctx, query, group.ID, group.Handle, group.Name, group.PhotoURL, group.OwnerID)\n\tif err != nil {\n\t\tif pgErr, ok := err.(*pq.Error); ok \u0026\u0026 pgErr.Code == \"23505\" { // unique_violation\n\t\t\treturn models.ErrGroupHandleTaken\n\t\t}\n\t\treturn fmt.Errorf(\"failed to create group: %w\", err)\n\t}\n\n\tmemberQuery := `INSERT INTO group_members (group_id, user_id) VALUES ($1, $2)`\n\t_, err = tx.ExecContext(ctx, memberQuery, group.ID, group.OwnerID)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to add owner as member: %w\", err)\n\t}\n\n\treturn tx.Commit()\n}\n\nfunc (r *postgresGroupRepository) Update(ctx context.Context, group *models.Group) error {\n\tquery := `UPDATE groups SET name = $2, photo_url = $3, owner_id = $4 WHERE id = $1`\n\tres, err := r.db.ExecContext(ctx, query, group.ID, group.Name, group.PhotoURL, group.OwnerID)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to update group: %w\", err)\n\t}\n\trowsAffected, err := res.RowsAffected()\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to get rows affected: %w\", err)\n\t}\n\tif rowsAffected == 0 {\n\t\treturn models.ErrGroupNotFound\n\t}\n\treturn nil\n}\n\nfunc (r *postgresGroupRepository) Delete(ctx context.Context, groupID uuid.UUID) error {\n\tquery := `DELETE FROM groups WHERE id = $1`\n\t_, err := r.db.ExecContext(ctx, query, groupID)\n\treturn err\n}\n\nfunc (r *postgresGroupRepository) FindByID(ctx context.Context, groupID uuid.UUID) (*models.Group, error) {\n\tquery := `SELECT id, handle, name, photo_url, owner_id, created_at FROM groups WHERE id = $1`\n\tgroup := \u0026models.Group{}\n\terr := r.db.QueryRowContext(ctx, query, groupID).Scan(\u0026group.ID, \u0026group.Handle, \u0026group.Name, \u0026group.PhotoURL, \u0026group.OwnerID, \u0026group.CreatedAt)\n\tif err != nil {\n\t\tif errors.Is(err, sql.ErrNoRows) {\n\t\t\treturn nil, models.ErrGroupNotFound\n\t\t}\n\t\treturn nil, fmt.Errorf(\"failed to find group by id: %w\", err)\n\t}\n\treturn group, nil\n}\n\nfunc (r *postgresGroupRepository) FindByHandle(ctx context.Context, handle string) (*models.Group, error) {\n\tquery := `SELECT id, handle, name, photo_url, owner_id, created_at FROM groups WHERE LOWER(handle) = LOWER($1)`\n\tgroup := \u0026models.Group{}\n\terr := r.db.QueryRowContext(ctx, query, handle).Scan(\u0026group.ID, \u0026group.Handle, \u0026group.Name, \u0026group.PhotoURL, \u0026group.OwnerID, \u0026group.CreatedAt)\n\tif err != nil {\n\t\tif errors.Is(err, sql.ErrNoRows) {\n\t\t\treturn nil, models.ErrGroupNotFound\n\t\t}\n\t\treturn nil, fmt.Errorf(\"failed to find group by handle: %w\", err)\n\t}\n\treturn group, nil\n}\n\nfunc (r *postgresGroupRepository) FuzzySearchByHandle(ctx context.Context, query string, limit int) ([]*models.Group, error) {\n\t// Note: For true fuzzy search, extensions like pg_trgm are better. This is a simple LIKE search.\n\tsqlQuery := `\n\t\tSELECT id, handle, name, photo_url, owner_id, created_at\n\t\tFROM groups\n\t\tWHERE LOWER(handle) LIKE LOWER($1)\n\t\tLIMIT $2\n\t`\n\trows, err := r.db.QueryContext(ctx, sqlQuery, \"%\"+query+\"%\", limit)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to search groups: %w\", err)\n\t}\n\tdefer rows.Close()\n\n\tvar groups []*models.Group\n\tfor rows.Next() {\n\t\tgroup := \u0026models.Group{}\n\t\tif err := rows.Scan(\u0026group.ID, \u0026group.Handle, \u0026group.Name, \u0026group.PhotoURL, \u0026group.OwnerID, \u0026group.CreatedAt); err != nil {\n\t\t\treturn nil, fmt.Errorf(\"failed to scan group row: %w\", err)\n\t\t}\n\t\tgroups = append(groups, group)\n\t}\n\treturn groups, nil\n}\n\nfunc (r *postgresGroupRepository) AddMember(ctx context.Context, member *models.GroupMember) error {\n\tquery := `INSERT INTO group_members (group_id, user_id) VALUES ($1, $2)`\n\t_, err := r.db.ExecContext(ctx, query, member.GroupID, member.UserID)\n\tif err != nil {\n\t\tif pgErr, ok := err.(*pq.Error); ok \u0026\u0026 pgErr.Code == \"23505\" { // unique_violation\n\t\t\treturn models.ErrAlreadyGroupMember\n\t\t}\n\t\treturn fmt.Errorf(\"failed to add group member: %w\", err)\n\t}\n\treturn nil\n}\n\nfunc (r *postgresGroupRepository) RemoveMember(ctx context.Context, groupID, userID uuid.UUID) error {\n\tquery := `DELETE FROM group_members WHERE group_id = $1 AND user_id = $2`\n\tres, err := r.db.ExecContext(ctx, query, groupID, userID)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to remove group member: %w\", err)\n\t}\n\trowsAffected, err := res.RowsAffected()\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to get rows affected: %w\", err)\n\t}\n\tif rowsAffected == 0 {\n\t\treturn models.ErrNotGroupMember\n\t}\n\treturn nil\n}\n\nfunc (r *postgresGroupRepository) FindMember(ctx context.Context, groupID, userID uuid.UUID) (*models.GroupMember, error) {\n\tquery := `SELECT group_id, user_id, joined_at FROM group_members WHERE group_id = $1 AND user_id = $2`\n\tmember := \u0026models.GroupMember{}\n\terr := r.db.QueryRowContext(ctx, query, groupID, userID).Scan(\u0026member.GroupID, \u0026member.UserID, \u0026member.JoinedAt)\n\tif err != nil {\n\t\tif errors.Is(err, sql.ErrNoRows) {\n\t\t\treturn nil, models.ErrNotGroupMember\n\t\t}\n\t\treturn nil, fmt.Errorf(\"failed to find group member: %w\", err)\n\t}\n\treturn member, nil\n}\n\nfunc (r *postgresGroupRepository) ListMembers(ctx context.Context, groupID uuid.UUID) ([]*models.User, error) {\n\tquery := `\n\t\tSELECT u.id, u.username, u.profile_pic_url, u.created_at\n\t\tFROM users u\n\t\tJOIN group_members gm ON u.id = gm.user_id\n\t\tWHERE gm.group_id = $1\n\t\tORDER BY gm.joined_at\n\t`\n\trows, err := r.db.QueryContext(ctx, query, groupID)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to list group members: %w\", err)\n\t}\n\tdefer rows.Close()\n\n\tvar users []*models.User\n\tfor rows.Next() {\n\t\tuser := \u0026models.User{}\n\t\tif err := rows.Scan(\u0026user.ID, \u0026user.Username, \u0026user.ProfilePicURL, \u0026user.CreatedAt); err != nil {\n\t\t\treturn nil, fmt.Errorf(\"failed to scan user row: %w\", err)\n\t\t}\n\t\tusers = append(users, user)\n\t}\n\treturn users, nil\n}\n\nfunc (r *postgresGroupRepository) GetOldestMember(ctx context.Context, groupID uuid.UUID) (*models.User, error) {\n\tquery := `\n\t\tSELECT u.id, u.username, u.profile_pic_url, u.created_at\n\t\tFROM users u\n\t\tJOIN group_members gm ON u.id = gm.user_id\n\t\tWHERE gm.group_id = $1\n\t\tORDER BY gm.joined_at ASC\n\t\tLIMIT 1\n\t`\n\tuser := \u0026models.User{}\n\terr := r.db.QueryRowContext(ctx, query, groupID).Scan(\u0026user.ID, \u0026user.Username, \u0026user.ProfilePicURL, \u0026user.CreatedAt)\n\tif err != nil {\n\t\tif errors.Is(err, sql.ErrNoRows) {\n\t\t\treturn nil, models.ErrGroupNotFound // Or no members, but group should have at least one\n\t\t}\n\t\treturn nil, fmt.Errorf(\"failed to get oldest member: %w\", err)\n\t}\n\treturn user, nil\n}\n",
  "backend/adapter/postgres/migrations/000001_init.sql": "CREATE EXTENSION IF NOT EXISTS \"uuid-ossp\";\n\nCREATE TABLE users (\n    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),\n    username VARCHAR(50) UNIQUE NOT NULL,\n    password_hash VARCHAR(255) NOT NULL,\n    profile_pic_url VARCHAR(255) DEFAULT '',\n    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()\n);\n\nCREATE INDEX idx_users_username ON users (LOWER(username));\n\nCREATE TABLE sessions (\n    refresh_token UUID PRIMARY KEY,\n    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,\n    expires_at TIMESTAMPTZ NOT NULL\n);\n\nCREATE INDEX idx_sessions_user_id ON sessions (user_id);\n",
  "backend/adapter/postgres/migrations/000002_add_social_features.sql": "-- +migrate Up\nCREATE TYPE friendship_status AS ENUM ('pending', 'accepted');\n\nCREATE TABLE friendships (\n    user_id1 UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,\n    user_id2 UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,\n    status friendship_status NOT NULL,\n    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),\n    PRIMARY KEY (user_id1, user_id2),\n    CHECK (user_id1 \u003c user_id2) -- Ensures canonical ordering to prevent duplicates like (A,B) and (B,A)\n);\n\nCREATE INDEX idx_friendships_user_id1 ON friendships(user_id1);\nCREATE INDEX idx_friendships_user_id2 ON friendships(user_id2);\n\nCREATE TABLE groups (\n    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),\n    handle VARCHAR(50) NOT NULL UNIQUE,\n    name VARCHAR(100) NOT NULL,\n    photo_url VARCHAR(255),\n    owner_id UUID NOT NULL REFERENCES users(id) ON DELETE SET NULL, -- Owner can leave, ownership transfers\n    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()\n);\n\nCREATE INDEX idx_groups_handle ON groups(LOWER(handle));\n\nCREATE TABLE group_members (\n    group_id UUID NOT NULL REFERENCES groups(id) ON DELETE CASCADE,\n    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,\n    joined_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),\n    PRIMARY KEY (group_id, user_id)\n);\n\nCREATE INDEX idx_group_members_group_id ON group_members(group_id);\nCREATE INDEX idx_group_members_user_id ON group_members(user_id);\n\n-- +migrate Down\nDROP TABLE IF EXISTS group_members;\nDROP TABLE IF EXISTS groups;\nDROP TABLE IF EXISTS friendships;\nDROP TYPE IF EXISTS friendship_status;\n",
  "backend/adapter/postgres/session_repo.go": "package postgres\n\nimport (\n\t\"chat-app/backend/models\"\n\t\"chat-app/backend/repository\"\n\t\"context\"\n\t\"database/sql\"\n\t\"errors\"\n\n\t\"github.com/google/uuid\"\n)\n\ntype postgresSessionRepository struct {\n\tdb *sql.DB\n}\n\nfunc NewPostgresSessionRepository(db *sql.DB) repository.SessionRepository {\n\treturn \u0026postgresSessionRepository{db: db}\n}\n\nfunc (r *postgresSessionRepository) Create(ctx context.Context, session *models.Session) error {\n\tquery := `\n        INSERT INTO sessions (refresh_token, user_id, expires_at)\n        VALUES ($1, $2, $3)\n        ON CONFLICT (refresh_token) DO UPDATE SET\n        expires_at = EXCLUDED.expires_at`\n\t_, err := r.db.ExecContext(ctx, query, session.RefreshToken, session.UserID, session.ExpiresAt)\n\treturn err\n}\n\nfunc (r *postgresSessionRepository) Find(ctx context.Context, refreshToken uuid.UUID) (*models.Session, error) {\n\tquery := `SELECT refresh_token, user_id, expires_at FROM sessions WHERE refresh_token = $1`\n\tsession := \u0026models.Session{}\n\terr := r.db.QueryRowContext(ctx, query, refreshToken).Scan(\u0026session.RefreshToken, \u0026session.UserID, \u0026session.ExpiresAt)\n\tif err != nil {\n\t\tif errors.Is(err, sql.ErrNoRows) {\n\t\t\treturn nil, models.ErrSessionNotFound\n\t\t}\n\t\treturn nil, err\n\t}\n\treturn session, nil\n}\n\nfunc (r *postgresSessionRepository) Delete(ctx context.Context, refreshToken uuid.UUID) error {\n\tquery := `DELETE FROM sessions WHERE refresh_token = $1`\n\t_, err := r.db.ExecContext(ctx, query, refreshToken)\n\treturn err\n}\n\nfunc (r *postgresSessionRepository) DeleteByUserID(ctx context.Context, userID uuid.UUID) error {\n\tquery := `DELETE FROM sessions WHERE user_id = $1`\n\t_, err := r.db.ExecContext(ctx, query, userID)\n\treturn err\n}",
  "backend/adapter/postgres/user_repo.go": "package postgres\n\nimport (\n\t\"chat-app/backend/models\"\n\t\"chat-app/backend/repository\"\n\t\"context\"\n\t\"database/sql\"\n\t\"errors\"\n\t\"strings\"\n\n\t\"github.com/google/uuid\"\n\t\"github.com/lib/pq\"\n)\n\ntype postgresUserRepository struct {\n\tdb *sql.DB\n}\n\nfunc NewPostgresUserRepository(db *sql.DB) repository.UserRepository {\n\treturn \u0026postgresUserRepository{db: db}\n}\n\nfunc (r *postgresUserRepository) Create(ctx context.Context, user *models.User) error {\n\tquery := `INSERT INTO users (id, username, password_hash, profile_pic_url) VALUES ($1, $2, $3, $4)`\n\t_, err := r.db.ExecContext(ctx, query, user.ID, user.Username, user.PasswordHash, user.ProfilePicURL)\n\tif err != nil {\n\t\tif pgErr, ok := err.(*pq.Error); ok \u0026\u0026 pgErr.Code == \"23505\" { // unique_violation\n\t\t\treturn models.ErrUsernameTaken\n\t\t}\n\t\treturn err\n\t}\n\treturn nil\n}\n\nfunc (r *postgresUserRepository) FindByUsername(ctx context.Context, username string) (*models.User, error) {\n\tquery := `SELECT id, username, password_hash, profile_pic_url, created_at FROM users WHERE LOWER(username) = $1`\n\tuser := \u0026models.User{}\n\terr := r.db.QueryRowContext(ctx, query, strings.ToLower(username)).Scan(\u0026user.ID, \u0026user.Username, \u0026user.PasswordHash, \u0026user.ProfilePicURL, \u0026user.CreatedAt)\n\tif err != nil {\n\t\tif errors.Is(err, sql.ErrNoRows) {\n\t\t\treturn nil, models.ErrUserNotFound\n\t\t}\n\t\treturn nil, err\n\t}\n\treturn user, nil\n}\n\nfunc (r *postgresUserRepository) FindByID(ctx context.Context, id uuid.UUID) (*models.User, error) {\n\tquery := `SELECT id, username, password_hash, profile_pic_url, created_at FROM users WHERE id = $1`\n\tuser := \u0026models.User{}\n\terr := r.db.QueryRowContext(ctx, query, id).Scan(\u0026user.ID, \u0026user.Username, \u0026user.PasswordHash, \u0026user.ProfilePicURL, \u0026user.CreatedAt)\n\tif err != nil {\n\t\tif errors.Is(err, sql.ErrNoRows) {\n\t\t\treturn nil, models.ErrUserNotFound\n\t\t}\n\t\treturn nil, err\n\t}\n\treturn user, nil\n}\n\nfunc (r *postgresUserRepository) Update(ctx context.Context, user *models.User) error {\n\tquery := `UPDATE users SET username = $1, password_hash = $2, profile_pic_url = $3 WHERE id = $4`\n\t_, err := r.db.ExecContext(ctx, query, user.Username, user.PasswordHash, user.ProfilePicURL, user.ID)\n\tif err != nil {\n\t\tif pgErr, ok := err.(*pq.Error); ok \u0026\u0026 pgErr.Code == \"23505\" {\n\t\t\treturn models.ErrUsernameTaken\n\t\t}\n\t\treturn err\n\t}\n\treturn nil\n}\n",
  "backend/adapter/util/password.go": "package util\n\nimport \"golang.org/x/crypto/bcrypt\"\n\nfunc HashPassword(password string) (string, error) {\n\tbytes, err := bcrypt.GenerateFromPassword([]byte(password), 14)\n\treturn string(bytes), err\n}\n\nfunc CheckPasswordHash(password, hash string) bool {\n\terr := bcrypt.CompareHashAndPassword([]byte(hash), []byte(password))\n\treturn err == nil\n}\n",
  "backend/adapter/util/response.go": "package util\n\nimport (\n\t\"encoding/json\"\n\t\"net/http\"\n)\n\nfunc RespondWithError(w http.ResponseWriter, code int, message string) {\n\tRespondWithJSON(w, code, map[string]string{\"error\": message})\n}\n\nfunc RespondWithJSON(w http.ResponseWriter, code int, payload interface{}) {\n\tresponse, _ := json.Marshal(payload)\n\tw.Header().Set(\"Content-Type\", \"application/json\")\n\tw.WriteHeader(code)\n\tw.Write(response)\n}\n",
  "backend/adapter/util/token.go": "package util\n\nimport (\n\t\"time\"\n\n\t\"github.com/golang-jwt/jwt/v5\"\n\t\"github.com/google/uuid\"\n)\n\ntype TokenGenerator interface {\n\tGenerateAccessToken(userID uuid.UUID) (string, error)\n\tGenerateRefreshToken() (uuid.UUID, time.Time, error)\n\tGetRefreshTokenExp() time.Duration\n}\n\ntype tokenGenerator struct {\n\tjwtSecret       string\n\taccessTokenExp  time.Duration\n\trefreshTokenExp time.Duration\n}\n\nfunc NewTokenGenerator(secret string, accessExp, refreshExp time.Duration) TokenGenerator {\n\treturn \u0026tokenGenerator{\n\t\tjwtSecret:       secret,\n\t\taccessTokenExp:  accessExp,\n\t\trefreshTokenExp: refreshExp,\n\t}\n}\n\nfunc (t *tokenGenerator) GenerateAccessToken(userID uuid.UUID) (string, error) {\n\tclaims := jwt.MapClaims{\n\t\t\"user_id\": userID.String(),\n\t\t\"exp\":     time.Now().Add(t.accessTokenExp).Unix(),\n\t\t\"iat\":     time.Now().Unix(),\n\t}\n\ttoken := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)\n\treturn token.SignedString([]byte(t.jwtSecret))\n}\n\nfunc (t *tokenGenerator) GenerateRefreshToken() (uuid.UUID, time.Time, error) {\n\trefreshToken := uuid.New()\n\texpiresAt := time.Now().Add(t.refreshTokenExp)\n\treturn refreshToken, expiresAt, nil\n}\n\nfunc (t *tokenGenerator) GetRefreshTokenExp() time.Duration {\n\treturn t.refreshTokenExp\n}\n",
  "backend/adapter/util/validation.go": "package util\n\nimport (\n\t\"errors\"\n\t\"mime/multipart\"\n\t\"regexp\"\n\t\"strings\"\n)\n\nvar (\n\tusernameRegex    = regexp.MustCompile(`^[a-z0-9_]{4,50}$`)\n\tgroupHandleRegex = regexp.MustCompile(`^[a-z0-9_]{4,50}$`)\n)\n\nfunc ValidateUsername(username string) error {\n\tif !usernameRegex.MatchString(username) {\n\t\treturn errors.New(\"username must be 4-50 characters and contain only lowercase letters, digits, and underscores\")\n\t}\n\treturn nil\n}\n\nfunc ValidateGroupHandle(handle string) error {\n\t// Format: string prefix + #groupname\n\tparts := strings.Split(handle, \"#\")\n\tif len(parts) != 2 || parts[0] == \"\" || parts[1] == \"\" {\n\t\treturn errors.New(\"group handle must be in the format 'prefix#groupname'\")\n\t}\n\n\tgroupname := parts[1]\n\tif !groupHandleRegex.MatchString(groupname) {\n\t\treturn errors.New(\"group name part of handle must be 4-50 characters and contain only lowercase letters, digits, and underscores\")\n\t}\n\treturn nil\n}\n\nfunc ValidatePassword(password string) error {\n\tif len(password) \u003c 8 {\n\t\treturn errors.New(\"password must be at least 8 characters long\")\n\t}\n\treturn nil\n}\n\nfunc ValidateProfilePic(header *multipart.FileHeader) error {\n\t// Max size: 200 KB\n\tif header.Size \u003e 200*1024 {\n\t\treturn errors.New(\"profile picture size cannot exceed 200 KB\")\n\t}\n\n\t// Allowed formats: png, jpg, jpeg, webp\n\tcontentType := header.Header.Get(\"Content-Type\")\n\tswitch contentType {\n\tcase \"image/png\", \"image/jpeg\", \"image/webp\":\n\t\treturn nil\n\tdefault:\n\t\treturn errors.New(\"invalid file format. Only png, jpg, jpeg, and webp are allowed\")\n\t}\n}\n",
  "backend/cmd/server/main.go": "package main\n\nimport (\n\t\"log\"\n\t\"net/http\"\n\t\"strings\"\n\n\t\"chat-app/adapter/filesystem\"\n\thttp_handler \"chat-app/adapter/handler/http\"\n\t\"chat-app/adapter/middleware\"\n\t\"chat-app/adapter/postgres\"\n\t\"chat-app/adapter/util\"\n\t\"chat-app/config\"\n\t\"chat-app/usecase\"\n\n\t\"github.com/go-chi/chi/v5\"\n\tchi_middleware \"github.com/go-chi/chi/v5/middleware\"\n\t\"github.com/go-chi/cors\"\n)\n\nfunc main() {\n\t// Load configuration\n\tcfg, err := config.Load()\n\tif err != nil {\n\t\tlog.Fatalf(\"failed to load config: %v\", err)\n\t}\n\n\t// Initialize database\n\tdb, err := postgres.NewDB(cfg)\n\tif err != nil {\n\t\tlog.Fatalf(\"failed to connect to database: %v\", err)\n\t}\n\tdefer db.Close()\n\n\t// Initialize repositories\n\tuserRepo := postgres.NewPostgresUserRepository(db)\n\tsessionRepo := postgres.NewPostgresSessionRepository(db)\n\tfileRepo := filesystem.NewLocalStorage(cfg.ProfilePicDir, cfg.ProfilePicRoute)\n\tfriendRepo := postgres.NewPostgresFriendshipRepository(db)\n\tgroupRepo := postgres.NewPostgresGroupRepository(db)\n\n\t// Initialize utilities\n\ttokenGen := util.NewTokenGenerator(cfg.JWTSecret, cfg.AccessTokenExp, cfg.RefreshTokenExp)\n\n\t// Initialize use cases\n\tauthUsecase := usecase.NewAuthUsecase(userRepo, sessionRepo, tokenGen)\n\tuserUsecase := usecase.NewUserUsecase(userRepo, fileRepo)\n\tfriendUsecase := usecase.NewFriendUsecase(userRepo, friendRepo)\n\tgroupUsecase := usecase.NewGroupUsecase(groupRepo, userRepo, friendRepo, fileRepo)\n\n\t// Initialize handlers\n\tauthHandler := http_handler.NewAuthHandler(authUsecase)\n\tuserHandler := http_handler.NewUserHandler(userUsecase)\n\tfriendHandler := http_handler.NewFriendHandler(friendUsecase)\n\tgroupHandler := http_handler.NewGroupHandler(groupUsecase)\n\n\t// Initialize middleware\n\tauthMiddleware := middleware.NewAuthMiddleware(cfg.JWTSecret)\n\n\t// Setup router\n\tr := chi.NewRouter()\n\tr.Use(chi_middleware.Logger)\n\tr.Use(cors.Handler(cors.Options{\n\t\tAllowedOrigins:   []string{\"http://*\", \"https://*\"},\n\t\tAllowedMethods:   []string{\"GET\", \"POST\", \"PUT\", \"DELETE\", \"OPTIONS\"},\n\t\tAllowedHeaders:   []string{\"Accept\", \"Authorization\", \"Content-Type\", \"X-CSRF-Token\"},\n\t\tExposedHeaders:   []string{\"Link\"},\n\t\tAllowCredentials: true,\n\t\tMaxAge:           300,\n\t}))\n\n\t// Serve static files for profile pictures\n\tfileServer(r, cfg.ProfilePicRoute, http.Dir(cfg.ProfilePicDir))\n\n\t// Public routes\n\tr.Route(\"/api\", func(r chi.Router) {\n\t\tr.Post(\"/register\", userHandler.Register)\n\t\tr.Post(\"/login\", authHandler.Login)\n\t\tr.Post(\"/refresh\", authHandler.Refresh)\n\t\tr.Post(\"/logout\", authHandler.Logout)\n\t\tr.Get(\"/users/{username}\", userHandler.GetUserByUsername)\n\t\tr.Get(\"/groups/search\", groupHandler.SearchGroups)\n\t})\n\n\t// Protected routes\n\tr.Route(\"/api\", func(r chi.Router) {\n\t\tr.Use(authMiddleware.Validate)\n\n\t\t// User profile\n\t\tr.Put(\"/profile\", userHandler.UpdateProfile)\n\n\t\t// Friends\n\t\tr.Route(\"/friends\", func(r chi.Router) {\n\t\t\tr.Get(\"/\", friendHandler.ListFriends)\n\t\t\tr.Delete(\"/{friendID}\", friendHandler.Unfriend)\n\n\t\t\tr.Route(\"/requests\", func(r chi.Router) {\n\t\t\t\tr.Get(\"/\", friendHandler.ListPendingRequests)\n\t\t\t\tr.Post(\"/\", friendHandler.SendRequest)\n\t\t\t\tr.Put(\"/{requesterID}\", friendHandler.RespondToRequest)\n\t\t\t})\n\t\t})\n\n\t\t// Groups\n\t\tr.Route(\"/groups\", func(r chi.Router) {\n\t\t\tr.Post(\"/\", groupHandler.CreateGroup)\n\t\t\tr.Post(\"/join\", groupHandler.JoinGroup)\n\n\t\t\tr.Route(\"/{groupID}\", func(r chi.Router) {\n\t\t\t\t// r.Get(\"/\", groupHandler.GetDetails)\n\t\t\t\t// r.Put(\"/\", groupHandler.UpdateGroup)\n\t\t\t\tr.Post(\"/leave\", groupHandler.LeaveGroup)\n\n\t\t\t\tr.Route(\"/members\", func(r chi.Router) {\n\t\t\t\t\t// r.Get(\"/\", groupHandler.ListMembers)\n\t\t\t\t\tr.Post(\"/\", groupHandler.AddMember)\n\t\t\t\t\tr.Delete(\"/{memberID}\", groupHandler.RemoveMember)\n\t\t\t\t})\n\t\t\t})\n\t\t})\n\t})\n\n\t// Start server\n\tlog.Printf(\"Server starting on port %s\", cfg.ServerPort)\n\tif err := http.ListenAndServe(\":\"+cfg.ServerPort, r); err != nil {\n\t\tlog.Fatalf(\"failed to start server: %v\", err)\n\t}\n}\n\nfunc fileServer(r chi.Router, path string, root http.FileSystem) {\n\tif strings.ContainsAny(path, \"{}*\") {\n\t\tpanic(\"FileServer does not permit URL parameters.\")\n\t}\n\n\tif path != \"/\" \u0026\u0026 path[len(path)-1] != '/' {\n\t\tr.Get(path, http.RedirectHandler(path+\"/\", http.StatusMovedPermanently).ServeHTTP)\n\t\tpath += \"/\"\n\t}\n\tpath += \"*\"\n\n\tr.Get(path, func(w http.ResponseWriter, r *http.Request) {\n\t\trctx := chi.RouteContext(r.Context())\n\t\tpathPrefix := strings.TrimSuffix(rctx.RoutePattern(), \"/*\")\n\t\tfs := http.StripPrefix(pathPrefix, http.FileServer(root))\n\t\tfs.ServeHTTP(w, r)\n\t})\n}\n",
  "backend/config/config.go": "package config\n\nimport (\n\t\"os\"\n\t\"strconv\"\n\t\"time\"\n\n\t\"github.com/joho/godotenv\"\n)\n\ntype Config struct {\n\tServerPort      string\n\tDBHost          string\n\tDBPort          string\n\tDBUser          string\n\tDBPassword      string\n\tDBName          string\n\tDBSslMode       string\n\tRedisAddr       string\n\tJWTSecret       string\n\tAccessTokenExp  time.Duration\n\tRefreshTokenExp time.Duration\n\tProfilePicDir   string\n\tProfilePicRoute string\n}\n\nfunc Load() (*Config, error) {\n\tif err := godotenv.Load(); err != nil {\n\t\t// Ignore error if .env file is not found, for production environments\n\t\tif !os.IsNotExist(err) {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\taccessTokenExpMin, _ := strconv.Atoi(getEnv(\"JWT_ACCESS_TOKEN_EXP_MIN\", \"10\"))\n\trefreshTokenExpHour, _ := strconv.Atoi(getEnv(\"JWT_REFRESH_TOKEN_EXP_HOUR\", \"8\"))\n\n\tcfg := \u0026Config{\n\t\tServerPort:      getEnv(\"SERVER_PORT\", \"8080\"),\n\t\tDBHost:          getEnv(\"DB_HOST\", \"localhost\"),\n\t\tDBPort:          getEnv(\"DB_PORT\", \"5432\"),\n\t\tDBUser:          getEnv(\"DB_USER\", \"user\"),\n\t\tDBPassword:      getEnv(\"DB_PASSWORD\", \"password\"),\n\t\tDBName:          getEnv(\"DB_NAME\", \"quikchat\"),\n\t\tDBSslMode:       getEnv(\"DB_SSLMODE\", \"disable\"),\n\t\tRedisAddr:       getEnv(\"REDIS_ADDR\", \"localhost:6379\"),\n\t\tJWTSecret:       getEnv(\"JWT_SECRET\", \"a_very_secret_key\"),\n\t\tAccessTokenExp:  time.Duration(accessTokenExpMin) * time.Minute,\n\t\tRefreshTokenExp: time.Duration(refreshTokenExpHour) * time.Hour,\n\t\tProfilePicDir:   getEnv(\"PROFILE_PIC_DIR\", \"./uploads/profile_pics\"),\n\t\tProfilePicRoute: getEnv(\"PROFILE_PIC_ROUTE\", \"/static/profile_pics/\"),\n\t}\n\n\t// Ensure profile pic directory exists\n\tif err := os.MkdirAll(cfg.ProfilePicDir, os.ModePerm); err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn cfg, nil\n}\n\nfunc getEnv(key, fallback string) string {\n\tif value, exists := os.LookupEnv(key); exists {\n\t\treturn value\n\t}\n\treturn fallback\n}\n",
  "backend/models/error.go": "package models\n\nimport \"errors\"\n\nvar (\n\t// User \u0026 Auth\n\tErrUserNotFound       = errors.New(\"user not found\")\n\tErrUsernameTaken      = errors.New(\"username is already taken\")\n\tErrInvalidCredentials = errors.New(\"invalid username or password\")\n\tErrSessionNotFound    = errors.New(\"session not found or expired\")\n\tErrInvalidToken       = errors.New(\"invalid token\")\n\tErrUnauthorized       = errors.New(\"unauthorized\")\n\tErrInternalServer     = errors.New(\"internal server error\")\n\tErrBadRequest         = errors.New(\"bad request\")\n\n\t// Friendship\n\tErrFriendRequestExists   = errors.New(\"friend request already exists\")\n\tErrAlreadyFriends        = errors.New(\"users are already friends\")\n\tErrNotFriends            = errors.New(\"users are not friends\")\n\tErrFriendRequestNotFound = errors.New(\"friend request not found\")\n\tErrCannotFriendSelf      = errors.New(\"cannot send friend request to yourself\")\n\n\t// Group\n\tErrGroupNotFound      = errors.New(\"group not found\")\n\tErrGroupHandleTaken   = errors.New(\"group handle is already taken\")\n\tErrNotGroupOwner      = errors.New(\"user is not the group owner\")\n\tErrNotGroupMember     = errors.New(\"user is not a group member\")\n\tErrAlreadyGroupMember = errors.New(\"user is already a group member\")\n\tErrCannotRemoveOwner  = errors.New(\"cannot remove the group owner\")\n)",
  "backend/models/friendship.go": "package models\n\nimport (\n\t\"time\"\n\n\t\"github.com/google/uuid\"\n)\n\ntype FriendshipStatus string\n\nconst (\n\tFriendshipStatusPending  FriendshipStatus = \"pending\"\n\tFriendshipStatusAccepted FriendshipStatus = \"accepted\"\n)\n\ntype Friendship struct {\n\tUserID1   uuid.UUID        `json:\"userId1\"`\n\tUserID2   uuid.UUID        `json:\"userId2\"`\n\tStatus    FriendshipStatus `json:\"status\"`\n\tCreatedAt time.Time        `json:\"createdAt\"`\n}\n",
  "backend/models/group.go": "package models\n\nimport (\n\t\"time\"\n\n\t\"github.com/google/uuid\"\n)\n\ntype Group struct {\n\tID        uuid.UUID `json:\"id\"`\n\tHandle    string    `json:\"handle\"`\n\tName      string    `json:\"name\"`\n\tPhotoURL  string    `json:\"photoUrl\"`\n\tOwnerID   uuid.UUID `json:\"ownerId\"`\n\tCreatedAt time.Time `json:\"createdAt\"`\n}\n\ntype GroupMember struct {\n\tGroupID  uuid.UUID `json:\"groupId\"`\n\tUserID   uuid.UUID `json:\"userId\"`\n\tJoinedAt time.Time `json:\"joinedAt\"`\n}\n",
  "backend/models/session.go": "package models\n\nimport (\n\t\"time\"\n\n\t\"github.com/google/uuid\"\n)\n\ntype Session struct {\n\tRefreshToken uuid.UUID `json:\"refreshToken\"`\n\tUserID       uuid.UUID `json:\"userId\"`\n\tExpiresAt    time.Time `json:\"expiresAt\"`\n}\n",
  "backend/models/user.go": "package models\n\nimport (\n\t\"time\"\n\n\t\"github.com/google/uuid\"\n)\n\ntype User struct {\n\tID           uuid.UUID `json:\"id\"`\n\tUsername     string    `json:\"username\"`\n\tPasswordHash string    `json:\"-\"`\n\tProfilePicURL string    `json:\"profilePicUrl\"`\n\tCreatedAt    time.Time `json:\"createdAt\"`\n}\n",
  "backend/repository/file_repository.go": "package repository\n\nimport \"mime/multipart\"\n\ntype FileRepository interface {\n\tSave(file multipart.File, header *multipart.FileHeader) (string, error)\n}\n",
  "backend/repository/friendship_repository.go": "package repository\n\nimport (\n\t\"context\"\n\t\"chat-app/models\"\n\n\t\"github.com/google/uuid\"\n)\n\ntype FriendshipRepository interface {\n\tCreate(ctx context.Context, friendship *models.Friendship) error\n\tUpdateStatus(ctx context.Context, userID1, userID2 uuid.UUID, status models.FriendshipStatus) error\n\tDelete(ctx context.Context, userID1, userID2 uuid.UUID) error\n\tFind(ctx context.Context, userID1, userID2 uuid.UUID) (*models.Friendship, error)\n\tListByUserID(ctx context.Context, userID uuid.UUID, status models.FriendshipStatus) ([]*models.User, error)\n}\n",
  "backend/repository/group_repository.go": "package repository\n\nimport (\n\t\"context\"\n\t\"chat-app/models\"\n\n\t\"github.com/google/uuid\"\n)\n\ntype GroupRepository interface {\n\tCreate(ctx context.Context, group *models.Group) error\n\tUpdate(ctx context.Context, group *models.Group) error\n\tDelete(ctx context.Context, groupID uuid.UUID) error\n\tFindByID(ctx context.Context, groupID uuid.UUID) (*models.Group, error)\n\tFindByHandle(ctx context.Context, handle string) (*models.Group, error)\n\tFuzzySearchByHandle(ctx context.Context, query string, limit int) ([]*models.Group, error)\n\n\tAddMember(ctx context.Context, member *models.GroupMember) error\n\tRemoveMember(ctx context.Context, groupID, userID uuid.UUID) error\n\tFindMember(ctx context.Context, groupID, userID uuid.UUID) (*models.GroupMember, error)\n\tListMembers(ctx context.Context, groupID uuid.UUID) ([]*models.User, error)\n\tGetOldestMember(ctx context.Context, groupID uuid.UUID) (*models.User, error)\n}\n",
  "backend/repository/session_repository.go": "package repository\n\nimport (\n\t\"chat-app/backend/models\"\n\t\"context\"\n\n\t\"github.com/google/uuid\"\n)\n\ntype SessionRepository interface {\n\tCreate(ctx context.Context, session *models.Session) error\n\tFind(ctx context.Context, refreshToken uuid.UUID) (*models.Session, error)\n\tDelete(ctx context.Context, refreshToken uuid.UUID) error\n\tDeleteByUserID(ctx context.Context, userID uuid.UUID) error\n}\n",
  "backend/repository/user_repository.go": "package repository\n\nimport (\n\t\"chat-app/backend/models\"\n\t\"context\"\n\n\t\"github.com/google/uuid\"\n)\n\ntype UserRepository interface {\n\tCreate(ctx context.Context, user *models.User) error\n\tFindByUsername(ctx context.Context, username string) (*models.User, error)\n\tFindByID(ctx context.Context, id uuid.UUID) (*models.User, error)\n\tUpdate(ctx context.Context, user *models.User) error\n}\n",
  "backend/usecase/auth_usecase.go": "package usecase\n\nimport (\n\t\"chat-app/backend/adapter/util\"\n\t\"chat-app/backend/models\"\n\t\"chat-app/backend/repository\"\n\t\"context\"\n\t\"errors\"\n\t\"time\"\n\n\t\"github.com/google/uuid\"\n)\n\ntype AuthUsecase interface {\n\tLogin(ctx context.Context, username, password string) (accessToken string, refreshToken string, err error)\n\tRefresh(ctx context.Context, refreshToken string) (newAccessToken string, err error)\n\tLogout(ctx context.Context, refreshToken string) error\n}\n\ntype authUsecase struct {\n\tuserRepo    repository.UserRepository\n\tsessionRepo repository.SessionRepository\n\ttokenGen    util.TokenGenerator\n}\n\nfunc NewAuthUsecase(userRepo repository.UserRepository, sessionRepo repository.SessionRepository, tokenGen util.TokenGenerator) AuthUsecase {\n\treturn \u0026authUsecase{\n\t\tuserRepo:    userRepo,\n\t\tsessionRepo: sessionRepo,\n\t\ttokenGen:    tokenGen,\n\t}\n}\n\nfunc (a *authUsecase) Login(ctx context.Context, username, password string) (string, string, error) {\n\tuser, err := a.userRepo.FindByUsername(ctx, username)\n\tif err != nil {\n\t\tif errors.Is(err, models.ErrUserNotFound) {\n\t\t\treturn \"\", \"\", models.ErrInvalidCredentials\n\t\t}\n\t\treturn \"\", \"\", err\n\t}\n\n\tif !util.CheckPasswordHash(password, user.PasswordHash) {\n\t\treturn \"\", \"\", models.ErrInvalidCredentials\n\t}\n\n\t// Single device policy: remove old sessions\n\tif err := a.sessionRepo.DeleteByUserID(ctx, user.ID); err != nil {\n\t\t// Log error but continue, as this is not critical for login\n\t\t// log.Printf(\"failed to delete old sessions for user %s: %v\", user.ID, err)\n\t}\n\n\taccessToken, err := a.tokenGen.GenerateAccessToken(user.ID)\n\tif err != nil {\n\t\treturn \"\", \"\", err\n\t}\n\n\trefreshToken, expiresAt, err := a.tokenGen.GenerateRefreshToken()\n\tif err != nil {\n\t\treturn \"\", \"\", err\n\t}\n\n\tsession := \u0026models.Session{\n\t\tRefreshToken: refreshToken,\n\t\tUserID:       user.ID,\n\t\tExpiresAt:    expiresAt,\n\t}\n\n\tif err := a.sessionRepo.Create(ctx, session); err != nil {\n\t\treturn \"\", \"\", err\n\t}\n\n\treturn accessToken, refreshToken.String(), nil\n}\n\nfunc (a *authUsecase) Refresh(ctx context.Context, refreshTokenStr string) (string, error) {\n\trefreshToken, err := uuid.Parse(refreshTokenStr)\n\tif err != nil {\n\t\treturn \"\", models.ErrInvalidToken\n\t}\n\n\tsession, err := a.sessionRepo.Find(ctx, refreshToken)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\tif session.ExpiresAt.Before(time.Now()) {\n\t\t// Clean up expired session\n\t\t_ = a.sessionRepo.Delete(ctx, refreshToken)\n\t\treturn \"\", models.ErrSessionNotFound\n\t}\n\n\t// Sliding window: extend session expiry\n\tsession.ExpiresAt = time.Now().Add(a.tokenGen.GetRefreshTokenExp())\n\tif err := a.sessionRepo.Create(ctx, session); err != nil { // Create will UPSERT\n\t\treturn \"\", err\n\t}\n\n\tnewAccessToken, err := a.tokenGen.GenerateAccessToken(session.UserID)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\treturn newAccessToken, nil\n}\n\nfunc (a *authUsecase) Logout(ctx context.Context, refreshTokenStr string) error {\n\trefreshToken, err := uuid.Parse(refreshTokenStr)\n\tif err != nil {\n\t\treturn models.ErrInvalidToken\n\t}\n\treturn a.sessionRepo.Delete(ctx, refreshToken)\n}\n",
  "backend/usecase/friend_usecase.go": "package usecase\n\nimport (\n\t\"context\"\n\n\t\"chat-app/models\"\n\t\"chat-app/repository\"\n\n\t\"github.com/google/uuid\"\n)\n\ntype FriendUsecase interface {\n\tSendRequest(ctx context.Context, fromUserID uuid.UUID, toUsername string) error\n\tAcceptRequest(ctx context.Context, userID, requesterID uuid.UUID) error\n\tRejectRequest(ctx context.Context, userID, requesterID uuid.UUID) error\n\tUnfriend(ctx context.Context, userID, friendID uuid.UUID) error\n\tListFriends(ctx context.Context, userID uuid.UUID) ([]*models.User, error)\n\tListPendingRequests(ctx context.Context, userID uuid.UUID) ([]*models.User, error)\n}\n\ntype friendUsecase struct {\n\tuserRepo   repository.UserRepository\n\tfriendRepo repository.FriendshipRepository\n}\n\nfunc NewFriendUsecase(userRepo repository.UserRepository, friendRepo repository.FriendshipRepository) FriendUsecase {\n\treturn \u0026friendUsecase{\n\t\tuserRepo:   userRepo,\n\t\tfriendRepo: friendRepo,\n\t}\n}\n\nfunc (u *friendUsecase) SendRequest(ctx context.Context, fromUserID uuid.UUID, toUsername string) error {\n\ttoUser, err := u.userRepo.FindByUsername(ctx, toUsername)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif fromUserID == toUser.ID {\n\t\treturn models.ErrCannotFriendSelf\n\t}\n\n\t// Check if a friendship or request already exists\n\texisting, err := u.friendRepo.Find(ctx, fromUserID, toUser.ID)\n\tif err != nil \u0026\u0026 err != models.ErrFriendRequestNotFound {\n\t\treturn err\n\t}\n\tif existing != nil {\n\t\tif existing.Status == models.FriendshipStatusAccepted {\n\t\t\treturn models.ErrAlreadyFriends\n\t\t}\n\t\treturn models.ErrFriendRequestExists\n\t}\n\n\tfriendship := \u0026models.Friendship{\n\t\tUserID1: fromUserID,\n\t\tUserID2: toUser.ID,\n\t\tStatus:  models.FriendshipStatusPending,\n\t}\n\n\treturn u.friendRepo.Create(ctx, friendship)\n}\n\nfunc (u *friendUsecase) AcceptRequest(ctx context.Context, userID, requesterID uuid.UUID) error {\n\tfriendship, err := u.friendRepo.Find(ctx, userID, requesterID)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif friendship.Status != models.FriendshipStatusPending {\n\t\treturn models.ErrFriendRequestNotFound\n\t}\n\n\tif friendship.UserID1 != userID \u0026\u0026 friendship.UserID2 != userID {\n\t\treturn models.ErrUnauthorized\n\t}\n\n\treturn u.friendRepo.UpdateStatus(ctx, userID, requesterID, models.FriendshipStatusAccepted)\n}\n\nfunc (u *friendUsecase) RejectRequest(ctx context.Context, userID, requesterID uuid.UUID) error {\n\tfriendship, err := u.friendRepo.Find(ctx, userID, requesterID)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif friendship.Status != models.FriendshipStatusPending {\n\t\treturn models.ErrFriendRequestNotFound\n\t}\n\n\tif friendship.UserID1 != userID \u0026\u0026 friendship.UserID2 != userID {\n\t\treturn models.ErrUnauthorized\n\t}\n\n\treturn u.friendRepo.Delete(ctx, userID, requesterID)\n}\n\nfunc (u *friendUsecase) Unfriend(ctx context.Context, userID, friendID uuid.UUID) error {\n\tfriendship, err := u.friendRepo.Find(ctx, userID, friendID)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif friendship.Status != models.FriendshipStatusAccepted {\n\t\treturn models.ErrNotFriends\n\t}\n\n\treturn u.friendRepo.Delete(ctx, userID, friendID)\n}\n\nfunc (u *friendUsecase) ListFriends(ctx context.Context, userID uuid.UUID) ([]*models.User, error) {\n\treturn u.friendRepo.ListByUserID(ctx, userID, models.FriendshipStatusAccepted)\n}\n\nfunc (u *friendUsecase) ListPendingRequests(ctx context.Context, userID uuid.UUID) ([]*models.User, error) {\n\treturn u.friendRepo.ListByUserID(ctx, userID, models.FriendshipStatusPending)\n}\n",
  "backend/usecase/group_usecase.go": "package usecase\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"mime/multipart\"\n\n\t\"chat-app/adapter/util\"\n\t\"chat-app/models\"\n\t\"chat-app/repository\"\n\n\t\"github.com/google/uuid\"\n)\n\ntype GroupUsecase interface {\n\tCreateGroup(ctx context.Context, ownerID uuid.UUID, handle, name string, photo multipart.File, photoHeader *multipart.FileHeader) (*models.Group, error)\n\tUpdateGroup(ctx context.Context, userID, groupID uuid.UUID, name *string, photo multipart.File, photoHeader *multipart.FileHeader) (*models.Group, error)\n\tJoinGroup(ctx context.Context, userID uuid.UUID, groupHandle string) error\n\tLeaveGroup(ctx context.Context, userID, groupID uuid.UUID) error\n\tAddMember(ctx context.Context, adderID uuid.UUID, newMemberUsername string, groupID uuid.UUID) error\n\tRemoveMember(ctx context.Context, ownerID, memberID, groupID uuid.UUID) error\n\tTransferOwnership(ctx context.Context, currentOwnerID, newOwnerID, groupID uuid.UUID) error\n\tSearchGroups(ctx context.Context, query string) ([]*models.Group, error)\n\tGetGroupDetails(ctx context.Context, groupID uuid.UUID) (*models.Group, error)\n\tListGroupMembers(ctx context.Context, groupID uuid.UUID) ([]*models.User, error)\n}\n\ntype groupUsecase struct {\n\tgroupRepo  repository.GroupRepository\n\tuserRepo   repository.UserRepository\n\tfriendRepo repository.FriendshipRepository\n\tfileRepo   repository.FileRepository\n}\n\nfunc NewGroupUsecase(groupRepo repository.GroupRepository, userRepo repository.UserRepository, friendRepo repository.FriendshipRepository, fileRepo repository.FileRepository) GroupUsecase {\n\treturn \u0026groupUsecase{\n\t\tgroupRepo:  groupRepo,\n\t\tuserRepo:   userRepo,\n\t\tfriendRepo: friendRepo,\n\t\tfileRepo:   fileRepo,\n\t}\n}\n\nfunc (u *groupUsecase) CreateGroup(ctx context.Context, ownerID uuid.UUID, handle, name string, photo multipart.File, photoHeader *multipart.FileHeader) (*models.Group, error) {\n\tif err := util.ValidateGroupHandle(handle); err != nil {\n\t\treturn nil, err\n\t}\n\n\tvar photoURL string\n\tvar err error\n\tif photo != nil \u0026\u0026 photoHeader != nil {\n\t\tif err := util.ValidateProfilePic(photoHeader); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tphotoURL, err = u.fileRepo.Save(photo, photoHeader)\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"failed to save group photo: %w\", err)\n\t\t}\n\t}\n\n\tgroup := \u0026models.Group{\n\t\tID:       uuid.New(),\n\t\tHandle:   handle,\n\t\tName:     name,\n\t\tPhotoURL: photoURL,\n\t\tOwnerID:  ownerID,\n\t}\n\n\tif err := u.groupRepo.Create(ctx, group); err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn group, nil\n}\n\nfunc (u *groupUsecase) UpdateGroup(ctx context.Context, userID, groupID uuid.UUID, name *string, photo multipart.File, photoHeader *multipart.FileHeader) (*models.Group, error) {\n\tgroup, err := u.groupRepo.FindByID(ctx, groupID)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tif group.OwnerID != userID {\n\t\treturn nil, models.ErrNotGroupOwner\n\t}\n\n\tif name != nil {\n\t\tgroup.Name = *name\n\t}\n\n\tif photo != nil \u0026\u0026 photoHeader != nil {\n\t\tif err := util.ValidateProfilePic(photoHeader); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tphotoURL, err := u.fileRepo.Save(photo, photoHeader)\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"failed to save group photo: %w\", err)\n\t\t}\n\t\tgroup.PhotoURL = photoURL\n\t}\n\n\tif err := u.groupRepo.Update(ctx, group); err != nil {\n\t\treturn nil, err\n\t}\n\treturn group, nil\n}\n\nfunc (u *groupUsecase) JoinGroup(ctx context.Context, userID uuid.UUID, groupHandle string) error {\n\tgroup, err := u.groupRepo.FindByHandle(ctx, groupHandle)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tmember := \u0026models.GroupMember{\n\t\tGroupID: group.ID,\n\t\tUserID:  userID,\n\t}\n\n\treturn u.groupRepo.AddMember(ctx, member)\n}\n\nfunc (u *groupUsecase) LeaveGroup(ctx context.Context, userID, groupID uuid.UUID) error {\n\tgroup, err := u.groupRepo.FindByID(ctx, groupID)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif err := u.groupRepo.RemoveMember(ctx, groupID, userID); err != nil {\n\t\treturn err\n\t}\n\n\t// If the owner leaves, transfer ownership\n\tif group.OwnerID == userID {\n\t\toldestMember, err := u.groupRepo.GetOldestMember(ctx, groupID)\n\t\tif err != nil {\n\t\t\t// If no members are left, the group can be deleted or left ownerless.\n\t\t\t// Let's assume it gets deleted.\n\t\t\tif err == models.ErrGroupNotFound { // No members left\n\t\t\t\treturn u.groupRepo.Delete(ctx, groupID)\n\t\t\t}\n\t\t\treturn fmt.Errorf(\"failed to find new owner: %w\", err)\n\t\t}\n\t\tgroup.OwnerID = oldestMember.ID\n\t\tif err := u.groupRepo.Update(ctx, group); err != nil {\n\t\t\treturn fmt.Errorf(\"failed to transfer ownership: %w\", err)\n\t\t}\n\t}\n\n\treturn nil\n}\n\nfunc (u *groupUsecase) AddMember(ctx context.Context, adderID uuid.UUID, newMemberUsername string, groupID uuid.UUID) error {\n\t// Check if adder is a member of the group\n\tif _, err := u.groupRepo.FindMember(ctx, groupID, adderID); err != nil {\n\t\treturn models.ErrNotGroupMember\n\t}\n\n\t// Find the user to be added\n\tnewMember, err := u.userRepo.FindByUsername(ctx, newMemberUsername)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Check if adder and new member are friends\n\tfriendship, err := u.friendRepo.Find(ctx, adderID, newMember.ID)\n\tif err != nil || friendship.Status != models.FriendshipStatusAccepted {\n\t\treturn models.ErrNotFriends\n\t}\n\n\tmember := \u0026models.GroupMember{\n\t\tGroupID: groupID,\n\t\tUserID:  newMember.ID,\n\t}\n\n\treturn u.groupRepo.AddMember(ctx, member)\n}\n\nfunc (u *groupUsecase) RemoveMember(ctx context.Context, ownerID, memberID, groupID uuid.UUID) error {\n\tgroup, err := u.groupRepo.FindByID(ctx, groupID)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif group.OwnerID != ownerID {\n\t\treturn models.ErrNotGroupOwner\n\t}\n\n\tif ownerID == memberID {\n\t\treturn models.ErrCannotRemoveOwner\n\t}\n\n\treturn u.groupRepo.RemoveMember(ctx, groupID, memberID)\n}\n\nfunc (u *groupUsecase) TransferOwnership(ctx context.Context, currentOwnerID, newOwnerID, groupID uuid.UUID) error {\n\tgroup, err := u.groupRepo.FindByID(ctx, groupID)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif group.OwnerID != currentOwnerID {\n\t\treturn models.ErrNotGroupOwner\n\t}\n\n\t// Check if new owner is a member\n\tif _, err := u.groupRepo.FindMember(ctx, groupID, newOwnerID); err != nil {\n\t\treturn err\n\t}\n\n\tgroup.OwnerID = newOwnerID\n\treturn u.groupRepo.Update(ctx, group)\n}\n\nfunc (u *groupUsecase) SearchGroups(ctx context.Context, query string) ([]*models.Group, error) {\n\treturn u.groupRepo.FuzzySearchByHandle(ctx, query, 10) // Limit to 10 results\n}\n\nfunc (u *groupUsecase) GetGroupDetails(ctx context.Context, groupID uuid.UUID) (*models.Group, error) {\n\treturn u.groupRepo.FindByID(ctx, groupID)\n}\n\nfunc (u *groupUsecase) ListGroupMembers(ctx context.Context, groupID uuid.UUID) ([]*models.User, error) {\n\treturn u.groupRepo.ListMembers(ctx, groupID)\n}\n",
  "backend/usecase/user_usecase.go": "package usecase\n\nimport (\n\t\"chat-app/backend/adapter/util\"\n\t\"chat-app/backend/models\"\n\t\"chat-app/backend/repository\"\n\t\"context\"\n\t\"errors\"\n\t\"mime/multipart\"\n\t\"strings\"\n\n\t\"github.com/google/uuid\"\n)\n\ntype UserUsecase interface {\n\tRegister(ctx context.Context, username, password string) (*models.User, error)\n\tGetByUsername(ctx context.Context, username string) (*models.User, error)\n\tUpdateProfile(ctx context.Context, userID uuid.UUID, username, password *string, profilePic multipart.File, profilePicHeader *multipart.FileHeader) (*models.User, error)\n}\n\ntype userUsecase struct {\n\tuserRepo repository.UserRepository\n\tfileRepo repository.FileRepository\n}\n\nfunc NewUserUsecase(userRepo repository.UserRepository, fileRepo repository.FileRepository) UserUsecase {\n\treturn \u0026userUsecase{\n\t\tuserRepo: userRepo,\n\t\tfileRepo: fileRepo,\n\t}\n}\n\nfunc (u *userUsecase) Register(ctx context.Context, username, password string) (*models.User, error) {\n\tif err := util.ValidateUsername(username); err != nil {\n\t\treturn nil, err\n\t}\n\tif err := util.ValidatePassword(password); err != nil {\n\t\treturn nil, err\n\t}\n\n\texistingUser, err := u.userRepo.FindByUsername(ctx, username)\n\tif err != nil \u0026\u0026 !errors.Is(err, models.ErrUserNotFound) {\n\t\treturn nil, err\n\t}\n\tif existingUser != nil {\n\t\treturn nil, models.ErrUsernameTaken\n\t}\n\n\thashedPassword, err := util.HashPassword(password)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tuser := \u0026models.User{\n\t\tID:           uuid.New(),\n\t\tUsername:     strings.ToLower(username),\n\t\tPasswordHash: hashedPassword,\n\t}\n\n\tif err := u.userRepo.Create(ctx, user); err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn user, nil\n}\n\nfunc (u *userUsecase) GetByUsername(ctx context.Context, username string) (*models.User, error) {\n\treturn u.userRepo.FindByUsername(ctx, username)\n}\n\nfunc (u *userUsecase) UpdateProfile(ctx context.Context, userID uuid.UUID, username, password *string, profilePic multipart.File, profilePicHeader *multipart.FileHeader) (*models.User, error) {\n\tuser, err := u.userRepo.FindByID(ctx, userID)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tif username != nil {\n\t\tif err := util.ValidateUsername(*username); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\t// Check if new username is taken by another user\n\t\texistingUser, err := u.userRepo.FindByUsername(ctx, *username)\n\t\tif err != nil \u0026\u0026 !errors.Is(err, models.ErrUserNotFound) {\n\t\t\treturn nil, err\n\t\t}\n\t\tif existingUser != nil \u0026\u0026 existingUser.ID != userID {\n\t\t\treturn nil, models.ErrUsernameTaken\n\t\t}\n\t\tuser.Username = strings.ToLower(*username)\n\t}\n\n\tif password != nil {\n\t\tif err := util.ValidatePassword(*password); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\thashedPassword, err := util.HashPassword(*password)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tuser.PasswordHash = hashedPassword\n\t}\n\n\tif profilePic != nil {\n\t\tif err := util.ValidateProfilePic(profilePicHeader); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tpicURL, err := u.fileRepo.Save(profilePic, profilePicHeader)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tuser.ProfilePicURL = picURL\n\t}\n\n\tif err := u.userRepo.Update(ctx, user); err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn user, nil\n}\n",
  "docker-compose.yml": "version: '3.8'\n\nservices:\n  postgres:\n    image: postgres:13\n    container_name: quikchat_postgres\n    environment:\n      POSTGRES_USER: ${DB_USER:-user}\n      POSTGRES_PASSWORD: ${DB_PASSWORD:-password}\n      POSTGRES_DB: ${DB_NAME:-quikchat}\n    ports:\n      - \"${DB_PORT:-5432}:5432\"\n    volumes:\n      - postgres_data:/var/lib/postgresql/data\n      - ./backend/adapter/postgres/migrations:/docker-entrypoint-initdb.d\n    restart: unless-stopped\n\n  redis:\n    image: redis:6.2-alpine\n    container_name: quikchat_redis\n    ports:\n      - \"6379:6379\"\n    restart: unless-stopped\n\nvolumes:\n  postgres_data:\n"
}