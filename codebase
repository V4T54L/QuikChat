{
  ".env.example": "# Server\nSERVER_PORT=8080\n\n# Postgres\nDB_HOST=localhost\nDB_PORT=5432\nDB_USER=user\nDB_PASSWORD=password\nDB_NAME=quikchat\nDB_SSLMODE=disable\n\n# Redis\nREDIS_ADDR=localhost:6379\nREDIS_PASSWORD=\n\n# JWT\nJWT_SECRET=a-very-secret-key-that-is-long-enough\nJWT_ACCESS_TOKEN_EXP_MIN=10\nJWT_REFRESH_TOKEN_EXP_HOUR=8\n\n# File Storage\nPROFILE_PIC_DIR=./uploads/profile_pics\nSTATIC_FILES_DIR=./web/static\nPROFILE_PIC_ROUTE=/static/profile_pics\n",
  "Makefile": ".PHONY: run docker-up docker-down\n\nrun:\n\t@echo \"Starting application...\"\n\t@go run ./backend/cmd/server/main.go\n\ndocker-up:\n\t@echo \"Starting Docker containers...\"\n\t@docker-compose up -d\n\ndocker-down:\n\t@echo \"Stopping Docker containers...\"\n\t@docker-compose down\n",
  "backend/adapter/filesystem/local_storage.go": "package filesystem\n\nimport (\n\t\"chat-app/backend/repository\"\n\t\"fmt\"\n\t\"io\"\n\t\"mime/multipart\"\n\t\"os\"\n\t\"path/filepath\"\n\n\t\"github.com/google/uuid\"\n)\n\ntype localStorage struct {\n\tstorageDir string\n\troutePath  string\n}\n\nfunc NewLocalStorage(storageDir, routePath string) repository.FileRepository {\n\treturn \u0026localStorage{\n\t\tstorageDir: storageDir,\n\t\troutePath:  routePath,\n\t}\n}\n\nfunc (l *localStorage) Save(file multipart.File, header *multipart.FileHeader) (string, error) {\n\tdefer file.Close()\n\n\text := filepath.Ext(header.Filename)\n\trandomFilename := fmt.Sprintf(\"%s%s\", uuid.New().String(), ext)\n\tfilePath := filepath.Join(l.storageDir, randomFilename)\n\n\tdst, err := os.Create(filePath)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\tdefer dst.Close()\n\n\tif _, err := io.Copy(dst, file); err != nil {\n\t\treturn \"\", err\n\t}\n\n\tfileURL := filepath.Join(l.routePath, randomFilename)\n\treturn fileURL, nil\n}\n",
  "backend/adapter/handler/http/auth_handler.go": "package http\n\nimport (\n\t\"chat-app/backend/adapter/util\"\n\t\"chat-app/backend/models\"\n\t\"encoding/json\"\n\t\"errors\"\n\t\"net/http\"\n)\n\ntype loginRequest struct {\n\tUsername string `json:\"username\"`\n\tPassword string `json:\"password\"`\n}\n\ntype loginResponse struct {\n\tAccessToken  string `json:\"accessToken\"`\n\tRefreshToken string `json:\"refreshToken\"`\n}\n\nfunc (h *AuthHandler) Login(w http.ResponseWriter, r *http.Request) {\n\tvar req loginRequest\n\tif err := json.NewDecoder(r.Body).Decode(\u0026req); err != nil {\n\t\tutil.RespondWithError(w, http.StatusBadRequest, \"Invalid request payload\")\n\t\treturn\n\t}\n\n\taccessToken, refreshToken, err := h.authUsecase.Login(r.Context(), req.Username, req.Password)\n\tif err != nil {\n\t\tif errors.Is(err, models.ErrInvalidCredentials) {\n\t\t\tutil.RespondWithError(w, http.StatusUnauthorized, err.Error())\n\t\t\treturn\n\t\t}\n\t\tutil.RespondWithError(w, http.StatusInternalServerError, \"Failed to login\")\n\t\treturn\n\t}\n\n\tutil.RespondWithJSON(w, http.StatusOK, loginResponse{\n\t\tAccessToken:  accessToken,\n\t\tRefreshToken: refreshToken,\n\t})\n}\n\ntype refreshRequest struct {\n\tRefreshToken string `json:\"refreshToken\"`\n}\n\ntype refreshResponse struct {\n\tAccessToken string `json:\"accessToken\"`\n}\n\nfunc (h *AuthHandler) Refresh(w http.ResponseWriter, r *http.Request) {\n\tvar req refreshRequest\n\tif err := json.NewDecoder(r.Body).Decode(\u0026req); err != nil {\n\t\tutil.RespondWithError(w, http.StatusBadRequest, \"Invalid request payload\")\n\t\treturn\n\t}\n\n\tnewAccessToken, err := h.authUsecase.Refresh(r.Context(), req.RefreshToken)\n\tif err != nil {\n\t\tif errors.Is(err, models.ErrSessionNotFound) || errors.Is(err, models.ErrInvalidToken) {\n\t\t\tutil.RespondWithError(w, http.StatusUnauthorized, err.Error())\n\t\t\treturn\n\t\t}\n\t\tutil.RespondWithError(w, http.StatusInternalServerError, \"Failed to refresh token\")\n\t\treturn\n\t}\n\n\tutil.RespondWithJSON(w, http.StatusOK, refreshResponse{AccessToken: newAccessToken})\n}\n\ntype logoutRequest struct {\n\tRefreshToken string `json:\"refreshToken\"`\n}\n\nfunc (h *AuthHandler) Logout(w http.ResponseWriter, r *http.Request) {\n\tvar req logoutRequest\n\tif err := json.NewDecoder(r.Body).Decode(\u0026req); err != nil {\n\t\tutil.RespondWithError(w, http.StatusBadRequest, \"Invalid request payload\")\n\t\treturn\n\t}\n\n\tif err := h.authUsecase.Logout(r.Context(), req.RefreshToken); err != nil {\n\t\t// We can choose to not return an error to the client for logout failures\n\t\t// for security reasons, but for simplicity we will.\n\t\tutil.RespondWithError(w, http.StatusInternalServerError, \"Failed to logout\")\n\t\treturn\n\t}\n\n\tutil.RespondWithJSON(w, http.StatusOK, map[string]string{\"message\": \"Logged out successfully\"})\n}\n",
  "backend/adapter/handler/http/friend_handler.go": "package http\n\nimport (\n\t\"encoding/json\"\n\t\"errors\"\n\t\"net/http\"\n\n\t\"chat-app/adapter/middleware\"\n\t\"chat-app/adapter/util\"\n\t\"chat-app/models\"\n\n\t\"github.com/go-chi/chi/v5\"\n\t\"github.com/google/uuid\"\n)\n\nfunc (h *FriendHandler) SendRequest(w http.ResponseWriter, r *http.Request) {\n\tuserID, ok := r.Context().Value(middleware.UserIDKey).(uuid.UUID)\n\tif !ok {\n\t\tutil.RespondWithError(w, http.StatusUnauthorized, \"Invalid user ID in token\")\n\t\treturn\n\t}\n\n\tvar req struct {\n\t\tUsername string `json:\"username\"`\n\t}\n\tif err := json.NewDecoder(r.Body).Decode(\u0026req); err != nil {\n\t\tutil.RespondWithError(w, http.StatusBadRequest, \"Invalid request payload\")\n\t\treturn\n\t}\n\n\terr := h.friendUsecase.SendRequest(r.Context(), userID, req.Username)\n\tif err != nil {\n\t\tswitch {\n\t\tcase errors.Is(err, models.ErrUserNotFound):\n\t\t\tutil.RespondWithError(w, http.StatusNotFound, err.Error())\n\t\tcase errors.Is(err, models.ErrAlreadyFriends), errors.Is(err, models.ErrFriendRequestExists), errors.Is(err, models.ErrCannotFriendSelf):\n\t\t\tutil.RespondWithError(w, http.StatusConflict, err.Error())\n\t\tdefault:\n\t\t\tutil.RespondWithError(w, http.StatusInternalServerError, \"Could not send friend request\")\n\t\t}\n\t\treturn\n\t}\n\n\tutil.RespondWithJSON(w, http.StatusCreated, map[string]string{\"message\": \"Friend request sent\"})\n}\n\nfunc (h *FriendHandler) RespondToRequest(w http.ResponseWriter, r *http.Request) {\n\tuserID, ok := r.Context().Value(middleware.UserIDKey).(uuid.UUID)\n\tif !ok {\n\t\tutil.RespondWithError(w, http.StatusUnauthorized, \"Invalid user ID in token\")\n\t\treturn\n\t}\n\n\trequesterIDStr := chi.URLParam(r, \"requesterID\")\n\trequesterID, err := uuid.Parse(requesterIDStr)\n\tif err != nil {\n\t\tutil.RespondWithError(w, http.StatusBadRequest, \"Invalid requester ID\")\n\t\treturn\n\t}\n\n\tvar req struct {\n\t\tAction string `json:\"action\"` // \"accept\" or \"reject\"\n\t}\n\tif err := json.NewDecoder(r.Body).Decode(\u0026req); err != nil {\n\t\tutil.RespondWithError(w, http.StatusBadRequest, \"Invalid request payload\")\n\t\treturn\n\t}\n\n\tvar usecaseErr error\n\tmessage := \"\"\n\tif req.Action == \"accept\" {\n\t\tusecaseErr = h.friendUsecase.AcceptRequest(r.Context(), userID, requesterID)\n\t\tmessage = \"Friend request accepted\"\n\t} else if req.Action == \"reject\" {\n\t\tusecaseErr = h.friendUsecase.RejectRequest(r.Context(), userID, requesterID)\n\t\tmessage = \"Friend request rejected\"\n\t} else {\n\t\tutil.RespondWithError(w, http.StatusBadRequest, \"Invalid action\")\n\t\treturn\n\t}\n\n\tif usecaseErr != nil {\n\t\tswitch {\n\t\tcase errors.Is(usecaseErr, models.ErrFriendRequestNotFound):\n\t\t\tutil.RespondWithError(w, http.StatusNotFound, usecaseErr.Error())\n\t\tdefault:\n\t\t\tutil.RespondWithError(w, http.StatusInternalServerError, \"Could not respond to friend request\")\n\t\t}\n\t\treturn\n\t}\n\n\tutil.RespondWithJSON(w, http.StatusOK, map[string]string{\"message\": message})\n}\n\nfunc (h *FriendHandler) Unfriend(w http.ResponseWriter, r *http.Request) {\n\tuserID, ok := r.Context().Value(middleware.UserIDKey).(uuid.UUID)\n\tif !ok {\n\t\tutil.RespondWithError(w, http.StatusUnauthorized, \"Invalid user ID in token\")\n\t\treturn\n\t}\n\n\tfriendIDStr := chi.URLParam(r, \"friendID\")\n\tfriendID, err := uuid.Parse(friendIDStr)\n\tif err != nil {\n\t\tutil.RespondWithError(w, http.StatusBadRequest, \"Invalid friend ID\")\n\t\treturn\n\t}\n\n\terr = h.friendUsecase.Unfriend(r.Context(), userID, friendID)\n\tif err != nil {\n\t\tswitch {\n\t\tcase errors.Is(err, models.ErrNotFriends), errors.Is(err, models.ErrFriendRequestNotFound):\n\t\t\tutil.RespondWithError(w, http.StatusNotFound, err.Error())\n\t\tdefault:\n\t\t\tutil.RespondWithError(w, http.StatusInternalServerError, \"Could not unfriend user\")\n\t\t}\n\t\treturn\n\t}\n\n\tw.WriteHeader(http.StatusNoContent)\n}\n\nfunc (h *FriendHandler) ListFriends(w http.ResponseWriter, r *http.Request) {\n\tuserID, ok := r.Context().Value(middleware.UserIDKey).(uuid.UUID)\n\tif !ok {\n\t\tutil.RespondWithError(w, http.StatusUnauthorized, \"Invalid user ID in token\")\n\t\treturn\n\t}\n\n\tfriends, err := h.friendUsecase.ListFriends(r.Context(), userID)\n\tif err != nil {\n\t\tutil.RespondWithError(w, http.StatusInternalServerError, \"Could not list friends\")\n\t\treturn\n\t}\n\n\tutil.RespondWithJSON(w, http.StatusOK, friends)\n}\n\nfunc (h *FriendHandler) ListPendingRequests(w http.ResponseWriter, r *http.Request) {\n\tuserID, ok := r.Context().Value(middleware.UserIDKey).(uuid.UUID)\n\tif !ok {\n\t\tutil.RespondWithError(w, http.StatusUnauthorized, \"Invalid user ID in token\")\n\t\treturn\n\t}\n\n\trequests, err := h.friendUsecase.ListPendingRequests(r.Context(), userID)\n\tif err != nil {\n\t\tutil.RespondWithError(w, http.StatusInternalServerError, \"Could not list pending requests\")\n\t\treturn\n\t}\n\n\tutil.RespondWithJSON(w, http.StatusOK, requests)\n}\n",
  "backend/adapter/handler/http/group_handler.go": "package http\n\nimport (\n\t\"encoding/json\"\n\t\"errors\"\n\t\"net/http\"\n\n\t\"chat-app/adapter/middleware\"\n\t\"chat-app/adapter/util\"\n\t\"chat-app/models\"\n\n\t\"github.com/go-chi/chi/v5\"\n\t\"github.com/google/uuid\"\n)\n\nconst maxGroupPhotoSize = 200 * 1024 // 200 KB\n\nfunc (h *GroupHandler) CreateGroup(w http.ResponseWriter, r *http.Request) {\n\tuserID, ok := r.Context().Value(middleware.UserIDKey).(uuid.UUID)\n\tif !ok {\n\t\tutil.RespondWithError(w, http.StatusUnauthorized, \"Invalid user ID in token\")\n\t\treturn\n\t}\n\n\tif err := r.ParseMultipartForm(maxGroupPhotoSize); err != nil {\n\t\tutil.RespondWithError(w, http.StatusBadRequest, \"Could not parse form\")\n\t\treturn\n\t}\n\n\thandle := r.FormValue(\"handle\")\n\tname := r.FormValue(\"name\")\n\tif handle == \"\" || name == \"\" {\n\t\tutil.RespondWithError(w, http.StatusBadRequest, \"Handle and name are required\")\n\t\treturn\n\t}\n\n\tfile, header, err := r.FormFile(\"photo\")\n\tif err != nil \u0026\u0026 !errors.Is(err, http.ErrMissingFile) {\n\t\tutil.RespondWithError(w, http.StatusBadRequest, \"Could not get photo\")\n\t\treturn\n\t}\n\tif file != nil {\n\t\tdefer file.Close()\n\t}\n\n\tgroup, err := h.groupUsecase.CreateGroup(r.Context(), userID, handle, name, file, header)\n\tif err != nil {\n\t\tswitch {\n\t\tcase errors.Is(err, models.ErrGroupHandleTaken):\n\t\t\tutil.RespondWithError(w, http.StatusConflict, err.Error())\n\t\tdefault:\n\t\t\tutil.RespondWithError(w, http.StatusInternalServerError, \"Could not create group\")\n\t\t}\n\t\treturn\n\t}\n\n\tutil.RespondWithJSON(w, http.StatusCreated, group)\n}\n\nfunc (h *GroupHandler) JoinGroup(w http.ResponseWriter, r *http.Request) {\n\tuserID, ok := r.Context().Value(middleware.UserIDKey).(uuid.UUID)\n\tif !ok {\n\t\tutil.RespondWithError(w, http.StatusUnauthorized, \"Invalid user ID in token\")\n\t\treturn\n\t}\n\n\tvar req struct {\n\t\tHandle string `json:\"handle\"`\n\t}\n\tif err := json.NewDecoder(r.Body).Decode(\u0026req); err != nil {\n\t\tutil.RespondWithError(w, http.StatusBadRequest, \"Invalid request payload\")\n\t\treturn\n\t}\n\n\terr := h.groupUsecase.JoinGroup(r.Context(), userID, req.Handle)\n\tif err != nil {\n\t\tswitch {\n\t\tcase errors.Is(err, models.ErrGroupNotFound):\n\t\t\tutil.RespondWithError(w, http.StatusNotFound, err.Error())\n\t\tcase errors.Is(err, models.ErrAlreadyGroupMember):\n\t\t\tutil.RespondWithError(w, http.StatusConflict, err.Error())\n\t\tdefault:\n\t\t\tutil.RespondWithError(w, http.StatusInternalServerError, \"Could not join group\")\n\t\t}\n\t\treturn\n\t}\n\n\tutil.RespondWithJSON(w, http.StatusOK, map[string]string{\"message\": \"Successfully joined group\"})\n}\n\nfunc (h *GroupHandler) LeaveGroup(w http.ResponseWriter, r *http.Request) {\n\tuserID, ok := r.Context().Value(middleware.UserIDKey).(uuid.UUID)\n\tif !ok {\n\t\tutil.RespondWithError(w, http.StatusUnauthorized, \"Invalid user ID in token\")\n\t\treturn\n\t}\n\n\tgroupIDStr := chi.URLParam(r, \"groupID\")\n\tgroupID, err := uuid.Parse(groupIDStr)\n\tif err != nil {\n\t\tutil.RespondWithError(w, http.StatusBadRequest, \"Invalid group ID\")\n\t\treturn\n\t}\n\n\terr = h.groupUsecase.LeaveGroup(r.Context(), userID, groupID)\n\tif err != nil {\n\t\tswitch {\n\t\tcase errors.Is(err, models.ErrGroupNotFound), errors.Is(err, models.ErrNotGroupMember):\n\t\t\tutil.RespondWithError(w, http.StatusNotFound, err.Error())\n\t\tdefault:\n\t\t\tutil.RespondWithError(w, http.StatusInternalServerError, \"Could not leave group\")\n\t\t}\n\t\treturn\n\t}\n\n\tutil.RespondWithJSON(w, http.StatusOK, map[string]string{\"message\": \"Successfully left group\"})\n}\n\nfunc (h *GroupHandler) AddMember(w http.ResponseWriter, r *http.Request) {\n\tadderID, ok := r.Context().Value(middleware.UserIDKey).(uuid.UUID)\n\tif !ok {\n\t\tutil.RespondWithError(w, http.StatusUnauthorized, \"Invalid user ID in token\")\n\t\treturn\n\t}\n\n\tgroupIDStr := chi.URLParam(r, \"groupID\")\n\tgroupID, err := uuid.Parse(groupIDStr)\n\tif err != nil {\n\t\tutil.RespondWithError(w, http.StatusBadRequest, \"Invalid group ID\")\n\t\treturn\n\t}\n\n\tvar req struct {\n\t\tUsername string `json:\"username\"`\n\t}\n\tif err := json.NewDecoder(r.Body).Decode(\u0026req); err != nil {\n\t\tutil.RespondWithError(w, http.StatusBadRequest, \"Invalid request payload\")\n\t\treturn\n\t}\n\n\terr = h.groupUsecase.AddMember(r.Context(), adderID, req.Username, groupID)\n\tif err != nil {\n\t\tswitch {\n\t\tcase errors.Is(err, models.ErrNotGroupMember), errors.Is(err, models.ErrUserNotFound), errors.Is(err, models.ErrNotFriends):\n\t\t\tutil.RespondWithError(w, http.StatusForbidden, err.Error())\n\t\tcase errors.Is(err, models.ErrAlreadyGroupMember):\n\t\t\tutil.RespondWithError(w, http.StatusConflict, err.Error())\n\t\tdefault:\n\t\t\tutil.RespondWithError(w, http.StatusInternalServerError, \"Could not add member\")\n\t\t}\n\t\treturn\n\t}\n\n\tutil.RespondWithJSON(w, http.StatusCreated, map[string]string{\"message\": \"Member added successfully\"})\n}\n\nfunc (h *GroupHandler) RemoveMember(w http.ResponseWriter, r *http.Request) {\n\townerID, ok := r.Context().Value(middleware.UserIDKey).(uuid.UUID)\n\tif !ok {\n\t\tutil.RespondWithError(w, http.StatusUnauthorized, \"Invalid user ID in token\")\n\t\treturn\n\t}\n\n\tgroupIDStr := chi.URLParam(r, \"groupID\")\n\tgroupID, err := uuid.Parse(groupIDStr)\n\tif err != nil {\n\t\tutil.RespondWithError(w, http.StatusBadRequest, \"Invalid group ID\")\n\t\treturn\n\t}\n\n\tmemberIDStr := chi.URLParam(r, \"memberID\")\n\tmemberID, err := uuid.Parse(memberIDStr)\n\tif err != nil {\n\t\tutil.RespondWithError(w, http.StatusBadRequest, \"Invalid member ID\")\n\t\treturn\n\t}\n\n\terr = h.groupUsecase.RemoveMember(r.Context(), ownerID, memberID, groupID)\n\tif err != nil {\n\t\tswitch {\n\t\tcase errors.Is(err, models.ErrNotGroupOwner), errors.Is(err, models.ErrCannotRemoveOwner):\n\t\t\tutil.RespondWithError(w, http.StatusForbidden, err.Error())\n\t\tcase errors.Is(err, models.ErrGroupNotFound), errors.Is(err, models.ErrNotGroupMember):\n\t\t\tutil.RespondWithError(w, http.StatusNotFound, err.Error())\n\t\tdefault:\n\t\t\tutil.RespondWithError(w, http.StatusInternalServerError, \"Could not remove member\")\n\t\t}\n\t\treturn\n\t}\n\n\tw.WriteHeader(http.StatusNoContent)\n}\n\nfunc (h *GroupHandler) SearchGroups(w http.ResponseWriter, r *http.Request) {\n\tquery := r.URL.Query().Get(\"q\")\n\tif query == \"\" {\n\t\tutil.RespondWithError(w, http.StatusBadRequest, \"Query parameter 'q' is required\")\n\t\treturn\n\t}\n\n\tgroups, err := h.groupUsecase.SearchGroups(r.Context(), query)\n\tif err != nil {\n\t\tutil.RespondWithError(w, http.StatusInternalServerError, \"Could not search for groups\")\n\t\treturn\n\t}\n\n\tutil.RespondWithJSON(w, http.StatusOK, groups)\n}\n",
  "backend/adapter/handler/http/handler.go": "package http\n\nimport (\n\t\"chat-app/usecase\"\n)\n\ntype AuthHandler struct {\n\tauthUsecase usecase.AuthUsecase\n}\n\nfunc NewAuthHandler(authUsecase usecase.AuthUsecase) *AuthHandler {\n\treturn \u0026AuthHandler{authUsecase: authUsecase}\n}\n\ntype UserHandler struct {\n\tuserUsecase usecase.UserUsecase\n}\n\nfunc NewUserHandler(userUsecase usecase.UserUsecase) *UserHandler {\n\treturn \u0026UserHandler{userUsecase: userUsecase}\n}\n\ntype FriendHandler struct {\n\tfriendUsecase usecase.FriendUsecase\n}\n\nfunc NewFriendHandler(friendUsecase usecase.FriendUsecase) *FriendHandler {\n\treturn \u0026FriendHandler{friendUsecase: friendUsecase}\n}\n\ntype GroupHandler struct {\n\tgroupUsecase usecase.GroupUsecase\n}\n\nfunc NewGroupHandler(groupUsecase usecase.GroupUsecase) *GroupHandler {\n\treturn \u0026GroupHandler{groupUsecase: groupUsecase}\n}\n",
  "backend/adapter/handler/http/user_handler.go": "package http\n\nimport (\n\t\"chat-app/backend/adapter/middleware\"\n\t\"chat-app/backend/adapter/util\"\n\t\"chat-app/backend/models\"\n\t\"encoding/json\"\n\t\"errors\"\n\t\"net/http\"\n\n\t\"github.com/go-chi/chi/v5\"\n\t\"github.com/google/uuid\"\n)\n\ntype registerRequest struct {\n\tUsername string `json:\"username\"`\n\tPassword string `json:\"password\"`\n}\n\nfunc (h *UserHandler) Register(w http.ResponseWriter, r *http.Request) {\n\tvar req registerRequest\n\tif err := json.NewDecoder(r.Body).Decode(\u0026req); err != nil {\n\t\tutil.RespondWithError(w, http.StatusBadRequest, \"Invalid request payload\")\n\t\treturn\n\t}\n\n\tuser, err := h.userUsecase.Register(r.Context(), req.Username, req.Password)\n\tif err != nil {\n\t\tif errors.Is(err, models.ErrUsernameTaken) || err.Error() == \"invalid username format\" || err.Error() == \"password is too short\" {\n\t\t\tutil.RespondWithError(w, http.StatusBadRequest, err.Error())\n\t\t\treturn\n\t\t}\n\t\tutil.RespondWithError(w, http.StatusInternalServerError, \"Failed to register user\")\n\t\treturn\n\t}\n\n\tutil.RespondWithJSON(w, http.StatusCreated, user)\n}\n\nfunc (h *UserHandler) GetUserByUsername(w http.ResponseWriter, r *http.Request) {\n\tusername := chi.URLParam(r, \"username\")\n\tif username == \"\" {\n\t\tutil.RespondWithError(w, http.StatusBadRequest, \"Username is required\")\n\t\treturn\n\t}\n\n\tuser, err := h.userUsecase.GetByUsername(r.Context(), username)\n\tif err != nil {\n\t\tif errors.Is(err, models.ErrUserNotFound) {\n\t\t\tutil.RespondWithError(w, http.StatusNotFound, err.Error())\n\t\t\treturn\n\t\t}\n\t\tutil.RespondWithError(w, http.StatusInternalServerError, \"Failed to get user\")\n\t\treturn\n\t}\n\n\tutil.RespondWithJSON(w, http.StatusOK, user)\n}\n\nfunc (h *UserHandler) UpdateProfile(w http.ResponseWriter, r *http.Request) {\n\tuserID, ok := r.Context().Value(middleware.UserIDKey).(uuid.UUID)\n\tif !ok {\n\t\tutil.RespondWithError(w, http.StatusUnauthorized, \"Unauthorized\")\n\t\treturn\n\t}\n\n\tif err := r.ParseMultipartForm(32 \u003c\u003c 20); err != nil { // 32MB max memory\n\t\tutil.RespondWithError(w, http.StatusBadRequest, \"Failed to parse multipart form\")\n\t\treturn\n\t}\n\n\tvar username, password *string\n\tif val := r.FormValue(\"username\"); val != \"\" {\n\t\tusername = \u0026val\n\t}\n\tif val := r.FormValue(\"password\"); val != \"\" {\n\t\tpassword = \u0026val\n\t}\n\n\tfile, header, err := r.FormFile(\"profilePic\")\n\tif err != nil \u0026\u0026 !errors.Is(err, http.ErrMissingFile) {\n\t\tutil.RespondWithError(w, http.StatusBadRequest, \"Invalid file upload\")\n\t\treturn\n\t}\n\tif file != nil {\n\t\tdefer file.Close()\n\t}\n\n\tuser, err := h.userUsecase.UpdateProfile(r.Context(), userID, username, password, file, header)\n\tif err != nil {\n\t\tif errors.Is(err, models.ErrUserNotFound) {\n\t\t\tutil.RespondWithError(w, http.StatusNotFound, err.Error())\n\t\t\treturn\n\t\t}\n\t\tif errors.Is(err, models.ErrUsernameTaken) {\n\t\t\tutil.RespondWithError(w, http.StatusConflict, err.Error())\n\t\t\treturn\n\t\t}\n\t\t// Check for validation errors\n\t\tif err.Error() == \"invalid username format\" || err.Error() == \"password is too short\" || err.Error() == \"file size exceeds 200KB\" || err.Error() == \"invalid file type\" {\n\t\t\tutil.RespondWithError(w, http.StatusBadRequest, err.Error())\n\t\t\treturn\n\t\t}\n\t\tutil.RespondWithError(w, http.StatusInternalServerError, \"Failed to update profile\")\n\t\treturn\n\t}\n\n\tutil.RespondWithJSON(w, http.StatusOK, user)\n}\n",
  "backend/adapter/handler/http/web_handler.go": "package http\n\nimport (\n\t\"html/template\"\n\t\"log\"\n\t\"net/http\"\n\t\"path/filepath\"\n)\n\ntype WebHandler struct {\n\ttemplates *template.Template\n}\n\nfunc NewWebHandler(templatesDir string) *WebHandler {\n\ttpl, err := template.ParseGlob(filepath.Join(templatesDir, \"*.html\"))\n\tif err != nil {\n\t\tlog.Fatalf(\"failed to parse templates: %v\", err)\n\t}\n\n\treturn \u0026WebHandler{\n\t\ttemplates: tpl,\n\t}\n}\n\nfunc (h *WebHandler) ServeApp(w http.ResponseWriter, r *http.Request) {\n\terr := h.templates.ExecuteTemplate(w, \"app.html\", nil)\n\tif err != nil {\n\t\tlog.Printf(\"Error executing template: %v\", err)\n\t\thttp.Error(w, \"Internal Server Error\", http.StatusInternalServerError)\n\t}\n}\n",
  "backend/adapter/handler/ws/client.go": "package ws\n\nimport (\n\t\"bytes\"\n\t\"log\"\n\t\"time\"\n\n\t\"github.com/google/uuid\"\n\t\"github.com/gorilla/websocket\"\n)\n\nconst (\n\twriteWait      = 10 * time.Second\n\tpongWait       = 60 * time.Second\n\tpingPeriod     = (pongWait * 9) / 10\n\tmaxMessageSize = 512\n)\n\nvar (\n\tnewline = []byte{'\\n'}\n\tspace   = []byte{' '}\n)\n\n// Client is a middleman between the websocket connection and the hub.\ntype Client struct {\n\thub *Hub\n\t// The websocket connection.\n\tconn *websocket.Conn\n\t// Buffered channel of outbound messages.\n\tsend chan []byte\n\t// Authenticated user ID.\n\tuserID uuid.UUID\n}\n\n// readPump pumps messages from the websocket connection to the hub.\nfunc (c *Client) readPump() {\n\tdefer func() {\n\t\tc.hub.unregister \u003c- c\n\t\tc.conn.Close()\n\t}()\n\tc.conn.SetReadLimit(maxMessageSize)\n\tc.conn.SetReadDeadline(time.Now().Add(pongWait))\n\tc.conn.SetPongHandler(func(string) error { c.conn.SetReadDeadline(time.Now().Add(pongWait)); return nil })\n\tfor {\n\t\t_, message, err := c.conn.ReadMessage()\n\t\tif err != nil {\n\t\t\tif websocket.IsUnexpectedCloseError(err, websocket.CloseGoingAway, websocket.CloseAbnormalClosure) {\n\t\t\t\tlog.Printf(\"error: %v\", err)\n\t\t\t}\n\t\t\tbreak\n\t\t}\n\t\tmessage = bytes.TrimSpace(bytes.Replace(message, newline, space, -1))\n\t\tc.hub.broadcast \u003c- \u0026ClientMessage{client: c, message: message}\n\t}\n}\n\n// writePump pumps messages from the hub to the websocket connection.\nfunc (c *Client) writePump() {\n\tticker := time.NewTicker(pingPeriod)\n\tdefer func() {\n\t\tticker.Stop()\n\t\tc.conn.Close()\n\t}()\n\tfor {\n\t\tselect {\n\t\tcase message, ok := \u003c-c.send:\n\t\t\tc.conn.SetWriteDeadline(time.Now().Add(writeWait))\n\t\t\tif !ok {\n\t\t\t\t// The hub closed the channel.\n\t\t\t\tc.conn.WriteMessage(websocket.CloseMessage, []byte{})\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tw, err := c.conn.NextWriter(websocket.TextMessage)\n\t\t\tif err != nil {\n\t\t\t\treturn\n\t\t\t}\n\t\t\tw.Write(message)\n\n\t\t\t// Add queued chat messages to the current websocket message.\n\t\t\tn := len(c.send)\n\t\t\tfor i := 0; i \u003c n; i++ {\n\t\t\t\tw.Write(newline)\n\t\t\t\tw.Write(\u003c-c.send)\n\t\t\t}\n\n\t\t\tif err := w.Close(); err != nil {\n\t\t\t\treturn\n\t\t\t}\n\t\tcase \u003c-ticker.C:\n\t\t\tc.conn.SetWriteDeadline(time.Now().Add(writeWait))\n\t\t\tif err := c.conn.WriteMessage(websocket.PingMessage, nil); err != nil {\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t}\n}\n",
  "backend/adapter/handler/ws/handler.go": "package ws\n\nimport (\n\t\"log\"\n\t\"net/http\"\n\n\t\"chat-app/adapter/middleware\"\n\t\"github.com/google/uuid\"\n\t\"github.com/gorilla/websocket\"\n)\n\nvar upgrader = websocket.Upgrader{\n\tReadBufferSize:  1024,\n\tWriteBufferSize: 1024,\n\tCheckOrigin: func(r *http.Request) bool {\n\t\t// Allow all connections for now\n\t\treturn true\n\t},\n}\n\n// ServeWs handles websocket requests from the peer.\nfunc ServeWs(hub *Hub, w http.ResponseWriter, r *http.Request) {\n\tuserID, ok := r.Context().Value(middleware.UserIDKey).(uuid.UUID)\n\tif !ok {\n\t\thttp.Error(w, \"Unauthorized\", http.StatusUnauthorized)\n\t\treturn\n\t}\n\n\tconn, err := upgrader.Upgrade(w, r, nil)\n\tif err != nil {\n\t\tlog.Println(err)\n\t\treturn\n\t}\n\tclient := \u0026Client{hub: hub, conn: conn, send: make(chan []byte, 256), userID: userID}\n\tclient.hub.register \u003c- client\n\n\t// Allow collection of memory referenced by the caller by doing all work in\n\t// new goroutines.\n\tgo client.writePump()\n\tgo client.readPump()\n}\n",
  "backend/adapter/handler/ws/hub.go": "package ws\n\nimport (\n\t\"context\"\n\t\"encoding/json\"\n\t\"log\"\n\t\"strings\"\n\t\"sync\"\n\t\"time\"\n\n\t\"chat-app/backend/models\"\n\t\"chat-app/backend/usecase\"\n\t\"github.com/google/uuid\"\n)\n\n// ClientMessage is a message from a client to the hub.\ntype ClientMessage struct {\n\tclient  *Client\n\tmessage []byte\n}\n\n// Hub maintains the set of active clients and broadcasts messages to the clients.\ntype Hub struct {\n\t// Registered clients.\n\tclients map[uuid.UUID]*Client\n\t// Inbound messages from the clients.\n\tbroadcast chan *ClientMessage\n\t// Register requests from the clients.\n\tregister chan *Client\n\t// Unregister requests from clients.\n\tunregister chan *Client\n\t// Event usecase\n\teventUsecase usecase.EventUsecase\n\tgroupUsecase usecase.GroupUsecase\n\tmu           sync.RWMutex\n}\n\nfunc NewHub(eventUsecase usecase.EventUsecase, groupUsecase usecase.GroupUsecase) *Hub {\n\treturn \u0026Hub{\n\t\tbroadcast:    make(chan *ClientMessage),\n\t\tregister:     make(chan *Client),\n\t\tunregister:   make(chan *Client),\n\t\tclients:      make(map[uuid.UUID]*Client),\n\t\teventUsecase: eventUsecase,\n\t\tgroupUsecase: groupUsecase,\n\t}\n}\n\nfunc (h *Hub) Run() {\n\tfor {\n\t\tselect {\n\t\tcase client := \u003c-h.register:\n\t\t\th.mu.Lock()\n\t\t\th.clients[client.userID] = client\n\t\t\th.mu.Unlock()\n\t\tcase client := \u003c-h.unregister:\n\t\t\th.mu.Lock()\n\t\t\tif _, ok := h.clients[client.userID]; ok {\n\t\t\t\tdelete(h.clients, client.userID)\n\t\t\t\tclose(client.send)\n\t\t\t}\n\t\t\th.mu.Unlock()\n\t\tcase clientMessage := \u003c-h.broadcast:\n\t\t\th.handleMessage(clientMessage.client, clientMessage.message)\n\t\t}\n\t}\n}\n\nfunc (h *Hub) GetClientCount() int {\n\th.mu.RLock()\n\tdefer h.mu.RUnlock()\n\treturn len(h.clients)\n}\n\nfunc (h *Hub) handleMessage(sender *Client, rawMessage []byte) {\n\tvar msg Message\n\tif err := json.Unmarshal(rawMessage, \u0026msg); err != nil {\n\t\tlog.Printf(\"error unmarshalling message: %v\", err)\n\t\treturn\n\t}\n\n\tswitch msg.Type {\n\tcase \"message_sent\":\n\t\tvar inbound InboundMessage\n\t\tif err := json.Unmarshal(msg.Payload, \u0026inbound); err != nil {\n\t\t\tlog.Printf(\"error unmarshalling inbound message payload: %v\", err)\n\t\t\treturn\n\t\t}\n\n\t\tcontent := strings.TrimSpace(inbound.Content)\n\t\tif len(content) == 0 || len(content) \u003e 200 {\n\t\t\tlog.Printf(\"invalid message length from user %s\", sender.userID)\n\t\t\treturn\n\t\t}\n\t\tinbound.Content = content\n\n\t\th.processAndRelayMessage(sender.userID, inbound)\n\tdefault:\n\t\tlog.Printf(\"unknown message type: %s\", msg.Type)\n\t}\n}\n\nfunc (h *Hub) processAndRelayMessage(senderID uuid.UUID, inbound InboundMessage) {\n\tctx := context.Background()\n\toutboundPayload := OutboundMessage{\n\t\tID:          uuid.New(),\n\t\tContent:     inbound.Content,\n\t\tSenderID:    senderID,\n\t\tRecipientID: inbound.RecipientID,\n\t\tTimestamp:   time.Now().UTC().Format(time.RFC3339),\n\t}\n\tpayloadBytes, _ := json.Marshal(outboundPayload)\n\n\tvar recipients []uuid.UUID\n\n\t// Check if recipient is a group or a user\n\tgroup, err := h.groupUsecase.GetGroupDetails(ctx, inbound.RecipientID)\n\tif err == nil \u0026\u0026 group != nil {\n\t\tmembers, err := h.groupUsecase.ListGroupMembers(ctx, group.ID)\n\t\tif err != nil {\n\t\t\tlog.Printf(\"error listing group members: %v\", err)\n\t\t\treturn\n\t\t}\n\t\tfor _, member := range members {\n\t\t\trecipients = append(recipients, member.ID)\n\t\t}\n\t} else {\n\t\trecipients = append(recipients, inbound.RecipientID)\n\t}\n\n\t// Store and send event to all recipients\n\tfor _, recipientID := range recipients {\n\t\tevent := \u0026models.Event{\n\t\t\tID:          uuid.New(),\n\t\t\tType:        models.EventMessageSent,\n\t\t\tPayload:     payloadBytes,\n\t\t\tRecipientID: recipientID,\n\t\t\tSenderID:    \u0026senderID,\n\t\t\tCreatedAt:   time.Now().UTC(),\n\t\t}\n\t\tif err := h.eventUsecase.StoreEvent(ctx, event); err != nil {\n\t\t\tlog.Printf(\"failed to store event: %v\", err)\n\t\t\tcontinue\n\t\t}\n\t\th.DeliverEvent(event)\n\t}\n\n\t// Send acknowledgment back to sender\n\tackPayload, err := json.Marshal(map[string]string{\"messageId\": outboundPayload.ID.String()})\n\tif err != nil {\n\t\tlog.Printf(\"error marshalling ack payload: %v\", err)\n\t\treturn\n\t}\n\n\tackEvent := \u0026models.Event{\n\t\tID:          uuid.New(), // New ID for the ack event itself\n\t\tType:        models.EventMessageAck,\n\t\tPayload:     ackPayload,\n\t\tRecipientID: senderID,\n\t\tCreatedAt:   time.Now().UTC(),\n\t}\n\th.DeliverEvent(ackEvent)\n}\n\n// DeliverEvent sends a single event to a connected client if they are online.\nfunc (h *Hub) DeliverEvent(event *models.Event) {\n\tpayload, err := json.Marshal(event)\n\tif err != nil {\n\t\tlog.Printf(\"error marshalling event for delivery: %v\", err)\n\t\treturn\n\t}\n\n\th.mu.RLock()\n\tclient, ok := h.clients[event.RecipientID]\n\th.mu.RUnlock()\n\n\tif ok {\n\t\tselect {\n\t\tcase client.send \u003c- payload:\n\t\tdefault:\n\t\t\t// Client's send buffer is full, assume it's lagging and disconnect.\n\t\t\tlog.Printf(\"client %s lagging, disconnecting\", client.userID)\n\t\t\th.unregister \u003c- client\n\t\t}\n\t}\n}\n",
  "backend/adapter/handler/ws/message.go": "package ws\n\nimport (\n\t\"encoding/json\"\n\t\"github.com/google/uuid\"\n)\n\n// Message represents a message sent over the WebSocket connection.\ntype Message struct {\n\tType    string          `json:\"type\"`\n\tPayload json.RawMessage `json:\"payload\"`\n}\n\n// InboundMessage represents a message received from a client.\ntype InboundMessage struct {\n\tContent     string    `json:\"content\"`\n\tRecipientID uuid.UUID `json:\"recipientId\"` // Can be a user ID or group ID\n}\n\n// OutboundMessage represents a message sent to a client.\ntype OutboundMessage struct {\n\tID          uuid.UUID `json:\"id\"`\n\tContent     string    `json:\"content\"`\n\tSenderID    uuid.UUID `json:\"senderId\"`\n\tRecipientID uuid.UUID `json:\"recipientId\"` // Can be a user ID or group ID\n\tTimestamp   string    `json:\"timestamp\"`\n}\n",
  "backend/adapter/middleware/auth.go": "package middleware\n\nimport (\n\t\"chat-app/backend/adapter/util\"\n\t\"context\"\n\t\"net/http\"\n\t\"strings\"\n\n\t\"github.com/golang-jwt/jwt/v5\"\n\t\"github.com/google/uuid\"\n)\n\ntype contextKey string\n\nconst UserIDKey contextKey = \"userID\"\n\ntype AuthMiddleware struct {\n\tjwtSecret string\n}\n\nfunc NewAuthMiddleware(jwtSecret string) *AuthMiddleware {\n\treturn \u0026AuthMiddleware{jwtSecret: jwtSecret}\n}\n\nfunc (m *AuthMiddleware) Validate(next http.Handler) http.Handler {\n\treturn http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\tauthHeader := r.Header.Get(\"Authorization\")\n\t\tif authHeader == \"\" {\n\t\t\tutil.RespondWithError(w, http.StatusUnauthorized, \"Authorization header required\")\n\t\t\treturn\n\t\t}\n\n\t\ttokenString := strings.TrimPrefix(authHeader, \"Bearer \")\n\t\tif tokenString == authHeader {\n\t\t\tutil.RespondWithError(w, http.StatusUnauthorized, \"Bearer token required\")\n\t\t\treturn\n\t\t}\n\n\t\ttoken, err := jwt.Parse(tokenString, func(token *jwt.Token) (interface{}, error) {\n\t\t\tif _, ok := token.Method.(*jwt.SigningMethodHMAC); !ok {\n\t\t\t\treturn nil, jwt.ErrSignatureInvalid\n\t\t\t}\n\t\t\treturn []byte(m.jwtSecret), nil\n\t\t})\n\n\t\tif err != nil || !token.Valid {\n\t\t\tutil.RespondWithError(w, http.StatusUnauthorized, \"Invalid or expired token\")\n\t\t\treturn\n\t\t}\n\n\t\tclaims, ok := token.Claims.(jwt.MapClaims)\n\t\tif !ok {\n\t\t\tutil.RespondWithError(w, http.StatusUnauthorized, \"Invalid token claims\")\n\t\t\treturn\n\t\t}\n\n\t\tuserIDStr, ok := claims[\"user_id\"].(string)\n\t\tif !ok {\n\t\t\tutil.RespondWithError(w, http.StatusUnauthorized, \"Invalid user ID in token\")\n\t\t\treturn\n\t\t}\n\n\t\tuserID, err := uuid.Parse(userIDStr)\n\t\tif err != nil {\n\t\t\tutil.RespondWithError(w, http.StatusUnauthorized, \"Invalid user ID format in token\")\n\t\t\treturn\n\t\t}\n\n\t\tctx := context.WithValue(r.Context(), UserIDKey, userID)\n\t\tnext.ServeHTTP(w, r.WithContext(ctx))\n\t})\n}\n",
  "backend/adapter/middleware/logging.go": "package middleware\n\nimport (\n\t\"log\"\n\t\"net/http\"\n\t\"time\"\n)\n\nfunc Logging(next http.Handler) http.Handler {\n\treturn http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\tstart := time.Now()\n\t\tnext.ServeHTTP(w, r)\n\t\tlog.Printf(\"%s %s %s\", r.Method, r.RequestURI, time.Since(start))\n\t})\n}\n",
  "backend/adapter/middleware/ratelimit.go": "package middleware\n\nimport (\n\t\"net\"\n\t\"net/http\"\n\t\"sync\"\n\t\"time\"\n\n\t\"golang.org/x/time/rate\"\n)\n\ntype client struct {\n\tlimiter  *rate.Limiter\n\tlastSeen time.Time\n}\n\nvar (\n\tclients = make(map[string]*client)\n\tmu      sync.Mutex\n)\n\nfunc init() {\n\tgo cleanupClients()\n}\n\nfunc getClient(ip string) *rate.Limiter {\n\tmu.Lock()\n\tdefer mu.Unlock()\n\n\tif c, exists := clients[ip]; exists {\n\t\tc.lastSeen = time.Now()\n\t\treturn c.limiter\n\t}\n\n\t// Allow 5 requests per second with a burst of 10.\n\tlimiter := rate.NewLimiter(5, 10)\n\tclients[ip] = \u0026client{limiter, time.Now()}\n\treturn limiter\n}\n\nfunc cleanupClients() {\n\tfor {\n\t\ttime.Sleep(time.Minute)\n\t\tmu.Lock()\n\t\tfor ip, c := range clients {\n\t\t\tif time.Since(c.lastSeen) \u003e 3*time.Minute {\n\t\t\t\tdelete(clients, ip)\n\t\t\t}\n\t\t}\n\t\tmu.Unlock()\n\t}\n}\n\nfunc RateLimit(next http.Handler) http.Handler {\n\treturn http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\tip, _, err := net.SplitHostPort(r.RemoteAddr)\n\t\tif err != nil {\n\t\t\t// Fallback for environments without a port\n\t\t\tip = r.RemoteAddr\n\t\t}\n\n\t\tlimiter := getClient(ip)\n\t\tif !limiter.Allow() {\n\t\t\thttp.Error(w, \"Too Many Requests\", http.StatusTooManyRequests)\n\t\t\treturn\n\t\t}\n\n\t\tnext.ServeHTTP(w, r)\n\t})\n}\n",
  "backend/adapter/postgres/db.go": "package postgres\n\nimport (\n\t\"chat-app/backend/config\"\n\t\"database/sql\"\n\t\"fmt\"\n\n\t_ \"github.com/lib/pq\"\n)\n\nfunc NewDB(cfg *config.Config) (*sql.DB, error) {\n\tconnStr := fmt.Sprintf(\"host=%s port=%s user=%s password=%s dbname=%s sslmode=%s\",\n\t\tcfg.DBHost, cfg.DBPort, cfg.DBUser, cfg.DBPassword, cfg.DBName, cfg.DBSslMode)\n\n\tdb, err := sql.Open(\"postgres\", connStr)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tif err := db.Ping(); err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn db, nil\n}\n",
  "backend/adapter/postgres/event_repo.go": "package postgres\n\nimport (\n\t\"context\"\n\t\"database/sql\"\n\t\"time\"\n\n\t\"chat-app/models\"\n\t\"chat-app/repository\"\n\n\t\"github.com/google/uuid\"\n\t\"github.com/lib/pq\"\n)\n\ntype postgresEventRepository struct {\n\tdb *sql.DB\n}\n\nfunc NewPostgresEventRepository(db *sql.DB) repository.EventRepository {\n\treturn \u0026postgresEventRepository{db: db}\n}\n\n// These methods are for the Postgres part of the EventRepository interface\nfunc (r *postgresEventRepository) Store(ctx context.Context, event *models.Event) error {\n\tquery := `INSERT INTO events (id, type, payload, recipient_id, sender_id, created_at)\n              VALUES ($1, $2, $3, $4, $5, $6)`\n\t_, err := r.db.ExecContext(ctx, query, event.ID, event.Type, event.Payload, event.RecipientID, event.SenderID, event.CreatedAt)\n\treturn err\n}\n\nfunc (r *postgresEventRepository) StoreBatch(ctx context.Context, events []*models.Event) error {\n\tif len(events) == 0 {\n\t\treturn nil\n\t}\n\n\ttx, err := r.db.BeginTx(ctx, nil)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer tx.Rollback()\n\n\tstmt, err := tx.PrepareContext(ctx, pq.CopyIn(\"events\", \"id\", \"type\", \"payload\", \"recipient_id\", \"sender_id\", \"created_at\"))\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer stmt.Close()\n\n\tfor _, event := range events {\n\t\t_, err = stmt.ExecContext(ctx, event.ID, event.Type, event.Payload, event.RecipientID, event.SenderID, event.CreatedAt)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\tif _, err = stmt.ExecContext(ctx); err != nil {\n\t\treturn err\n\t}\n\n\treturn tx.Commit()\n}\n\nfunc (r *postgresEventRepository) FetchUndelivered(ctx context.Context, userID uuid.UUID, cursor time.Time, limit int) ([]*models.Event, error) {\n\tquery := `SELECT id, type, payload, recipient_id, sender_id, created_at\n              FROM events\n              WHERE recipient_id = $1 AND created_at \u003e $2\n              ORDER BY created_at ASC\n              LIMIT $3`\n\n\trows, err := r.db.QueryContext(ctx, query, userID, cursor, limit)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer rows.Close()\n\n\tvar events []*models.Event\n\tfor rows.Next() {\n\t\tvar event models.Event\n\t\tif err := rows.Scan(\u0026event.ID, \u0026event.Type, \u0026event.Payload, \u0026event.RecipientID, \u0026event.SenderID, \u0026event.CreatedAt); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tevents = append(events, \u0026event)\n\t}\n\treturn events, nil\n}\n\nfunc (r *postgresEventRepository) Delete(ctx context.Context, eventID uuid.UUID) error {\n\tquery := `DELETE FROM events WHERE id = $1`\n\t_, err := r.db.ExecContext(ctx, query, eventID)\n\treturn err\n}\n\n// These methods are for the Redis part of the interface, so they are no-ops here.\nfunc (r *postgresEventRepository) BufferEvent(ctx context.Context, event *models.Event) error {\n\treturn nil // No-op\n}\nfunc (r *postgresEventRepository) GetBufferedEvents(ctx context.Context, count int) ([]*models.Event, error) {\n\treturn nil, nil // No-op\n}\nfunc (r *postgresEventRepository) DeleteBufferedEvents(ctx context.Context, events []*models.Event) error {\n\treturn nil // No-op\n}\n",
  "backend/adapter/postgres/friendship_repo.go": "package postgres\n\nimport (\n\t\"context\"\n\t\"database/sql\"\n\t\"errors\"\n\t\"fmt\"\n\n\t\"chat-app/models\"\n\t\"chat-app/repository\"\n\n\t\"github.com/google/uuid\"\n\t\"github.com/lib/pq\"\n)\n\ntype postgresFriendshipRepository struct {\n\tdb *sql.DB\n}\n\nfunc NewPostgresFriendshipRepository(db *sql.DB) repository.FriendshipRepository {\n\treturn \u0026postgresFriendshipRepository{db: db}\n}\n\n// normalizeUserIDs ensures that userID1 is always less than userID2\nfunc normalizeUserIDs(userID1, userID2 uuid.UUID) (uuid.UUID, uuid.UUID) {\n\tif userID1.String() \u003e userID2.String() {\n\t\treturn userID2, userID1\n\t}\n\treturn userID1, userID2\n}\n\nfunc (r *postgresFriendshipRepository) Create(ctx context.Context, friendship *models.Friendship) error {\n\tu1, u2 := normalizeUserIDs(friendship.UserID1, friendship.UserID2)\n\tquery := `INSERT INTO friendships (user_id1, user_id2, status) VALUES ($1, $2, $3)`\n\t_, err := r.db.ExecContext(ctx, query, u1, u2, friendship.Status)\n\tif err != nil {\n\t\tif pgErr, ok := err.(*pq.Error); ok \u0026\u0026 pgErr.Code == \"23505\" { // unique_violation\n\t\t\treturn models.ErrFriendRequestExists\n\t\t}\n\t\treturn fmt.Errorf(\"failed to create friendship: %w\", err)\n\t}\n\treturn nil\n}\n\nfunc (r *postgresFriendshipRepository) UpdateStatus(ctx context.Context, userID1, userID2 uuid.UUID, status models.FriendshipStatus) error {\n\tu1, u2 := normalizeUserIDs(userID1, userID2)\n\tquery := `UPDATE friendships SET status = $3 WHERE user_id1 = $1 AND user_id2 = $2`\n\tres, err := r.db.ExecContext(ctx, query, u1, u2, status)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to update friendship status: %w\", err)\n\t}\n\trowsAffected, err := res.RowsAffected()\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to get rows affected: %w\", err)\n\t}\n\tif rowsAffected == 0 {\n\t\treturn models.ErrFriendRequestNotFound\n\t}\n\treturn nil\n}\n\nfunc (r *postgresFriendshipRepository) Delete(ctx context.Context, userID1, userID2 uuid.UUID) error {\n\tu1, u2 := normalizeUserIDs(userID1, userID2)\n\tquery := `DELETE FROM friendships WHERE user_id1 = $1 AND user_id2 = $2`\n\tres, err := r.db.ExecContext(ctx, query, u1, u2)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to delete friendship: %w\", err)\n\t}\n\trowsAffected, err := res.RowsAffected()\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to get rows affected: %w\", err)\n\t}\n\tif rowsAffected == 0 {\n\t\treturn models.ErrNotFriends // Or request not found, context dependent\n\t}\n\treturn nil\n}\n\nfunc (r *postgresFriendshipRepository) Find(ctx context.Context, userID1, userID2 uuid.UUID) (*models.Friendship, error) {\n\tu1, u2 := normalizeUserIDs(userID1, userID2)\n\tquery := `SELECT user_id1, user_id2, status, created_at FROM friendships WHERE user_id1 = $1 AND user_id2 = $2`\n\tfriendship := \u0026models.Friendship{}\n\terr := r.db.QueryRowContext(ctx, query, u1, u2).Scan(\u0026friendship.UserID1, \u0026friendship.UserID2, \u0026friendship.Status, \u0026friendship.CreatedAt)\n\tif err != nil {\n\t\tif errors.Is(err, sql.ErrNoRows) {\n\t\t\treturn nil, models.ErrFriendRequestNotFound\n\t\t}\n\t\treturn nil, fmt.Errorf(\"failed to find friendship: %w\", err)\n\t}\n\treturn friendship, nil\n}\n\nfunc (r *postgresFriendshipRepository) ListByUserID(ctx context.Context, userID uuid.UUID, status models.FriendshipStatus) ([]*models.User, error) {\n\tquery := `\n\t\tSELECT u.id, u.username, u.profile_pic_url, u.created_at\n\t\tFROM users u\n\t\tJOIN friendships f ON (u.id = f.user_id1 OR u.id = f.user_id2)\n\t\tWHERE (f.user_id1 = $1 OR f.user_id2 = $1)\n\t\tAND u.id != $1\n\t\tAND f.status = $2\n\t`\n\trows, err := r.db.QueryContext(ctx, query, userID, status)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to list friends: %w\", err)\n\t}\n\tdefer rows.Close()\n\n\tvar users []*models.User\n\tfor rows.Next() {\n\t\tuser := \u0026models.User{}\n\t\tif err := rows.Scan(\u0026user.ID, \u0026user.Username, \u0026user.ProfilePicURL, \u0026user.CreatedAt); err != nil {\n\t\t\treturn nil, fmt.Errorf(\"failed to scan user row: %w\", err)\n\t\t}\n\t\tusers = append(users, user)\n\t}\n\treturn users, nil\n}\n",
  "backend/adapter/postgres/group_repo.go": "package postgres\n\nimport (\n\t\"context\"\n\t\"database/sql\"\n\t\"errors\"\n\t\"fmt\"\n\n\t\"chat-app/models\"\n\t\"chat-app/repository\"\n\n\t\"github.com/google/uuid\"\n\t\"github.com/lib/pq\"\n)\n\ntype postgresGroupRepository struct {\n\tdb *sql.DB\n}\n\nfunc NewPostgresGroupRepository(db *sql.DB) repository.GroupRepository {\n\treturn \u0026postgresGroupRepository{db: db}\n}\n\nfunc (r *postgresGroupRepository) Create(ctx context.Context, group *models.Group) error {\n\ttx, err := r.db.BeginTx(ctx, nil)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to begin transaction: %w\", err)\n\t}\n\tdefer tx.Rollback()\n\n\tquery := `INSERT INTO groups (id, handle, name, photo_url, owner_id) VALUES ($1, $2, $3, $4, $5)`\n\t_, err = tx.ExecContext(ctx, query, group.ID, group.Handle, group.Name, group.PhotoURL, group.OwnerID)\n\tif err != nil {\n\t\tif pgErr, ok := err.(*pq.Error); ok \u0026\u0026 pgErr.Code == \"23505\" { // unique_violation\n\t\t\treturn models.ErrGroupHandleTaken\n\t\t}\n\t\treturn fmt.Errorf(\"failed to create group: %w\", err)\n\t}\n\n\tmemberQuery := `INSERT INTO group_members (group_id, user_id) VALUES ($1, $2)`\n\t_, err = tx.ExecContext(ctx, memberQuery, group.ID, group.OwnerID)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to add owner as member: %w\", err)\n\t}\n\n\treturn tx.Commit()\n}\n\nfunc (r *postgresGroupRepository) Update(ctx context.Context, group *models.Group) error {\n\tquery := `UPDATE groups SET name = $2, photo_url = $3, owner_id = $4 WHERE id = $1`\n\tres, err := r.db.ExecContext(ctx, query, group.ID, group.Name, group.PhotoURL, group.OwnerID)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to update group: %w\", err)\n\t}\n\trowsAffected, err := res.RowsAffected()\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to get rows affected: %w\", err)\n\t}\n\tif rowsAffected == 0 {\n\t\treturn models.ErrGroupNotFound\n\t}\n\treturn nil\n}\n\nfunc (r *postgresGroupRepository) Delete(ctx context.Context, groupID uuid.UUID) error {\n\tquery := `DELETE FROM groups WHERE id = $1`\n\t_, err := r.db.ExecContext(ctx, query, groupID)\n\treturn err\n}\n\nfunc (r *postgresGroupRepository) FindByID(ctx context.Context, groupID uuid.UUID) (*models.Group, error) {\n\tquery := `SELECT id, handle, name, photo_url, owner_id, created_at FROM groups WHERE id = $1`\n\tgroup := \u0026models.Group{}\n\terr := r.db.QueryRowContext(ctx, query, groupID).Scan(\u0026group.ID, \u0026group.Handle, \u0026group.Name, \u0026group.PhotoURL, \u0026group.OwnerID, \u0026group.CreatedAt)\n\tif err != nil {\n\t\tif errors.Is(err, sql.ErrNoRows) {\n\t\t\treturn nil, models.ErrGroupNotFound\n\t\t}\n\t\treturn nil, fmt.Errorf(\"failed to find group by id: %w\", err)\n\t}\n\treturn group, nil\n}\n\nfunc (r *postgresGroupRepository) FindByHandle(ctx context.Context, handle string) (*models.Group, error) {\n\tquery := `SELECT id, handle, name, photo_url, owner_id, created_at FROM groups WHERE LOWER(handle) = LOWER($1)`\n\tgroup := \u0026models.Group{}\n\terr := r.db.QueryRowContext(ctx, query, handle).Scan(\u0026group.ID, \u0026group.Handle, \u0026group.Name, \u0026group.PhotoURL, \u0026group.OwnerID, \u0026group.CreatedAt)\n\tif err != nil {\n\t\tif errors.Is(err, sql.ErrNoRows) {\n\t\t\treturn nil, models.ErrGroupNotFound\n\t\t}\n\t\treturn nil, fmt.Errorf(\"failed to find group by handle: %w\", err)\n\t}\n\treturn group, nil\n}\n\nfunc (r *postgresGroupRepository) FuzzySearchByHandle(ctx context.Context, query string, limit int) ([]*models.Group, error) {\n\t// Note: For true fuzzy search, extensions like pg_trgm are better. This is a simple LIKE search.\n\tsqlQuery := `\n\t\tSELECT id, handle, name, photo_url, owner_id, created_at\n\t\tFROM groups\n\t\tWHERE LOWER(handle) LIKE LOWER($1)\n\t\tLIMIT $2\n\t`\n\trows, err := r.db.QueryContext(ctx, sqlQuery, \"%\"+query+\"%\", limit)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to search groups: %w\", err)\n\t}\n\tdefer rows.Close()\n\n\tvar groups []*models.Group\n\tfor rows.Next() {\n\t\tgroup := \u0026models.Group{}\n\t\tif err := rows.Scan(\u0026group.ID, \u0026group.Handle, \u0026group.Name, \u0026group.PhotoURL, \u0026group.OwnerID, \u0026group.CreatedAt); err != nil {\n\t\t\treturn nil, fmt.Errorf(\"failed to scan group row: %w\", err)\n\t\t}\n\t\tgroups = append(groups, group)\n\t}\n\treturn groups, nil\n}\n\nfunc (r *postgresGroupRepository) AddMember(ctx context.Context, member *models.GroupMember) error {\n\tquery := `INSERT INTO group_members (group_id, user_id) VALUES ($1, $2)`\n\t_, err := r.db.ExecContext(ctx, query, member.GroupID, member.UserID)\n\tif err != nil {\n\t\tif pgErr, ok := err.(*pq.Error); ok \u0026\u0026 pgErr.Code == \"23505\" { // unique_violation\n\t\t\treturn models.ErrAlreadyGroupMember\n\t\t}\n\t\treturn fmt.Errorf(\"failed to add group member: %w\", err)\n\t}\n\treturn nil\n}\n\nfunc (r *postgresGroupRepository) RemoveMember(ctx context.Context, groupID, userID uuid.UUID) error {\n\tquery := `DELETE FROM group_members WHERE group_id = $1 AND user_id = $2`\n\tres, err := r.db.ExecContext(ctx, query, groupID, userID)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to remove group member: %w\", err)\n\t}\n\trowsAffected, err := res.RowsAffected()\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to get rows affected: %w\", err)\n\t}\n\tif rowsAffected == 0 {\n\t\treturn models.ErrNotGroupMember\n\t}\n\treturn nil\n}\n\nfunc (r *postgresGroupRepository) FindMember(ctx context.Context, groupID, userID uuid.UUID) (*models.GroupMember, error) {\n\tquery := `SELECT group_id, user_id, joined_at FROM group_members WHERE group_id = $1 AND user_id = $2`\n\tmember := \u0026models.GroupMember{}\n\terr := r.db.QueryRowContext(ctx, query, groupID, userID).Scan(\u0026member.GroupID, \u0026member.UserID, \u0026member.JoinedAt)\n\tif err != nil {\n\t\tif errors.Is(err, sql.ErrNoRows) {\n\t\t\treturn nil, models.ErrNotGroupMember\n\t\t}\n\t\treturn nil, fmt.Errorf(\"failed to find group member: %w\", err)\n\t}\n\treturn member, nil\n}\n\nfunc (r *postgresGroupRepository) ListMembers(ctx context.Context, groupID uuid.UUID) ([]*models.User, error) {\n\tquery := `\n\t\tSELECT u.id, u.username, u.profile_pic_url, u.created_at\n\t\tFROM users u\n\t\tJOIN group_members gm ON u.id = gm.user_id\n\t\tWHERE gm.group_id = $1\n\t\tORDER BY gm.joined_at\n\t`\n\trows, err := r.db.QueryContext(ctx, query, groupID)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to list group members: %w\", err)\n\t}\n\tdefer rows.Close()\n\n\tvar users []*models.User\n\tfor rows.Next() {\n\t\tuser := \u0026models.User{}\n\t\tif err := rows.Scan(\u0026user.ID, \u0026user.Username, \u0026user.ProfilePicURL, \u0026user.CreatedAt); err != nil {\n\t\t\treturn nil, fmt.Errorf(\"failed to scan user row: %w\", err)\n\t\t}\n\t\tusers = append(users, user)\n\t}\n\treturn users, nil\n}\n\nfunc (r *postgresGroupRepository) GetOldestMember(ctx context.Context, groupID uuid.UUID) (*models.User, error) {\n\tquery := `\n\t\tSELECT u.id, u.username, u.profile_pic_url, u.created_at\n\t\tFROM users u\n\t\tJOIN group_members gm ON u.id = gm.user_id\n\t\tWHERE gm.group_id = $1\n\t\tORDER BY gm.joined_at ASC\n\t\tLIMIT 1\n\t`\n\tuser := \u0026models.User{}\n\terr := r.db.QueryRowContext(ctx, query, groupID).Scan(\u0026user.ID, \u0026user.Username, \u0026user.ProfilePicURL, \u0026user.CreatedAt)\n\tif err != nil {\n\t\tif errors.Is(err, sql.ErrNoRows) {\n\t\t\treturn nil, models.ErrGroupNotFound // Or no members, but group should have at least one\n\t\t}\n\t\treturn nil, fmt.Errorf(\"failed to get oldest member: %w\", err)\n\t}\n\treturn user, nil\n}\n",
  "backend/adapter/postgres/migrations/000001_init.sql": "CREATE EXTENSION IF NOT EXISTS \"uuid-ossp\";\n\nCREATE TABLE users (\n    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),\n    username VARCHAR(50) UNIQUE NOT NULL,\n    password_hash VARCHAR(255) NOT NULL,\n    profile_pic_url VARCHAR(255) DEFAULT '',\n    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()\n);\n\nCREATE INDEX idx_users_username ON users (LOWER(username));\n\nCREATE TABLE sessions (\n    refresh_token UUID PRIMARY KEY,\n    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,\n    expires_at TIMESTAMPTZ NOT NULL\n);\n\nCREATE INDEX idx_sessions_user_id ON sessions (user_id);\n",
  "backend/adapter/postgres/migrations/000002_add_social_features.sql": "-- +migrate Up\nCREATE TYPE friendship_status AS ENUM ('pending', 'accepted');\n\nCREATE TABLE friendships (\n    user_id1 UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,\n    user_id2 UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,\n    status friendship_status NOT NULL,\n    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),\n    PRIMARY KEY (user_id1, user_id2),\n    CHECK (user_id1 \u003c user_id2) -- Ensures canonical ordering to prevent duplicates like (A,B) and (B,A)\n);\n\nCREATE INDEX idx_friendships_user_id1 ON friendships(user_id1);\nCREATE INDEX idx_friendships_user_id2 ON friendships(user_id2);\n\nCREATE TABLE groups (\n    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),\n    handle VARCHAR(50) NOT NULL UNIQUE,\n    name VARCHAR(100) NOT NULL,\n    photo_url VARCHAR(255),\n    owner_id UUID NOT NULL REFERENCES users(id) ON DELETE SET NULL, -- Owner can leave, ownership transfers\n    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()\n);\n\nCREATE INDEX idx_groups_handle ON groups(LOWER(handle));\n\nCREATE TABLE group_members (\n    group_id UUID NOT NULL REFERENCES groups(id) ON DELETE CASCADE,\n    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,\n    joined_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),\n    PRIMARY KEY (group_id, user_id)\n);\n\nCREATE INDEX idx_group_members_group_id ON group_members(group_id);\nCREATE INDEX idx_group_members_user_id ON group_members(user_id);\n\n-- +migrate Down\nDROP TABLE IF EXISTS group_members;\nDROP TABLE IF EXISTS groups;\nDROP TABLE IF EXISTS friendships;\nDROP TYPE IF EXISTS friendship_status;\n",
  "backend/adapter/postgres/migrations/000003_add_events.sql": "-- +migrate Up\nCREATE TABLE events (\n    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),\n    type VARCHAR(50) NOT NULL,\n    payload JSONB NOT NULL,\n    recipient_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,\n    sender_id UUID REFERENCES users(id) ON DELETE SET NULL,\n    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()\n);\n\nCREATE INDEX idx_events_recipient_id_created_at ON events (recipient_id, created_at DESC);\n\n-- +migrate Down\nDROP TABLE IF EXISTS events;\n",
  "backend/adapter/postgres/session_repo.go": "package postgres\n\nimport (\n\t\"chat-app/backend/models\"\n\t\"chat-app/backend/repository\"\n\t\"context\"\n\t\"database/sql\"\n\t\"errors\"\n\n\t\"github.com/google/uuid\"\n)\n\ntype postgresSessionRepository struct {\n\tdb *sql.DB\n}\n\nfunc NewPostgresSessionRepository(db *sql.DB) repository.SessionRepository {\n\treturn \u0026postgresSessionRepository{db: db}\n}\n\nfunc (r *postgresSessionRepository) Create(ctx context.Context, session *models.Session) error {\n\tquery := `\n        INSERT INTO sessions (refresh_token, user_id, expires_at)\n        VALUES ($1, $2, $3)\n        ON CONFLICT (refresh_token) DO UPDATE SET\n        expires_at = EXCLUDED.expires_at`\n\t_, err := r.db.ExecContext(ctx, query, session.RefreshToken, session.UserID, session.ExpiresAt)\n\treturn err\n}\n\nfunc (r *postgresSessionRepository) Find(ctx context.Context, refreshToken uuid.UUID) (*models.Session, error) {\n\tquery := `SELECT refresh_token, user_id, expires_at FROM sessions WHERE refresh_token = $1`\n\tsession := \u0026models.Session{}\n\terr := r.db.QueryRowContext(ctx, query, refreshToken).Scan(\u0026session.RefreshToken, \u0026session.UserID, \u0026session.ExpiresAt)\n\tif err != nil {\n\t\tif errors.Is(err, sql.ErrNoRows) {\n\t\t\treturn nil, models.ErrSessionNotFound\n\t\t}\n\t\treturn nil, err\n\t}\n\treturn session, nil\n}\n\nfunc (r *postgresSessionRepository) Delete(ctx context.Context, refreshToken uuid.UUID) error {\n\tquery := `DELETE FROM sessions WHERE refresh_token = $1`\n\t_, err := r.db.ExecContext(ctx, query, refreshToken)\n\treturn err\n}\n\nfunc (r *postgresSessionRepository) DeleteByUserID(ctx context.Context, userID uuid.UUID) error {\n\tquery := `DELETE FROM sessions WHERE user_id = $1`\n\t_, err := r.db.ExecContext(ctx, query, userID)\n\treturn err\n}",
  "backend/adapter/postgres/user_repo.go": "package postgres\n\nimport (\n\t\"chat-app/backend/models\"\n\t\"chat-app/backend/repository\"\n\t\"context\"\n\t\"database/sql\"\n\t\"errors\"\n\t\"strings\"\n\n\t\"github.com/google/uuid\"\n\t\"github.com/lib/pq\"\n)\n\ntype postgresUserRepository struct {\n\tdb *sql.DB\n}\n\nfunc NewPostgresUserRepository(db *sql.DB) repository.UserRepository {\n\treturn \u0026postgresUserRepository{db: db}\n}\n\nfunc (r *postgresUserRepository) Create(ctx context.Context, user *models.User) error {\n\tquery := `INSERT INTO users (id, username, password_hash, profile_pic_url) VALUES ($1, $2, $3, $4)`\n\t_, err := r.db.ExecContext(ctx, query, user.ID, user.Username, user.PasswordHash, user.ProfilePicURL)\n\tif err != nil {\n\t\tif pgErr, ok := err.(*pq.Error); ok \u0026\u0026 pgErr.Code == \"23505\" { // unique_violation\n\t\t\treturn models.ErrUsernameTaken\n\t\t}\n\t\treturn err\n\t}\n\treturn nil\n}\n\nfunc (r *postgresUserRepository) FindByUsername(ctx context.Context, username string) (*models.User, error) {\n\tquery := `SELECT id, username, password_hash, profile_pic_url, created_at FROM users WHERE LOWER(username) = $1`\n\tuser := \u0026models.User{}\n\terr := r.db.QueryRowContext(ctx, query, strings.ToLower(username)).Scan(\u0026user.ID, \u0026user.Username, \u0026user.PasswordHash, \u0026user.ProfilePicURL, \u0026user.CreatedAt)\n\tif err != nil {\n\t\tif errors.Is(err, sql.ErrNoRows) {\n\t\t\treturn nil, models.ErrUserNotFound\n\t\t}\n\t\treturn nil, err\n\t}\n\treturn user, nil\n}\n\nfunc (r *postgresUserRepository) FindByID(ctx context.Context, id uuid.UUID) (*models.User, error) {\n\tquery := `SELECT id, username, password_hash, profile_pic_url, created_at FROM users WHERE id = $1`\n\tuser := \u0026models.User{}\n\terr := r.db.QueryRowContext(ctx, query, id).Scan(\u0026user.ID, \u0026user.Username, \u0026user.PasswordHash, \u0026user.ProfilePicURL, \u0026user.CreatedAt)\n\tif err != nil {\n\t\tif errors.Is(err, sql.ErrNoRows) {\n\t\t\treturn nil, models.ErrUserNotFound\n\t\t}\n\t\treturn nil, err\n\t}\n\treturn user, nil\n}\n\nfunc (r *postgresUserRepository) Update(ctx context.Context, user *models.User) error {\n\tquery := `UPDATE users SET username = $1, password_hash = $2, profile_pic_url = $3 WHERE id = $4`\n\t_, err := r.db.ExecContext(ctx, query, user.Username, user.PasswordHash, user.ProfilePicURL, user.ID)\n\tif err != nil {\n\t\tif pgErr, ok := err.(*pq.Error); ok \u0026\u0026 pgErr.Code == \"23505\" {\n\t\t\treturn models.ErrUsernameTaken\n\t\t}\n\t\treturn err\n\t}\n\treturn nil\n}\n",
  "backend/adapter/redis/event_repo.go": "package redis\n\nimport (\n\t\"context\"\n\t\"encoding/json\"\n\t\"time\"\n\n\t\"chat-app/models\"\n\t\"chat-app/repository\"\n\n\t\"github.com/go-redis/redis/v8\"\n\t\"github.com/google/uuid\"\n)\n\nconst (\n\teventBufferKey = \"event_buffer\"\n)\n\ntype redisEventRepository struct {\n\trdb *redis.Client\n}\n\nfunc NewRedisEventRepository(rdb *redis.Client) repository.EventRepository {\n\treturn \u0026redisEventRepository{rdb: rdb}\n}\n\n// These methods are for the Redis part of the EventRepository interface\nfunc (r *redisEventRepository) BufferEvent(ctx context.Context, event *models.Event) error {\n\tdata, err := json.Marshal(event)\n\tif err != nil {\n\t\treturn err\n\t}\n\t// Use a sorted set, score is timestamp. This allows easy retrieval in order.\n\treturn r.rdb.ZAdd(ctx, eventBufferKey, \u0026redis.Z{\n\t\tScore:  float64(event.CreatedAt.UnixNano()),\n\t\tMember: data,\n\t}).Err()\n}\n\nfunc (r *redisEventRepository) GetBufferedEvents(ctx context.Context, count int) ([]*models.Event, error) {\n\tresults, err := r.rdb.ZRange(ctx, eventBufferKey, 0, int64(count-1)).Result()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tvar events []*models.Event\n\tfor _, res := range results {\n\t\tvar event models.Event\n\t\tif err := json.Unmarshal([]byte(res), \u0026event); err == nil {\n\t\t\tevents = append(events, \u0026event)\n\t\t}\n\t}\n\treturn events, nil\n}\n\nfunc (r *redisEventRepository) DeleteBufferedEvents(ctx context.Context, events []*models.Event) error {\n\tif len(events) == 0 {\n\t\treturn nil\n\t}\n\tmembers := make([]interface{}, len(events))\n\tfor i, event := range events {\n\t\tdata, err := json.Marshal(event)\n\t\tif err != nil {\n\t\t\t// Log this error but continue\n\t\t\tcontinue\n\t\t}\n\t\tmembers[i] = data\n\t}\n\treturn r.rdb.ZRem(ctx, eventBufferKey, members...).Err()\n}\n\n// These methods are for the Postgres part of the interface, so they are no-ops here.\nfunc (r *redisEventRepository) Store(ctx context.Context, event *models.Event) error {\n\treturn nil // No-op\n}\nfunc (r *redisEventRepository) FetchUndelivered(ctx context.Context, userID uuid.UUID, cursor time.Time, limit int) ([]*models.Event, error) {\n\treturn nil, nil // No-op\n}\nfunc (r *redisEventRepository) Delete(ctx context.Context, eventID uuid.UUID) error {\n\treturn nil // No-op\n}\nfunc (r *redisEventRepository) StoreBatch(ctx context.Context, events []*models.Event) error {\n\treturn nil // No-op\n}\n",
  "backend/adapter/redis/redis.go": "package redis\n\nimport (\n\t\"chat-app/config\"\n\t\"github.com/go-redis/redis/v8\"\n)\n\nfunc NewRedisClient(cfg *config.Config) *redis.Client {\n\trdb := redis.NewClient(\u0026redis.Options{\n\t\tAddr:     cfg.RedisAddr,\n\t\tPassword: cfg.RedisPassword,\n\t\tDB:       0, // use default DB\n\t})\n\treturn rdb\n}\n",
  "backend/adapter/util/password.go": "package util\n\nimport \"golang.org/x/crypto/bcrypt\"\n\nfunc HashPassword(password string) (string, error) {\n\tbytes, err := bcrypt.GenerateFromPassword([]byte(password), 14)\n\treturn string(bytes), err\n}\n\nfunc CheckPasswordHash(password, hash string) bool {\n\terr := bcrypt.CompareHashAndPassword([]byte(hash), []byte(password))\n\treturn err == nil\n}\n",
  "backend/adapter/util/response.go": "package util\n\nimport (\n\t\"encoding/json\"\n\t\"net/http\"\n)\n\nfunc RespondWithError(w http.ResponseWriter, code int, message string) {\n\tRespondWithJSON(w, code, map[string]string{\"error\": message})\n}\n\nfunc RespondWithJSON(w http.ResponseWriter, code int, payload interface{}) {\n\tresponse, _ := json.Marshal(payload)\n\tw.Header().Set(\"Content-Type\", \"application/json\")\n\tw.WriteHeader(code)\n\tw.Write(response)\n}\n",
  "backend/adapter/util/token.go": "package util\n\nimport (\n\t\"time\"\n\n\t\"github.com/golang-jwt/jwt/v5\"\n\t\"github.com/google/uuid\"\n)\n\ntype TokenGenerator interface {\n\tGenerateAccessToken(userID uuid.UUID) (string, error)\n\tGenerateRefreshToken() (uuid.UUID, time.Time, error)\n\tGetRefreshTokenExp() time.Duration\n}\n\ntype tokenGenerator struct {\n\tjwtSecret       string\n\taccessTokenExp  time.Duration\n\trefreshTokenExp time.Duration\n}\n\nfunc NewTokenGenerator(secret string, accessExp, refreshExp time.Duration) TokenGenerator {\n\treturn \u0026tokenGenerator{\n\t\tjwtSecret:       secret,\n\t\taccessTokenExp:  accessExp,\n\t\trefreshTokenExp: refreshExp,\n\t}\n}\n\nfunc (t *tokenGenerator) GenerateAccessToken(userID uuid.UUID) (string, error) {\n\tclaims := jwt.MapClaims{\n\t\t\"user_id\": userID.String(),\n\t\t\"exp\":     time.Now().Add(t.accessTokenExp).Unix(),\n\t\t\"iat\":     time.Now().Unix(),\n\t}\n\ttoken := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)\n\treturn token.SignedString([]byte(t.jwtSecret))\n}\n\nfunc (t *tokenGenerator) GenerateRefreshToken() (uuid.UUID, time.Time, error) {\n\trefreshToken := uuid.New()\n\texpiresAt := time.Now().Add(t.refreshTokenExp)\n\treturn refreshToken, expiresAt, nil\n}\n\nfunc (t *tokenGenerator) GetRefreshTokenExp() time.Duration {\n\treturn t.refreshTokenExp\n}\n",
  "backend/adapter/util/validation.go": "package util\n\nimport (\n\t\"errors\"\n\t\"mime/multipart\"\n\t\"regexp\"\n\t\"strings\"\n)\n\nvar (\n\tusernameRegex    = regexp.MustCompile(`^[a-z0-9_]{4,50}$`)\n\tgroupHandleRegex = regexp.MustCompile(`^[a-z0-9_]{4,50}$`)\n)\n\nfunc ValidateUsername(username string) error {\n\tif !usernameRegex.MatchString(username) {\n\t\treturn errors.New(\"username must be 4-50 characters and contain only lowercase letters, digits, and underscores\")\n\t}\n\treturn nil\n}\n\nfunc ValidateGroupHandle(handle string) error {\n\t// Format: string prefix + #groupname\n\tparts := strings.Split(handle, \"#\")\n\tif len(parts) != 2 || parts[0] == \"\" || parts[1] == \"\" {\n\t\treturn errors.New(\"group handle must be in the format 'prefix#groupname'\")\n\t}\n\n\tgroupname := parts[1]\n\tif !groupHandleRegex.MatchString(groupname) {\n\t\treturn errors.New(\"group name part of handle must be 4-50 characters and contain only lowercase letters, digits, and underscores\")\n\t}\n\treturn nil\n}\n\nfunc ValidatePassword(password string) error {\n\tif len(password) \u003c 8 {\n\t\treturn errors.New(\"password must be at least 8 characters long\")\n\t}\n\treturn nil\n}\n\nfunc ValidateProfilePic(header *multipart.FileHeader) error {\n\t// Max size: 200 KB\n\tif header.Size \u003e 200*1024 {\n\t\treturn errors.New(\"profile picture size cannot exceed 200 KB\")\n\t}\n\n\t// Allowed formats: png, jpg, jpeg, webp\n\tcontentType := header.Header.Get(\"Content-Type\")\n\tswitch contentType {\n\tcase \"image/png\", \"image/jpeg\", \"image/webp\":\n\t\treturn nil\n\tdefault:\n\t\treturn errors.New(\"invalid file format. Only png, jpg, jpeg, and webp are allowed\")\n\t}\n}\n",
  "backend/cmd/server/main.go": "package main\n\nimport (\n\t\"context\"\n\t\"database/sql\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"log\"\n\t\"net/http\"\n\t\"os\"\n\t\"os/signal\"\n\t\"strings\"\n\t\"syscall\"\n\t\"time\"\n\n\t\"chat-app/backend/adapter/filesystem\"\n\thttpHandler \"chat-app/backend/adapter/handler/http\"\n\t\"chat-app/backend/adapter/handler/ws\"\n\t\"chat-app/backend/adapter/middleware\"\n\t\"chat-app/backend/adapter/postgres\"\n\t\"chat-app/backend/adapter/redis\"\n\t\"chat-app/backend/adapter/util\"\n\t\"chat-app/backend/config\"\n\t\"chat-app/backend/models\"\n\t\"chat-app/backend/usecase\"\n\n\t\"github.com/go-chi/chi/v5\"\n\tchiMiddleware \"github.com/go-chi/chi/v5/middleware\"\n\t\"github.com/go-chi/cors\"\n\t_ \"github.com/lib/pq\"\n)\n\nfunc fileServer(r chi.Router, path string, root http.FileSystem) {\n\tif strings.ContainsAny(path, \"{}*\") {\n\t\tpanic(\"FileServer does not permit URL parameters.\")\n\t}\n\n\tfs := http.StripPrefix(path, http.FileServer(root))\n\n\tif path != \"/\" \u0026\u0026 path[len(path)-1] != '/' {\n\t\tr.Get(path, http.RedirectHandler(path+\"/\", http.StatusMovedPermanently).ServeHTTP)\n\t\tpath += \"/\"\n\t}\n\tpath += \"*\"\n\n\tr.Get(path, func(w http.ResponseWriter, r *http.Request) {\n\t\tfs.ServeHTTP(w, r)\n\t})\n}\n\nfunc main() {\n\tcfg, err := config.Load()\n\tif err != nil {\n\t\tlog.Fatalf(\"failed to load config: %v\", err)\n\t}\n\n\tdb, err := postgres.NewDB(cfg)\n\tif err != nil {\n\t\tlog.Fatalf(\"failed to connect to postgres: %v\", err)\n\t}\n\tdefer db.Close()\n\n\trdb := redis.NewRedisClient(cfg)\n\tif _, err := rdb.Ping(context.Background()).Result(); err != nil {\n\t\tlog.Fatalf(\"failed to connect to redis: %v\", err)\n\t}\n\tdefer rdb.Close()\n\n\t// Repositories\n\tuserRepo := postgres.NewPostgresUserRepository(db)\n\tsessionRepo := postgres.NewPostgresSessionRepository(db)\n\tfriendRepo := postgres.NewPostgresFriendshipRepository(db)\n\tgroupRepo := postgres.NewPostgresGroupRepository(db)\n\tfileRepo := filesystem.NewLocalStorage(cfg.ProfilePicDir, cfg.ProfilePicRoute)\n\tredisEventRepo := redis.NewRedisEventRepository(rdb)\n\tdbEventRepo := postgres.NewPostgresEventRepository(db)\n\n\t// Utilities\n\ttokenGen := util.NewTokenGenerator(cfg.JWTSecret, cfg.AccessTokenExp, cfg.RefreshTokenExp)\n\n\t// Usecases\n\teventUsecase := usecase.NewEventUsecase(redisEventRepo, dbEventRepo)\n\tauthUsecase := usecase.NewAuthUsecase(userRepo, sessionRepo, tokenGen)\n\tuserUsecase := usecase.NewUserUsecase(userRepo, fileRepo)\n\tfriendUsecase := usecase.NewFriendUsecase(userRepo, friendRepo, eventUsecase)\n\tgroupUsecase := usecase.NewGroupUsecase(groupRepo, userRepo, friendRepo, fileRepo, eventUsecase)\n\n\t// Handlers\n\tauthHandler := httpHandler.NewAuthHandler(authUsecase)\n\tuserHandler := httpHandler.NewUserHandler(userUsecase)\n\tfriendHandler := httpHandler.NewFriendHandler(friendUsecase)\n\tgroupHandler := httpHandler.NewGroupHandler(groupUsecase)\n\twebHandler := httpHandler.NewWebHandler(\"./web/templates\")\n\n\t// WebSocket Hub\n\thub := ws.NewHub(eventUsecase, groupUsecase)\n\tgo hub.Run()\n\n\t// Background worker for event persistence\n\tgo func() {\n\t\tticker := time.NewTicker(10 * time.Second)\n\t\tdefer ticker.Stop()\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase \u003c-ticker.C:\n\t\t\t\tctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)\n\t\t\t\tevents, err := redisEventRepo.GetBufferedEvents(ctx, 100)\n\t\t\t\tif err != nil {\n\t\t\t\t\tlog.Printf(\"error getting buffered events: %v\", err)\n\t\t\t\t\tcancel()\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\tif len(events) \u003e 0 {\n\t\t\t\t\tif err := dbEventRepo.StoreBatch(ctx, events); err != nil {\n\t\t\t\t\t\tlog.Printf(\"error storing event batch to db: %v\", err)\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif err := redisEventRepo.DeleteBufferedEvents(ctx, events); err != nil {\n\t\t\t\t\t\t\tlog.Printf(\"error deleting buffered events from redis: %v\", err)\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcancel()\n\t\t\t}\n\t\t}\n\t}()\n\n\trouter := chi.NewRouter()\n\trouter.Use(chiMiddleware.Recoverer)\n\trouter.Use(middleware.Logging)\n\trouter.Use(cors.Handler(cors.Options{\n\t\tAllowedOrigins:   []string{\"http://*\", \"https://*\"},\n\t\tAllowedMethods:   []string{\"GET\", \"POST\", \"PUT\", \"DELETE\", \"OPTIONS\"},\n\t\tAllowedHeaders:   []string{\"Accept\", \"Authorization\", \"Content-Type\", \"X-CSRF-Token\"},\n\t\tExposedHeaders:   []string{\"Link\"},\n\t\tAllowCredentials: true,\n\t\tMaxAge:           300,\n\t}))\n\n\t// Health and Metrics endpoints\n\trouter.Get(\"/healthz\", func(w http.ResponseWriter, r *http.Request) {\n\t\tw.Header().Set(\"Content-Type\", \"text/plain\")\n\t\tw.WriteHeader(http.StatusOK)\n\t\tw.Write([]byte(\"OK\"))\n\t})\n\trouter.Get(\"/metrics\", func(w http.ResponseWriter, r *http.Request) {\n\t\tmetrics := struct {\n\t\t\tConnectedClients int `json:\"connected_clients\"`\n\t\t}{\n\t\t\tConnectedClients: hub.GetClientCount(),\n\t\t}\n\t\tw.Header().Set(\"Content-Type\", \"application/json\")\n\t\tw.WriteHeader(http.StatusOK)\n\t\tjson.NewEncoder(w).Encode(metrics)\n\t})\n\n\t// Public API routes\n\trouter.Group(func(r chi.Router) {\n\t\tr.Use(middleware.RateLimit)\n\t\tr.Post(\"/api/v1/register\", userHandler.Register)\n\t\tr.Post(\"/api/v1/login\", authHandler.Login)\n\t\tr.Post(\"/api/v1/refresh\", authHandler.Refresh)\n\t\tr.Post(\"/api/v1/logout\", authHandler.Logout)\n\t})\n\n\t// Protected API routes\n\tauthMiddleware := middleware.NewAuthMiddleware(cfg.JWTSecret)\n\trouter.Group(func(r chi.Router) {\n\t\tr.Use(authMiddleware.Validate)\n\t\tr.Use(middleware.RateLimit)\n\n\t\t// User routes\n\t\tr.Get(\"/api/v1/users/{username}\", userHandler.GetUserByUsername)\n\t\tr.Put(\"/api/v1/me\", userHandler.UpdateProfile)\n\n\t\t// Friend routes\n\t\tr.Post(\"/api/v1/friends/requests\", friendHandler.SendRequest)\n\t\tr.Put(\"/api/v1/friends/requests/{requesterID}\", friendHandler.RespondToRequest)\n\t\tr.Delete(\"/api/v1/friends/{friendID}\", friendHandler.Unfriend)\n\t\tr.Get(\"/api/v1/friends\", friendHandler.ListFriends)\n\t\tr.Get(\"/api/v1/friends/requests/pending\", friendHandler.ListPendingRequests)\n\n\t\t// Group routes\n\t\tr.Post(\"/api/v1/groups\", groupHandler.CreateGroup)\n\t\tr.Post(\"/api/v1/groups/join\", groupHandler.JoinGroup)\n\t\tr.Post(\"/api/v1/groups/{groupID}/leave\", groupHandler.LeaveGroup)\n\t\tr.Post(\"/api/v1/groups/{groupID}/members\", groupHandler.AddMember)\n\t\tr.Delete(\"/api/v1/groups/{groupID}/members/{memberID}\", groupHandler.RemoveMember)\n\t\tr.Get(\"/api/v1/groups/search\", groupHandler.SearchGroups)\n\n\t\t// WebSocket route\n\t\tr.Get(\"/ws\", func(w http.ResponseWriter, r *http.Request) {\n\t\t\tws.ServeWs(hub, w, r)\n\t\t})\n\t})\n\n\t// Serve static files\n\tfileServer(router, \"/static\", http.Dir(\"web/static\"))\n\tfileServer(router, cfg.ProfilePicRoute, http.Dir(cfg.ProfilePicDir))\n\n\t// Serve Web App\n\trouter.Get(\"/*\", webHandler.ServeApp)\n\n\t// Server setup\n\tsrv := \u0026http.Server{\n\t\tAddr:    \":\" + cfg.ServerPort,\n\t\tHandler: router,\n\t}\n\n\tgo func() {\n\t\tlog.Printf(\"Server starting on port %s\", cfg.ServerPort)\n\t\tif err := srv.ListenAndServe(); err != nil \u0026\u0026 err != http.ErrServerClosed {\n\t\t\tlog.Fatalf(\"listen: %s\\n\", err)\n\t\t}\n\t}()\n\n\t// Graceful shutdown\n\tquit := make(chan os.Signal, 1)\n\tsignal.Notify(quit, syscall.SIGINT, syscall.SIGTERM)\n\t\u003c-quit\n\tlog.Println(\"Shutting down server...\")\n\n\tctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)\n\tdefer cancel()\n\tif err := srv.Shutdown(ctx); err != nil {\n\t\tlog.Fatal(\"Server forced to shutdown:\", err)\n\t}\n\n\tlog.Println(\"Server exiting\")\n}\n",
  "backend/config/config.go": "package config\n\nimport (\n\t\"os\"\n\t\"strconv\"\n\t\"time\"\n\n\t\"github.com/joho/godotenv\"\n)\n\ntype Config struct {\n\tServerPort      string\n\tDBHost          string\n\tDBPort          string\n\tDBUser          string\n\tDBPassword      string\n\tDBName          string\n\tDBSslMode       string\n\tRedisAddr       string\n\tRedisPassword   string\n\tJWTSecret       string\n\tAccessTokenExp  time.Duration\n\tRefreshTokenExp time.Duration\n\tProfilePicDir   string\n\tProfilePicRoute string\n}\n\nfunc getEnv(key, fallback string) string {\n\tif value, ok := os.LookupEnv(key); ok {\n\t\treturn value\n\t}\n\treturn fallback\n}\n\nfunc Load() (*Config, error) {\n\tif err := godotenv.Load(); err != nil {\n\t\t// Ignore error if .env file is not found, for production environments\n\t\tif !os.IsNotExist(err) {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\tserverPort := getEnv(\"SERVER_PORT\", \"8080\")\n\tdbHost := getEnv(\"DB_HOST\", \"localhost\")\n\tdbPort := getEnv(\"DB_PORT\", \"5432\")\n\tdbUser := getEnv(\"DB_USER\", \"user\")\n\tdbPassword := getEnv(\"DB_PASSWORD\", \"password\")\n\tdbName := getEnv(\"DB_NAME\", \"quikchat\")\n\tdbSslMode := getEnv(\"DB_SSLMODE\", \"disable\")\n\tredisAddr := getEnv(\"REDIS_ADDR\", \"localhost:6379\")\n\tredisPassword := getEnv(\"REDIS_PASSWORD\", \"\")\n\tjwtSecret := getEnv(\"JWT_SECRET\", \"a-very-secret-key-that-is-long-enough\")\n\tprofilePicDir := getEnv(\"PROFILE_PIC_DIR\", \"./uploads/profile_pics\")\n\tprofilePicRoute := getEnv(\"PROFILE_PIC_ROUTE\", \"/static/profile_pics\")\n\n\taccessExpMin, _ := strconv.Atoi(getEnv(\"JWT_ACCESS_TOKEN_EXP_MIN\", \"10\"))\n\trefreshExpHour, _ := strconv.Atoi(getEnv(\"JWT_REFRESH_TOKEN_EXP_HOUR\", \"8\"))\n\n\tcfg := \u0026Config{\n\t\tServerPort:      serverPort,\n\t\tDBHost:          dbHost,\n\t\tDBPort:          dbPort,\n\t\tDBUser:          dbUser,\n\t\tDBPassword:      dbPassword,\n\t\tDBName:          dbName,\n\t\tDBSslMode:       dbSslMode,\n\t\tRedisAddr:       redisAddr,\n\t\tRedisPassword:   redisPassword,\n\t\tJWTSecret:       jwtSecret,\n\t\tAccessTokenExp:  time.Duration(accessExpMin) * time.Minute,\n\t\tRefreshTokenExp: time.Duration(refreshExpHour) * time.Hour,\n\t\tProfilePicDir:   profilePicDir,\n\t\tProfilePicRoute: profilePicRoute,\n\t}\n\n\tif err := os.MkdirAll(cfg.ProfilePicDir, os.ModePerm); err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn cfg, nil\n}\n",
  "backend/models/error.go": "package models\n\nimport \"errors\"\n\nvar (\n\t// User \u0026 Auth\n\tErrUserNotFound       = errors.New(\"user not found\")\n\tErrUsernameTaken      = errors.New(\"username is already taken\")\n\tErrInvalidCredentials = errors.New(\"invalid username or password\")\n\tErrSessionNotFound    = errors.New(\"session not found or expired\")\n\tErrInvalidToken       = errors.New(\"invalid token\")\n\tErrUnauthorized       = errors.New(\"unauthorized\")\n\tErrInternalServer     = errors.New(\"internal server error\")\n\tErrBadRequest         = errors.New(\"bad request\")\n\n\t// Friendship\n\tErrFriendRequestExists   = errors.New(\"friend request already exists\")\n\tErrAlreadyFriends        = errors.New(\"users are already friends\")\n\tErrNotFriends            = errors.New(\"users are not friends\")\n\tErrFriendRequestNotFound = errors.New(\"friend request not found\")\n\tErrCannotFriendSelf      = errors.New(\"cannot send friend request to yourself\")\n\n\t// Group\n\tErrGroupNotFound      = errors.New(\"group not found\")\n\tErrGroupHandleTaken   = errors.New(\"group handle is already taken\")\n\tErrNotGroupOwner      = errors.New(\"user is not the group owner\")\n\tErrNotGroupMember     = errors.New(\"user is not a group member\")\n\tErrAlreadyGroupMember = errors.New(\"user is already a group member\")\n\tErrCannotRemoveOwner  = errors.New(\"cannot remove the group owner\")\n)",
  "backend/models/event.go": "package models\n\nimport (\n\t\"encoding/json\"\n\t\"time\"\n\n\t\"github.com/google/uuid\"\n)\n\ntype EventType string\n\nconst (\n\t// Messaging\n\tEventMessageSent EventType = \"message_sent\"\n\tEventMessageAck  EventType = \"message_ack\"\n\n\t// Friend Management\n\tEventFriendRequestReceived EventType = \"friend_request_received\"\n\tEventFriendRequestAccepted EventType = \"friend_request_accepted\"\n\tEventFriendRequestRejected EventType = \"friend_request_rejected\"\n\tEventUnfriended            EventType = \"unfriended\"\n\n\t// Group Management\n\tEventAddedToGroup     EventType = \"added_to_group\"\n\tEventRemovedFromGroup EventType = \"removed_from_group\"\n\tEventUserJoinedGroup  EventType = \"user_joined_group\"\n\tEventUserLeftGroup    EventType = \"user_left_group\"\n)\n\ntype Event struct {\n\tID          uuid.UUID       `json:\"id\"`\n\tType        EventType       `json:\"type\"`\n\tPayload     json.RawMessage `json:\"payload\"`\n\tRecipientID uuid.UUID       `json:\"-\"`\n\tCreatedAt   time.Time       `json:\"createdAt\"`\n\tSenderID    *uuid.UUID      `json:\"senderId,omitempty\"` // Optional, for messages etc.\n}\n",
  "backend/models/friendship.go": "package models\n\nimport (\n\t\"time\"\n\n\t\"github.com/google/uuid\"\n)\n\ntype FriendshipStatus string\n\nconst (\n\tFriendshipStatusPending  FriendshipStatus = \"pending\"\n\tFriendshipStatusAccepted FriendshipStatus = \"accepted\"\n)\n\ntype Friendship struct {\n\tUserID1   uuid.UUID        `json:\"userId1\"`\n\tUserID2   uuid.UUID        `json:\"userId2\"`\n\tStatus    FriendshipStatus `json:\"status\"`\n\tCreatedAt time.Time        `json:\"createdAt\"`\n}\n",
  "backend/models/group.go": "package models\n\nimport (\n\t\"time\"\n\n\t\"github.com/google/uuid\"\n)\n\ntype Group struct {\n\tID        uuid.UUID `json:\"id\"`\n\tHandle    string    `json:\"handle\"`\n\tName      string    `json:\"name\"`\n\tPhotoURL  string    `json:\"photoUrl\"`\n\tOwnerID   uuid.UUID `json:\"ownerId\"`\n\tCreatedAt time.Time `json:\"createdAt\"`\n}\n\ntype GroupMember struct {\n\tGroupID  uuid.UUID `json:\"groupId\"`\n\tUserID   uuid.UUID `json:\"userId\"`\n\tJoinedAt time.Time `json:\"joinedAt\"`\n}\n",
  "backend/models/session.go": "package models\n\nimport (\n\t\"time\"\n\n\t\"github.com/google/uuid\"\n)\n\ntype Session struct {\n\tRefreshToken uuid.UUID `json:\"refreshToken\"`\n\tUserID       uuid.UUID `json:\"userId\"`\n\tExpiresAt    time.Time `json:\"expiresAt\"`\n}\n",
  "backend/models/user.go": "package models\n\nimport (\n\t\"time\"\n\n\t\"github.com/google/uuid\"\n)\n\ntype User struct {\n\tID           uuid.UUID `json:\"id\"`\n\tUsername     string    `json:\"username\"`\n\tPasswordHash string    `json:\"-\"`\n\tProfilePicURL string    `json:\"profilePicUrl\"`\n\tCreatedAt    time.Time `json:\"createdAt\"`\n}\n",
  "backend/repository/event_repository.go": "package repository\n\nimport (\n\t\"context\"\n\t\"chat-app/models\"\n\t\"github.com/google/uuid\"\n\t\"time\"\n)\n\ntype EventRepository interface {\n\t// For Redis (buffering)\n\tBufferEvent(ctx context.Context, event *models.Event) error\n\tGetBufferedEvents(ctx context.Context, count int) ([]*models.Event, error)\n\tDeleteBufferedEvents(ctx context.Context, events []*models.Event) error\n\n\t// For Postgres (durable storage)\n\tStore(ctx context.Context, event *models.Event) error\n\tFetchUndelivered(ctx context.Context, userID uuid.UUID, cursor time.Time, limit int) ([]*models.Event, error)\n\tDelete(ctx context.Context, eventID uuid.UUID) error\n\tStoreBatch(ctx context.Context, events []*models.Event) error\n}\n",
  "backend/repository/file_repository.go": "package repository\n\nimport \"mime/multipart\"\n\ntype FileRepository interface {\n\tSave(file multipart.File, header *multipart.FileHeader) (string, error)\n}\n",
  "backend/repository/friendship_repository.go": "package repository\n\nimport (\n\t\"context\"\n\t\"chat-app/models\"\n\n\t\"github.com/google/uuid\"\n)\n\ntype FriendshipRepository interface {\n\tCreate(ctx context.Context, friendship *models.Friendship) error\n\tUpdateStatus(ctx context.Context, userID1, userID2 uuid.UUID, status models.FriendshipStatus) error\n\tDelete(ctx context.Context, userID1, userID2 uuid.UUID) error\n\tFind(ctx context.Context, userID1, userID2 uuid.UUID) (*models.Friendship, error)\n\tListByUserID(ctx context.Context, userID uuid.UUID, status models.FriendshipStatus) ([]*models.User, error)\n}\n",
  "backend/repository/group_repository.go": "package repository\n\nimport (\n\t\"context\"\n\t\"chat-app/models\"\n\n\t\"github.com/google/uuid\"\n)\n\ntype GroupRepository interface {\n\tCreate(ctx context.Context, group *models.Group) error\n\tUpdate(ctx context.Context, group *models.Group) error\n\tDelete(ctx context.Context, groupID uuid.UUID) error\n\tFindByID(ctx context.Context, groupID uuid.UUID) (*models.Group, error)\n\tFindByHandle(ctx context.Context, handle string) (*models.Group, error)\n\tFuzzySearchByHandle(ctx context.Context, query string, limit int) ([]*models.Group, error)\n\n\tAddMember(ctx context.Context, member *models.GroupMember) error\n\tRemoveMember(ctx context.Context, groupID, userID uuid.UUID) error\n\tFindMember(ctx context.Context, groupID, userID uuid.UUID) (*models.GroupMember, error)\n\tListMembers(ctx context.Context, groupID uuid.UUID) ([]*models.User, error)\n\tGetOldestMember(ctx context.Context, groupID uuid.UUID) (*models.User, error)\n}\n",
  "backend/repository/session_repository.go": "package repository\n\nimport (\n\t\"chat-app/backend/models\"\n\t\"context\"\n\n\t\"github.com/google/uuid\"\n)\n\ntype SessionRepository interface {\n\tCreate(ctx context.Context, session *models.Session) error\n\tFind(ctx context.Context, refreshToken uuid.UUID) (*models.Session, error)\n\tDelete(ctx context.Context, refreshToken uuid.UUID) error\n\tDeleteByUserID(ctx context.Context, userID uuid.UUID) error\n}\n",
  "backend/repository/user_repository.go": "package repository\n\nimport (\n\t\"chat-app/backend/models\"\n\t\"context\"\n\n\t\"github.com/google/uuid\"\n)\n\ntype UserRepository interface {\n\tCreate(ctx context.Context, user *models.User) error\n\tFindByUsername(ctx context.Context, username string) (*models.User, error)\n\tFindByID(ctx context.Context, id uuid.UUID) (*models.User, error)\n\tUpdate(ctx context.Context, user *models.User) error\n}\n",
  "backend/usecase/auth_usecase.go": "package usecase\n\nimport (\n\t\"chat-app/backend/adapter/util\"\n\t\"chat-app/backend/models\"\n\t\"chat-app/backend/repository\"\n\t\"context\"\n\t\"errors\"\n\t\"time\"\n\n\t\"github.com/google/uuid\"\n)\n\ntype AuthUsecase interface {\n\tLogin(ctx context.Context, username, password string) (accessToken string, refreshToken string, err error)\n\tRefresh(ctx context.Context, refreshToken string) (newAccessToken string, err error)\n\tLogout(ctx context.Context, refreshToken string) error\n}\n\ntype authUsecase struct {\n\tuserRepo    repository.UserRepository\n\tsessionRepo repository.SessionRepository\n\ttokenGen    util.TokenGenerator\n}\n\nfunc NewAuthUsecase(userRepo repository.UserRepository, sessionRepo repository.SessionRepository, tokenGen util.TokenGenerator) AuthUsecase {\n\treturn \u0026authUsecase{\n\t\tuserRepo:    userRepo,\n\t\tsessionRepo: sessionRepo,\n\t\ttokenGen:    tokenGen,\n\t}\n}\n\nfunc (a *authUsecase) Login(ctx context.Context, username, password string) (string, string, error) {\n\tuser, err := a.userRepo.FindByUsername(ctx, username)\n\tif err != nil {\n\t\tif errors.Is(err, models.ErrUserNotFound) {\n\t\t\treturn \"\", \"\", models.ErrInvalidCredentials\n\t\t}\n\t\treturn \"\", \"\", err\n\t}\n\n\tif !util.CheckPasswordHash(password, user.PasswordHash) {\n\t\treturn \"\", \"\", models.ErrInvalidCredentials\n\t}\n\n\t// Single device policy: remove old sessions\n\tif err := a.sessionRepo.DeleteByUserID(ctx, user.ID); err != nil {\n\t\t// Log error but continue, as this is not critical for login\n\t\t// log.Printf(\"failed to delete old sessions for user %s: %v\", user.ID, err)\n\t}\n\n\taccessToken, err := a.tokenGen.GenerateAccessToken(user.ID)\n\tif err != nil {\n\t\treturn \"\", \"\", err\n\t}\n\n\trefreshToken, expiresAt, err := a.tokenGen.GenerateRefreshToken()\n\tif err != nil {\n\t\treturn \"\", \"\", err\n\t}\n\n\tsession := \u0026models.Session{\n\t\tRefreshToken: refreshToken,\n\t\tUserID:       user.ID,\n\t\tExpiresAt:    expiresAt,\n\t}\n\n\tif err := a.sessionRepo.Create(ctx, session); err != nil {\n\t\treturn \"\", \"\", err\n\t}\n\n\treturn accessToken, refreshToken.String(), nil\n}\n\nfunc (a *authUsecase) Refresh(ctx context.Context, refreshTokenStr string) (string, error) {\n\trefreshToken, err := uuid.Parse(refreshTokenStr)\n\tif err != nil {\n\t\treturn \"\", models.ErrInvalidToken\n\t}\n\n\tsession, err := a.sessionRepo.Find(ctx, refreshToken)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\tif session.ExpiresAt.Before(time.Now()) {\n\t\t// Clean up expired session\n\t\t_ = a.sessionRepo.Delete(ctx, refreshToken)\n\t\treturn \"\", models.ErrSessionNotFound\n\t}\n\n\t// Sliding window: extend session expiry\n\tsession.ExpiresAt = time.Now().Add(a.tokenGen.GetRefreshTokenExp())\n\tif err := a.sessionRepo.Create(ctx, session); err != nil { // Create will UPSERT\n\t\treturn \"\", err\n\t}\n\n\tnewAccessToken, err := a.tokenGen.GenerateAccessToken(session.UserID)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\treturn newAccessToken, nil\n}\n\nfunc (a *authUsecase) Logout(ctx context.Context, refreshTokenStr string) error {\n\trefreshToken, err := uuid.Parse(refreshTokenStr)\n\tif err != nil {\n\t\treturn models.ErrInvalidToken\n\t}\n\treturn a.sessionRepo.Delete(ctx, refreshToken)\n}\n",
  "backend/usecase/event_usecase.go": "package usecase\n\nimport (\n\t\"context\"\n\t\"time\"\n\n\t\"chat-app/models\"\n\t\"chat-app/repository\"\n\n\t\"github.com/google/uuid\"\n)\n\ntype EventUsecase interface {\n\tStoreEvent(ctx context.Context, event *models.Event) error\n\tGetUndeliveredEvents(ctx context.Context, userID uuid.UUID, cursor time.Time, limit int) ([]*models.Event, error)\n\tMarkEventAsDelivered(ctx context.Context, eventID uuid.UUID) error\n}\n\ntype eventUsecase struct {\n\tredisRepo repository.EventRepository\n\tdbRepo    repository.EventRepository\n}\n\nfunc NewEventUsecase(redisRepo, dbRepo repository.EventRepository) EventUsecase {\n\treturn \u0026eventUsecase{\n\t\tredisRepo: redisRepo,\n\t\tdbRepo:    dbRepo,\n\t}\n}\n\nfunc (u *eventUsecase) StoreEvent(ctx context.Context, event *models.Event) error {\n\t// All events are buffered in Redis first\n\treturn u.redisRepo.BufferEvent(ctx, event)\n}\n\nfunc (u *eventUsecase) GetUndeliveredEvents(ctx context.Context, userID uuid.UUID, cursor time.Time, limit int) ([]*models.Event, error) {\n\t// Fetch from durable storage (Postgres)\n\treturn u.dbRepo.FetchUndelivered(ctx, userID, cursor, limit)\n}\n\nfunc (u *eventUsecase) MarkEventAsDelivered(ctx context.Context, eventID uuid.UUID) error {\n\t// Once delivered, remove from durable storage\n\treturn u.dbRepo.Delete(ctx, eventID)\n}\n",
  "backend/usecase/friend_usecase.go": "package usecase\n\nimport (\n\t\"context\"\n\t\"encoding/json\"\n\t\"time\"\n\n\t\"chat-app/models\"\n\t\"chat-app/repository\"\n\n\t\"github.com/google/uuid\"\n)\n\ntype FriendUsecase interface {\n\tSendRequest(ctx context.Context, fromUserID uuid.UUID, toUsername string) error\n\tAcceptRequest(ctx context.Context, userID, requesterID uuid.UUID) error\n\tRejectRequest(ctx context.Context, userID, requesterID uuid.UUID) error\n\tUnfriend(ctx context.Context, userID, friendID uuid.UUID) error\n\tListFriends(ctx context.Context, userID uuid.UUID) ([]*models.User, error)\n\tListPendingRequests(ctx context.Context, userID uuid.UUID) ([]*models.User, error)\n}\n\ntype friendUsecase struct {\n\tuserRepo     repository.UserRepository\n\tfriendRepo   repository.FriendshipRepository\n\teventUsecase EventUsecase\n}\n\nfunc NewFriendUsecase(userRepo repository.UserRepository, friendRepo repository.FriendshipRepository, eventUsecase EventUsecase) FriendUsecase {\n\treturn \u0026friendUsecase{\n\t\tuserRepo:     userRepo,\n\t\tfriendRepo:   friendRepo,\n\t\teventUsecase: eventUsecase,\n\t}\n}\n\nfunc (u *friendUsecase) SendRequest(ctx context.Context, fromUserID uuid.UUID, toUsername string) error {\n\tif fromUserID.String() == toUsername {\n\t\treturn models.ErrCannotFriendSelf\n\t}\n\n\ttoUser, err := u.userRepo.FindByUsername(ctx, toUsername)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif fromUserID == toUser.ID {\n\t\treturn models.ErrCannotFriendSelf\n\t}\n\n\t// Check if a friendship or request already exists\n\t_, err = u.friendRepo.Find(ctx, fromUserID, toUser.ID)\n\tif err == nil {\n\t\treturn models.ErrFriendRequestExists\n\t} else if err != models.ErrFriendRequestNotFound {\n\t\treturn err\n\t}\n\n\t// Create friendship request\n\tfriendship := \u0026models.Friendship{\n\t\tUserID1:   fromUserID,\n\t\tUserID2:   toUser.ID,\n\t\tStatus:    models.FriendshipStatusPending,\n\t\tCreatedAt: time.Now(),\n\t}\n\tif err := u.friendRepo.Create(ctx, friendship); err != nil {\n\t\treturn err\n\t}\n\n\t// Create and store event for the recipient\n\tfromUser, err := u.userRepo.FindByID(ctx, fromUserID)\n\tif err != nil {\n\t\treturn err // Should not happen if fromUserID is from a valid token\n\t}\n\n\tpayload, _ := json.Marshal(fromUser)\n\tevent := \u0026models.Event{\n\t\tID:          uuid.New(),\n\t\tType:        models.EventFriendRequestReceived,\n\t\tPayload:     payload,\n\t\tRecipientID: toUser.ID,\n\t\tSenderID:    \u0026fromUserID,\n\t\tCreatedAt:   time.Now().UTC(),\n\t}\n\n\treturn u.eventUsecase.StoreEvent(ctx, event)\n}\n\nfunc (u *friendUsecase) AcceptRequest(ctx context.Context, userID, requesterID uuid.UUID) error {\n\t// Ensure a pending request exists from requesterID to userID\n\tfs, err := u.friendRepo.Find(ctx, requesterID, userID)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif fs.Status != models.FriendshipStatusPending {\n\t\treturn models.ErrFriendRequestNotFound\n\t}\n\n\tif err := u.friendRepo.UpdateStatus(ctx, requesterID, userID, models.FriendshipStatusAccepted); err != nil {\n\t\treturn err\n\t}\n\n\t// Create and store event for the original requester\n\tuser, err := u.userRepo.FindByID(ctx, userID)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tpayload, _ := json.Marshal(user)\n\tevent := \u0026models.Event{\n\t\tID:          uuid.New(),\n\t\tType:        models.EventFriendRequestAccepted,\n\t\tPayload:     payload,\n\t\tRecipientID: requesterID,\n\t\tSenderID:    \u0026userID,\n\t\tCreatedAt:   time.Now().UTC(),\n\t}\n\n\treturn u.eventUsecase.StoreEvent(ctx, event)\n}\n\nfunc (u *friendUsecase) RejectRequest(ctx context.Context, userID, requesterID uuid.UUID) error {\n\t// Ensure a pending request exists from requesterID to userID\n\tfs, err := u.friendRepo.Find(ctx, requesterID, userID)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif fs.Status != models.FriendshipStatusPending {\n\t\treturn models.ErrFriendRequestNotFound\n\t}\n\n\tif err := u.friendRepo.Delete(ctx, requesterID, userID); err != nil {\n\t\treturn err\n\t}\n\n\t// Create and store event for the original requester\n\tuser, err := u.userRepo.FindByID(ctx, userID)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tpayload, _ := json.Marshal(map[string]string{\"username\": user.Username})\n\tevent := \u0026models.Event{\n\t\tID:          uuid.New(),\n\t\tType:        models.EventFriendRequestRejected,\n\t\tPayload:     payload,\n\t\tRecipientID: requesterID,\n\t\tSenderID:    \u0026userID,\n\t\tCreatedAt:   time.Now().UTC(),\n\t}\n\n\treturn u.eventUsecase.StoreEvent(ctx, event)\n}\n\nfunc (u *friendUsecase) Unfriend(ctx context.Context, userID, friendID uuid.UUID) error {\n\t// Ensure they are friends\n\tfs, err := u.friendRepo.Find(ctx, userID, friendID)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif fs.Status != models.FriendshipStatusAccepted {\n\t\treturn models.ErrNotFriends\n\t}\n\n\tif err := u.friendRepo.Delete(ctx, userID, friendID); err != nil {\n\t\treturn err\n\t}\n\n\t// Create and store event for the unfriended user\n\tuser, err := u.userRepo.FindByID(ctx, userID)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tpayload, _ := json.Marshal(map[string]string{\"username\": user.Username})\n\tevent := \u0026models.Event{\n\t\tID:          uuid.New(),\n\t\tType:        models.EventUnfriended,\n\t\tPayload:     payload,\n\t\tRecipientID: friendID,\n\t\tSenderID:    \u0026userID,\n\t\tCreatedAt:   time.Now().UTC(),\n\t}\n\n\treturn u.eventUsecase.StoreEvent(ctx, event)\n}\n\nfunc (u *friendUsecase) ListFriends(ctx context.Context, userID uuid.UUID) ([]*models.User, error) {\n\treturn u.friendRepo.ListByUserID(ctx, userID, models.FriendshipStatusAccepted)\n}\n\nfunc (u *friendUsecase) ListPendingRequests(ctx context.Context, userID uuid.UUID) ([]*models.User, error) {\n\treturn u.friendRepo.ListByUserID(ctx, userID, models.FriendshipStatusPending)\n}\n",
  "backend/usecase/group_usecase.go": "package usecase\n\nimport (\n\t\"context\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"mime/multipart\"\n\t\"time\"\n\n\t\"chat-app/backend/adapter/util\"\n\t\"chat-app/backend/models\"\n\t\"chat-app/backend/repository\"\n\n\t\"github.com/google/uuid\"\n)\n\ntype GroupUsecase interface {\n\tCreateGroup(ctx context.Context, ownerID uuid.UUID, handle, name string, photo multipart.File, photoHeader *multipart.FileHeader) (*models.Group, error)\n\tUpdateGroup(ctx context.Context, userID, groupID uuid.UUID, name *string, photo multipart.File, photoHeader *multipart.FileHeader) (*models.Group, error)\n\tJoinGroup(ctx context.Context, userID uuid.UUID, groupHandle string) error\n\tLeaveGroup(ctx context.Context, userID, groupID uuid.UUID) error\n\tAddMember(ctx context.Context, adderID uuid.UUID, newMemberUsername string, groupID uuid.UUID) error\n\tRemoveMember(ctx context.Context, ownerID, memberID, groupID uuid.UUID) error\n\tTransferOwnership(ctx context.Context, currentOwnerID, newOwnerID, groupID uuid.UUID) error\n\tSearchGroups(ctx context.Context, query string) ([]*models.Group, error)\n\tGetGroupDetails(ctx context.Context, groupID uuid.UUID) (*models.Group, error)\n\tListGroupMembers(ctx context.Context, groupID uuid.UUID) ([]*models.User, error)\n}\n\ntype groupUsecase struct {\n\tgroupRepo    repository.GroupRepository\n\tuserRepo     repository.UserRepository\n\tfriendRepo   repository.FriendshipRepository\n\tfileRepo     repository.FileRepository\n\teventUsecase EventUsecase\n}\n\nfunc NewGroupUsecase(groupRepo repository.GroupRepository, userRepo repository.UserRepository, friendRepo repository.FriendshipRepository, fileRepo repository.FileRepository, eventUsecase EventUsecase) GroupUsecase {\n\treturn \u0026groupUsecase{\n\t\tgroupRepo:    groupRepo,\n\t\tuserRepo:     userRepo,\n\t\tfriendRepo:   friendRepo,\n\t\tfileRepo:     fileRepo,\n\t\teventUsecase: eventUsecase,\n\t}\n}\n\nfunc (u *groupUsecase) CreateGroup(ctx context.Context, ownerID uuid.UUID, handle, name string, photo multipart.File, photoHeader *multipart.FileHeader) (*models.Group, error) {\n\tif err := util.ValidateGroupHandle(handle); err != nil {\n\t\treturn nil, err\n\t}\n\tif name == \"\" || len(name) \u003e 100 {\n\t\treturn nil, fmt.Errorf(\"group name must be between 1 and 100 characters: %w\", models.ErrBadRequest)\n\t}\n\n\tvar photoURL string\n\tif photo != nil \u0026\u0026 photoHeader != nil {\n\t\tif err := util.ValidateProfilePic(photoHeader); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\turl, err := u.fileRepo.Save(photo, photoHeader)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tphotoURL = url\n\t}\n\n\tgroup := \u0026models.Group{\n\t\tID:        uuid.New(),\n\t\tHandle:    handle,\n\t\tName:      name,\n\t\tPhotoURL:  photoURL,\n\t\tOwnerID:   ownerID,\n\t\tCreatedAt: time.Now(),\n\t}\n\n\tif err := u.groupRepo.Create(ctx, group); err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn group, nil\n}\n\nfunc (u *groupUsecase) UpdateGroup(ctx context.Context, userID, groupID uuid.UUID, name *string, photo multipart.File, photoHeader *multipart.FileHeader) (*models.Group, error) {\n\tgroup, err := u.groupRepo.FindByID(ctx, groupID)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tif group.OwnerID != userID {\n\t\treturn nil, models.ErrNotGroupOwner\n\t}\n\n\tif name != nil {\n\t\tif *name == \"\" || len(*name) \u003e 100 {\n\t\t\treturn nil, fmt.Errorf(\"group name must be between 1 and 100 characters: %w\", models.ErrBadRequest)\n\t\t}\n\t\tgroup.Name = *name\n\t}\n\n\tif photo != nil \u0026\u0026 photoHeader != nil {\n\t\tif err := util.ValidateProfilePic(photoHeader); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\turl, err := u.fileRepo.Save(photo, photoHeader)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tgroup.PhotoURL = url\n\t}\n\n\tif err := u.groupRepo.Update(ctx, group); err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn group, nil\n}\n\nfunc (u *groupUsecase) JoinGroup(ctx context.Context, userID uuid.UUID, groupHandle string) error {\n\tgroup, err := u.groupRepo.FindByHandle(ctx, groupHandle)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tmember := \u0026models.GroupMember{\n\t\tGroupID:  group.ID,\n\t\tUserID:   userID,\n\t\tJoinedAt: time.Now(),\n\t}\n\n\tif err := u.groupRepo.AddMember(ctx, member); err != nil {\n\t\treturn err\n\t}\n\n\t// Notify other group members\n\tgo u.notifyGroupMembers(context.Background(), group.ID, userID, models.EventUserJoinedGroup, map[string]interface{}{\n\t\t\"groupId\":   group.ID,\n\t\t\"groupName\": group.Name,\n\t\t\"userId\":    userID,\n\t})\n\n\treturn nil\n}\n\nfunc (u *groupUsecase) LeaveGroup(ctx context.Context, userID, groupID uuid.UUID) error {\n\tgroup, err := u.groupRepo.FindByID(ctx, groupID)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif _, err := u.groupRepo.FindMember(ctx, groupID, userID); err != nil {\n\t\treturn models.ErrNotGroupMember\n\t}\n\n\tmembers, err := u.groupRepo.ListMembers(ctx, groupID)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif err := u.groupRepo.RemoveMember(ctx, groupID, userID); err != nil {\n\t\treturn err\n\t}\n\n\t// Notify remaining members\n\tgo u.notifyGroupMembers(context.Background(), groupID, userID, models.EventUserLeftGroup, map[string]interface{}{\n\t\t\"groupId\":   groupID,\n\t\t\"groupName\": group.Name,\n\t\t\"userId\":    userID,\n\t})\n\n\t// Handle ownership transfer or group deletion\n\tif group.OwnerID == userID {\n\t\tif len(members) == 1 { // The owner was the last member\n\t\t\treturn u.groupRepo.Delete(ctx, groupID)\n\t\t}\n\n\t\toldestMember, err := u.groupRepo.GetOldestMember(ctx, groupID)\n\t\tif err != nil {\n\t\t\t// This case should be rare, but if it happens, delete the group\n\t\t\tu.groupRepo.Delete(ctx, groupID)\n\t\t\treturn err\n\t\t}\n\t\tgroup.OwnerID = oldestMember.ID\n\t\treturn u.groupRepo.Update(ctx, group)\n\t}\n\n\treturn nil\n}\n\nfunc (u *groupUsecase) AddMember(ctx context.Context, adderID uuid.UUID, newMemberUsername string, groupID uuid.UUID) error {\n\t// Check if adder is a member\n\tif _, err := u.groupRepo.FindMember(ctx, groupID, adderID); err != nil {\n\t\treturn models.ErrNotGroupMember\n\t}\n\n\tnewMember, err := u.userRepo.FindByUsername(ctx, newMemberUsername)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Check if they are friends\n\tfs, err := u.friendRepo.Find(ctx, adderID, newMember.ID)\n\tif err != nil || fs.Status != models.FriendshipStatusAccepted {\n\t\treturn models.ErrNotFriends\n\t}\n\n\tmember := \u0026models.GroupMember{\n\t\tGroupID:  groupID,\n\t\tUserID:   newMember.ID,\n\t\tJoinedAt: time.Now(),\n\t}\n\n\tif err := u.groupRepo.AddMember(ctx, member); err != nil {\n\t\treturn err\n\t}\n\n\tgroup, err := u.groupRepo.FindByID(ctx, groupID)\n\tif err != nil {\n\t\treturn err // Group should exist, but handle error just in case\n\t}\n\n\t// Notify the new member\n\tgo u.notifyUser(context.Background(), newMember.ID, adderID, models.EventAddedToGroup, map[string]interface{}{\n\t\t\"groupId\":   groupID,\n\t\t\"groupName\": group.Name,\n\t\t\"adderId\":   adderID,\n\t})\n\n\t// Notify other group members\n\tgo u.notifyGroupMembers(context.Background(), groupID, newMember.ID, models.EventUserJoinedGroup, map[string]interface{}{\n\t\t\"groupId\":   groupID,\n\t\t\"groupName\": group.Name,\n\t\t\"userId\":    newMember.ID,\n\t\t\"adderId\":   adderID,\n\t})\n\n\treturn nil\n}\n\nfunc (u *groupUsecase) RemoveMember(ctx context.Context, ownerID, memberID, groupID uuid.UUID) error {\n\tgroup, err := u.groupRepo.FindByID(ctx, groupID)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif group.OwnerID != ownerID {\n\t\treturn models.ErrNotGroupOwner\n\t}\n\n\tif ownerID == memberID {\n\t\treturn models.ErrCannotRemoveOwner\n\t}\n\n\tif err := u.groupRepo.RemoveMember(ctx, groupID, memberID); err != nil {\n\t\treturn err\n\t}\n\n\t// Notify the removed member\n\tgo u.notifyUser(context.Background(), memberID, ownerID, models.EventRemovedFromGroup, map[string]interface{}{\n\t\t\"groupId\":   groupID,\n\t\t\"groupName\": group.Name,\n\t\t\"removerId\": ownerID,\n\t})\n\n\t// Notify other group members\n\tgo u.notifyGroupMembers(context.Background(), groupID, memberID, models.EventUserLeftGroup, map[string]interface{}{\n\t\t\"groupId\":   groupID,\n\t\t\"groupName\": group.Name,\n\t\t\"userId\":    memberID,\n\t\t\"removerId\": ownerID,\n\t})\n\n\treturn nil\n}\n\nfunc (u *groupUsecase) TransferOwnership(ctx context.Context, currentOwnerID, newOwnerID, groupID uuid.UUID) error {\n\tgroup, err := u.groupRepo.FindByID(ctx, groupID)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif group.OwnerID != currentOwnerID {\n\t\treturn models.ErrNotGroupOwner\n\t}\n\n\tif _, err := u.groupRepo.FindMember(ctx, groupID, newOwnerID); err != nil {\n\t\treturn models.ErrNotGroupMember\n\t}\n\n\tgroup.OwnerID = newOwnerID\n\treturn u.groupRepo.Update(ctx, group)\n}\n\nfunc (u *groupUsecase) SearchGroups(ctx context.Context, query string) ([]*models.Group, error) {\n\treturn u.groupRepo.FuzzySearchByHandle(ctx, query, 10)\n}\n\nfunc (u *groupUsecase) GetGroupDetails(ctx context.Context, groupID uuid.UUID) (*models.Group, error) {\n\treturn u.groupRepo.FindByID(ctx, groupID)\n}\n\nfunc (u *groupUsecase) ListGroupMembers(ctx context.Context, groupID uuid.UUID) ([]*models.User, error) {\n\treturn u.groupRepo.ListMembers(ctx, groupID)\n}\n\nfunc (u *groupUsecase) notifyGroupMembers(ctx context.Context, groupID, subjectUserID uuid.UUID, eventType models.EventType, payload map[string]interface{}) {\n\tmembers, err := u.groupRepo.ListMembers(ctx, groupID)\n\tif err != nil {\n\t\treturn\n\t}\n\n\tjsonPayload, _ := json.Marshal(payload)\n\n\tfor _, member := range members {\n\t\tif member.ID == subjectUserID {\n\t\t\tcontinue\n\t\t}\n\t\tevent := \u0026models.Event{\n\t\t\tID:          uuid.New(),\n\t\t\tType:        eventType,\n\t\t\tPayload:     jsonPayload,\n\t\t\tRecipientID: member.ID,\n\t\t\tCreatedAt:   time.Now(),\n\t\t}\n\t\tu.eventUsecase.StoreEvent(ctx, event)\n\t}\n}\n\nfunc (u *groupUsecase) notifyUser(ctx context.Context, recipientID, senderID uuid.UUID, eventType models.EventType, payload map[string]interface{}) {\n\tjsonPayload, _ := json.Marshal(payload)\n\tevent := \u0026models.Event{\n\t\tID:          uuid.New(),\n\t\tType:        eventType,\n\t\tPayload:     jsonPayload,\n\t\tRecipientID: recipientID,\n\t\tSenderID:    \u0026senderID,\n\t\tCreatedAt:   time.Now(),\n\t}\n\tu.eventUsecase.StoreEvent(ctx, event)\n}\n",
  "backend/usecase/user_usecase.go": "package usecase\n\nimport (\n\t\"chat-app/backend/adapter/util\"\n\t\"chat-app/backend/models\"\n\t\"chat-app/backend/repository\"\n\t\"context\"\n\t\"errors\"\n\t\"mime/multipart\"\n\t\"strings\"\n\n\t\"github.com/google/uuid\"\n)\n\ntype UserUsecase interface {\n\tRegister(ctx context.Context, username, password string) (*models.User, error)\n\tGetByUsername(ctx context.Context, username string) (*models.User, error)\n\tUpdateProfile(ctx context.Context, userID uuid.UUID, username, password *string, profilePic multipart.File, profilePicHeader *multipart.FileHeader) (*models.User, error)\n}\n\ntype userUsecase struct {\n\tuserRepo repository.UserRepository\n\tfileRepo repository.FileRepository\n}\n\nfunc NewUserUsecase(userRepo repository.UserRepository, fileRepo repository.FileRepository) UserUsecase {\n\treturn \u0026userUsecase{\n\t\tuserRepo: userRepo,\n\t\tfileRepo: fileRepo,\n\t}\n}\n\nfunc (u *userUsecase) Register(ctx context.Context, username, password string) (*models.User, error) {\n\tif err := util.ValidateUsername(username); err != nil {\n\t\treturn nil, err\n\t}\n\tif err := util.ValidatePassword(password); err != nil {\n\t\treturn nil, err\n\t}\n\n\texistingUser, err := u.userRepo.FindByUsername(ctx, username)\n\tif err != nil \u0026\u0026 !errors.Is(err, models.ErrUserNotFound) {\n\t\treturn nil, err\n\t}\n\tif existingUser != nil {\n\t\treturn nil, models.ErrUsernameTaken\n\t}\n\n\thashedPassword, err := util.HashPassword(password)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tuser := \u0026models.User{\n\t\tID:           uuid.New(),\n\t\tUsername:     strings.ToLower(username),\n\t\tPasswordHash: hashedPassword,\n\t}\n\n\tif err := u.userRepo.Create(ctx, user); err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn user, nil\n}\n\nfunc (u *userUsecase) GetByUsername(ctx context.Context, username string) (*models.User, error) {\n\treturn u.userRepo.FindByUsername(ctx, username)\n}\n\nfunc (u *userUsecase) UpdateProfile(ctx context.Context, userID uuid.UUID, username, password *string, profilePic multipart.File, profilePicHeader *multipart.FileHeader) (*models.User, error) {\n\tuser, err := u.userRepo.FindByID(ctx, userID)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tif username != nil {\n\t\tif err := util.ValidateUsername(*username); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\t// Check if new username is taken by another user\n\t\texistingUser, err := u.userRepo.FindByUsername(ctx, *username)\n\t\tif err != nil \u0026\u0026 !errors.Is(err, models.ErrUserNotFound) {\n\t\t\treturn nil, err\n\t\t}\n\t\tif existingUser != nil \u0026\u0026 existingUser.ID != userID {\n\t\t\treturn nil, models.ErrUsernameTaken\n\t\t}\n\t\tuser.Username = strings.ToLower(*username)\n\t}\n\n\tif password != nil {\n\t\tif err := util.ValidatePassword(*password); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\thashedPassword, err := util.HashPassword(*password)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tuser.PasswordHash = hashedPassword\n\t}\n\n\tif profilePic != nil {\n\t\tif err := util.ValidateProfilePic(profilePicHeader); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tpicURL, err := u.fileRepo.Save(profilePic, profilePicHeader)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tuser.ProfilePicURL = picURL\n\t}\n\n\tif err := u.userRepo.Update(ctx, user); err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn user, nil\n}\n",
  "docker-compose.yml": "version: '3.8'\n\nservices:\n  postgres:\n    image: postgres:13\n    container_name: quikchat_postgres\n    environment:\n      POSTGRES_USER: ${DB_USER:-user}\n      POSTGRES_PASSWORD: ${DB_PASSWORD:-password}\n      POSTGRES_DB: ${DB_NAME:-quikchat}\n    ports:\n      - \"${DB_PORT:-5432}:5432\"\n    volumes:\n      - postgres_data:/var/lib/postgresql/data\n      - ./backend/adapter/postgres/migrations:/docker-entrypoint-initdb.d\n    restart: unless-stopped\n    healthcheck:\n      test: [\"CMD-SHELL\", \"pg_isready -U ${DB_USER:-user} -d ${DB_NAME:-quikchat}\"]\n      interval: 10s\n      timeout: 5s\n      retries: 5\n\n  redis:\n    image: redis:6.2-alpine\n    container_name: quikchat_redis\n    ports:\n      - \"6379:6379\"\n    restart: unless-stopped\n    command: redis-server --requirepass ${REDIS_PASSWORD:-}\n    healthcheck:\n      test: [\"CMD\", \"redis-cli\", \"ping\"]\n      interval: 10s\n      timeout: 5s\n      retries: 5\n\nvolumes:\n  postgres_data:",
  "tailwind.config.js": "/** @type {import('tailwindcss').Config} */\nmodule.exports = {\n  content: [\n    './web/templates/**/*.html',\n    './web/static/js/**/*.js',\n  ],\n  theme: {\n    extend: {\n        colors: {\n            'primary': '#1e293b',    // slate-800\n            'secondary': '#334155', // slate-700\n            'accent': '#475569',    // slate-600\n            'text-main': '#f8fafc', // slate-50\n            'text-dim': '#94a3b8',  // slate-400\n            'highlight': '#2dd4bf', // teal-400\n        }\n    },\n  },\n  plugins: [],\n}\n",
  "web/static/css/input.css": "@tailwind base;\n@tailwind components;\n@tailwind utilities;\n",
  "web/static/css/style.css": "/* This file would be generated by the Tailwind CSS build process. */\n/* For this project, a pre-compiled version with basic styles is assumed. */\n/* A full build would be several megabytes, so this is a placeholder. */\n@tailwind base;\n@tailwind components;\n@tailwind utilities;\n\n.chat-scrollbar::-webkit-scrollbar {\n    width: 8px;\n}\n.chat-scrollbar::-webkit-scrollbar-track {\n    background: #334155; /* secondary */\n}\n.chat-scrollbar::-webkit-scrollbar-thumb {\n    background: #475569; /* accent */\n    border-radius: 4px;\n}\n.chat-scrollbar::-webkit-scrollbar-thumb:hover {\n    background: #64748b; /* slate-500 */\n}\n\n",
  "web/static/js/api.js": "import { getState, setState } from './state.js';\n\nconst BASE_URL = '/api/v1';\n\nasync function request(endpoint, options = {}) {\n    const { accessToken } = getState();\n    const headers = {\n        'Content-Type': 'application/json',\n        ...options.headers,\n    };\n\n    if (accessToken) {\n        headers['Authorization'] = `Bearer ${accessToken}`;\n    }\n\n    const config = {\n        ...options,\n        headers,\n    };\n\n    const response = await fetch(`${BASE_URL}${endpoint}`, config);\n\n    if (!response.ok) {\n        const errorData = await response.json().catch(() =\u003e ({ message: 'An unknown error occurred' }));\n        throw new Error(errorData.message || `HTTP error! status: ${response.status}`);\n    }\n\n    if (response.status === 204) { // No Content\n        return null;\n    }\n\n    return response.json();\n}\n\nexport const api = {\n    login: (username, password) =\u003e request('/login', {\n        method: 'POST',\n        body: JSON.stringify({ username, password }),\n    }),\n    register: (username, password) =\u003e request('/register', {\n        method: 'POST',\n        body: JSON.stringify({ username, password }),\n    }),\n    logout: (refreshToken) =\u003e request('/logout', {\n        method: 'POST',\n        body: JSON.stringify({ refreshToken }),\n    }),\n    getFriends: () =\u003e request('/friends'),\n    getGroups: () =\u003e {\n        // This endpoint doesn't exist, so we'll mock it for now.\n        // In a real app, you'd fetch groups the user is a member of.\n        console.warn(\"API call to getGroups is mocked.\");\n        return Promise.resolve([]); \n    },\n    getMessages: (chatId) =\u003e {\n        // This endpoint doesn't exist. Messages are received via WebSocket.\n        // A real app would have an endpoint to fetch message history.\n        console.warn(\"API call to getMessages is mocked.\");\n        return Promise.resolve([]);\n    },\n};\n",
  "web/static/js/main.js": "import { api } from './api.js';\nimport { getState, setState } from './state.js';\nimport { ui } from './ui.js';\nimport { ws } from './ws.js';\n\nconst loginForm = document.getElementById('login-form');\nconst registerForm = document.getElementById('register-form');\nconst messageForm = document.getElementById('message-form');\nconst logoutBtn = document.getElementById('logout-btn');\nconst loginTabBtn = document.getElementById('login-tab-btn');\nconst registerTabBtn = document.getElementById('register-tab-btn');\n\nasync function handleLogin(e) {\n    e.preventDefault();\n    const button = e.target.querySelector('button');\n    ui.toggleButton(button, true);\n    try {\n        const formData = new FormData(e.target);\n        const { username, password } = Object.fromEntries(formData.entries());\n        const { accessToken, refreshToken } = await api.login(username, password);\n        setState({ accessToken, refreshToken });\n        await initializeApp();\n    } catch (error) {\n        ui.showAuthError(error.message);\n    } finally {\n        ui.toggleButton(button, false);\n    }\n}\n\nasync function handleRegister(e) {\n    e.preventDefault();\n    const button = e.target.querySelector('button');\n    ui.toggleButton(button, true);\n    try {\n        const formData = new FormData(e.target);\n        const { username, password } = Object.fromEntries(formData.entries());\n        await api.register(username, password);\n        alert('Registration successful! Please log in.');\n        e.target.reset();\n        ui.switchAuthTab('login');\n    } catch (error) {\n        ui.showAuthError(error.message);\n    } finally {\n        ui.toggleButton(button, false);\n    }\n}\n\nasync function handleLogout() {\n    try {\n        const { refreshToken } = getState();\n        if (refreshToken) {\n            await api.logout(refreshToken);\n        }\n    } catch (error) {\n        console.error('Logout failed:', error);\n    } finally {\n        ws.disconnect();\n        setState({\n            currentUser: null,\n            accessToken: null,\n            refreshToken: null,\n            friends: [],\n            groups: [],\n            activeChat: null,\n        });\n        ui.showView('auth');\n    }\n}\n\nfunction handleSendMessage(e) {\n    e.preventDefault();\n    const { activeChat } = getState();\n    const input = e.target.elements.message;\n    const content = input.value.trim();\n\n    if (content \u0026\u0026 activeChat) {\n        const payload = {\n            content,\n            recipientId: activeChat.id,\n        };\n        ws.sendMessage({ type: 'message_sent', payload });\n        ui.clearMessageInput();\n    }\n}\n\nfunction setupWsListeners() {\n    ws.onEvent('message_sent', (message) =\u003e {\n        const { currentUser, activeChat } = getState();\n        if (\n            activeChat \u0026\u0026\n            (message.recipientId === activeChat.id || message.senderId === activeChat.id)\n        ) {\n            ui.renderMessage(message, message.senderId === currentUser.id);\n        }\n        // TODO: Add notification for inactive chats\n    });\n\n    ws.onEvent('message_ack', (payload) =\u003e {\n        console.log('Message acknowledged:', payload.messageId);\n        // Can be used to update message status to \"sent\"\n    });\n}\n\nasync function initializeApp() {\n    ui.showView('chat');\n    const { accessToken } = getState();\n\n    try {\n        // Mock current user from token until we have a /me endpoint\n        const tokenPayload = JSON.parse(atob(accessToken.split('.')[1]));\n        const currentUser = { id: tokenPayload.user_id, username: 'You' }; // Username is a placeholder\n        setState({ currentUser });\n\n        ui.renderUserProfile(currentUser);\n\n        ws.connect(accessToken);\n        setupWsListeners();\n\n        const friends = await api.getFriends();\n        setState({ friends });\n        ui.renderFriendList(friends);\n\n        const groups = await api.getGroups();\n        setState({ groups });\n        ui.renderGroupList(groups);\n    } catch (error) {\n        console.error('Initialization failed:', error);\n        await handleLogout();\n    }\n}\n\n// Event Listeners\nloginForm.addEventListener('submit', handleLogin);\nregisterForm.addEventListener('submit', handleRegister);\nmessageForm.addEventListener('submit', handleSendMessage);\nlogoutBtn.addEventListener('click', handleLogout);\nloginTabBtn.addEventListener('click', () =\u003e ui.switchAuthTab('login'));\nregisterTabBtn.addEventListener('click', () =\u003e ui.switchAuthTab('register'));\n\n// Initial check (e.g., for a stored refresh token) could go here\n// For now, we start at the auth view.\nui.showView('auth');\n",
  "web/static/js/state.js": "/** @type {import('./types.js').AppState} */\nlet state = {\n    currentUser: null,\n    accessToken: null,\n    refreshToken: null,\n    friends: [],\n    groups: [],\n    activeChat: null,\n};\n\n/** @returns {import('./types.js').AppState} */\nexport function getState() {\n    return { ...state };\n}\n\n/** @param {Partial\u003cimport('./types.js').AppState\u003e} newState */\nexport function setState(newState) {\n    state = { ...state, ...newState };\n}\n",
  "web/static/js/templates.js": "/**\n * @param {import('./types.js').User} user\n */\nexport const userProfileTemplate = (user) =\u003e `\n    \u003cdiv class=\"flex items-center space-x-4\"\u003e\n        \u003cimg src=\"${user.profilePicUrl || 'https://via.placeholder.com/40'}\" alt=\"Profile\" class=\"w-10 h-10 rounded-full\"\u003e\n        \u003cdiv\u003e\n            \u003ch3 class=\"font-bold\"\u003e${user.username}\u003c/h3\u003e\n            \u003cp class=\"text-sm text-text-dim\"\u003eOnline\u003c/p\u003e\n        \u003c/div\u003e\n    \u003c/div\u003e\n`;\n\n/**\n * @param {import('./types.js').User[]} friends\n */\nexport const friendListTemplate = (friends) =\u003e `\n    \u003ch4 class=\"mb-2 text-sm font-semibold tracking-wider uppercase text-text-dim\"\u003eFriends\u003c/h4\u003e\n    \u003cul\u003e\n        ${friends.map(friend =\u003e `\n            \u003cli data-id=\"${friend.id}\" data-username=\"${friend.username}\" class=\"flex items-center p-2 space-x-3 rounded-md cursor-pointer hover:bg-accent\"\u003e\n                \u003cimg src=\"${friend.profilePicUrl || 'https://via.placeholder.com/32'}\" alt=\"${friend.username}\" class=\"w-8 h-8 rounded-full\"\u003e\n                \u003cspan\u003e${friend.username}\u003c/span\u003e\n            \u003c/li\u003e\n        `).join('')}\n    \u003c/ul\u003e\n`;\n\n/**\n * @param {import('./types.js').Group[]} groups\n */\nexport const groupListTemplate = (groups) =\u003e `\n    \u003ch4 class=\"mt-4 mb-2 text-sm font-semibold tracking-wider uppercase text-text-dim\"\u003eGroups\u003c/h4\u003e\n    \u003cul\u003e\n        ${groups.map(group =\u003e `\n            \u003cli data-id=\"${group.id}\" data-name=\"${group.name}\" class=\"flex items-center p-2 space-x-3 rounded-md cursor-pointer hover:bg-accent\"\u003e\n                \u003cimg src=\"${group.photoUrl || 'https://via.placeholder.com/32'}\" alt=\"${group.name}\" class=\"w-8 h-8 rounded-full\"\u003e\n                \u003cspan\u003e${group.name}\u003c/span\u003e\n            \u003c/li\u003e\n        `).join('')}\n    \u003c/ul\u003e\n`;\n\n/**\n * @param {import('./types.js').Message} message\n * @param {boolean} isOwnMessage\n */\nexport const messageTemplate = (message, isOwnMessage) =\u003e `\n    \u003cdiv class=\"flex ${isOwnMessage ? 'justify-end' : 'justify-start'} mb-4\"\u003e\n        \u003cdiv class=\"max-w-xs px-4 py-2 rounded-lg ${isOwnMessage ? 'bg-highlight text-primary' : 'bg-accent'}\"\u003e\n            \u003cp class=\"text-sm\"\u003e${message.content}\u003c/p\u003e\n            \u003cp class=\"mt-1 text-xs text-right ${isOwnMessage ? 'text-teal-900' : 'text-text-dim'}\"\u003e${new Date(message.timestamp).toLocaleTimeString()}\u003c/p\u003e\n        \u003c/div\u003e\n    \u003c/div\u003e\n`;\n",
  "web/static/js/types.js": "/**\n * @typedef {object} User\n * @property {string} id\n * @property {string} username\n * @property {string} profilePicUrl\n */\n\n/**\n * @typedef {object} Group\n * @property {string} id\n * @property {string} name\n * @property {string} handle\n * @property {string} photoUrl\n */\n\n/**\n * @typedef {object} Message\n * @property {string} id\n * @property {string} content\n * @property {string} senderId\n * @property {string} recipientId\n * @property {string} timestamp\n */\n\n/**\n * @typedef {object} ActiveChat\n * @property {string} id\n * @property {string} name\n * @property {'user' | 'group'} type\n */\n\n/**\n * @typedef {object} AppState\n * @property {User | null} currentUser\n * @property {string | null} accessToken\n * @property {string | null} refreshToken\n * @property {User[]} friends\n * @property {Group[]} groups\n * @property {ActiveChat | null} activeChat\n */\n\n export default {};\n",
  "web/static/js/ui.js": "import { setState } from './state.js';\nimport {\n    userProfileTemplate,\n    friendListTemplate,\n    groupListTemplate,\n    messageTemplate,\n} from './templates.js';\n\n// DOM Elements\nconst authView = document.getElementById('auth-view');\nconst chatView = document.getElementById('chat-view');\nconst authError = document.getElementById('auth-error');\nconst loginForm = document.getElementById('login-form');\nconst registerForm = document.getElementById('register-form');\nconst loginTabBtn = document.getElementById('login-tab-btn');\nconst registerTabBtn = document.getElementById('register-tab-btn');\n\nconst userProfileContainer = document.getElementById('user-profile-container');\nconst friendsListContainer = document.getElementById('friends-list-container');\nconst groupsListContainer = document.getElementById('groups-list-container');\n\nconst messagesContainer = document.getElementById('messages-container');\nconst chatTitle = document.getElementById('chat-title');\nconst messageInput = document.getElementById('message-input');\nconst messageForm = document.getElementById('message-form');\nconst messageFormBtn = messageForm.querySelector('button');\n\n/** @param {import('./types.js').ActiveChat} chat */\nfunction setActiveChat(chat) {\n    setState({ activeChat: chat });\n    chatTitle.textContent = chat.name;\n    messagesContainer.innerHTML = ''; // Clear previous messages\n    messageInput.disabled = false;\n    messageFormBtn.disabled = false;\n    messageInput.focus();\n    // TODO: Fetch message history for this chat\n}\n\nexport const ui = {\n    /** @param {'auth' | 'chat'} view */\n    showView(view) {\n        authView.classList.toggle('hidden', view === 'chat');\n        chatView.classList.toggle('hidden', view === 'auth');\n    },\n\n    /** @param {string} message */\n    showAuthError(message) {\n        authError.textContent = message;\n        authError.classList.toggle('hidden', !message);\n    },\n\n    /** @param {'login' | 'register'} tab */\n    switchAuthTab(tab) {\n        const isLogin = tab === 'login';\n        loginForm.classList.toggle('hidden', !isLogin);\n        registerForm.classList.toggle('hidden', isLogin);\n\n        loginTabBtn.classList.toggle('border-accent', isLogin);\n        loginTabBtn.classList.toggle('text-white', isLogin);\n        loginTabBtn.classList.toggle('border-transparent', !isLogin);\n        loginTabBtn.classList.toggle('text-text-dim', !isLogin);\n\n        registerTabBtn.classList.toggle('border-accent', !isLogin);\n        registerTabBtn.classList.toggle('text-white', !isLogin);\n        registerTabBtn.classList.toggle('border-transparent', isLogin);\n        registerTabBtn.classList.toggle('text-text-dim', isLogin);\n\n        ui.showAuthError(''); // Clear error on tab switch\n    },\n\n    /**\n     * @param {HTMLButtonElement} button\n     * @param {boolean} disabled\n     */\n    toggleButton(button, disabled) {\n        if (button) {\n            button.disabled = disabled;\n            button.classList.toggle('opacity-50', disabled);\n            button.classList.toggle('cursor-not-allowed', disabled);\n        }\n    },\n\n    clearMessageInput() {\n        messageInput.value = '';\n    },\n\n    /** @param {import('./types.js').User} user */\n    renderUserProfile(user) {\n        userProfileContainer.innerHTML = userProfileTemplate(user);\n    },\n\n    /** @param {import('./types.js').User[]} friends */\n    renderFriendList(friends) {\n        friendsListContainer.innerHTML = friendListTemplate(friends);\n        friendsListContainer.querySelectorAll('li').forEach((item) =\u003e {\n            item.addEventListener('click', () =\u003e {\n                setActiveChat({\n                    id: item.dataset.id,\n                    name: item.dataset.username,\n                    type: 'user',\n                });\n            });\n        });\n    },\n\n    /** @param {import('./types.js').Group[]} groups */\n    renderGroupList(groups) {\n        groupsListContainer.innerHTML = groupListTemplate(groups);\n        groupsListContainer.querySelectorAll('li').forEach((item) =\u003e {\n            item.addEventListener('click', () =\u003e {\n                setActiveChat({\n                    id: item.dataset.id,\n                    name: item.dataset.name,\n                    type: 'group',\n                });\n            });\n        });\n    },\n\n    /**\n     * @param {import('./types.js').Message} message\n     * @param {boolean} isOwnMessage\n     */\n    renderMessage(message, isOwnMessage) {\n        const messageEl = document.createElement('div');\n        messageEl.innerHTML = messageTemplate(message, isOwnMessage);\n        messagesContainer.appendChild(messageEl);\n        messagesContainer.scrollTop = messagesContainer.scrollHeight;\n    },\n};",
  "web/static/js/ws.js": "let socket = null;\nconst eventListeners = new Map();\n\nconst handleMessage = (event) =\u003e {\n    try {\n        const data = JSON.parse(event.data);\n        if (data.type \u0026\u0026 eventListeners.has(data.type)) {\n            eventListeners.get(data.type).forEach(callback =\u003e callback(data.payload));\n        } else {\n            console.warn('Unhandled WebSocket event type:', data.type);\n        }\n    } catch (error) {\n        console.error('Error parsing WebSocket message:', error);\n    }\n};\n\nexport const ws = {\n    connect: (token) =\u003e {\n        if (socket \u0026\u0026 socket.readyState === WebSocket.OPEN) {\n            console.log('WebSocket is already connected.');\n            return;\n        }\n        const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';\n        const url = `${protocol}//${window.location.host}/api/v1/ws`;\n        \n        socket = new WebSocket(url);\n\n        socket.onopen = () =\u003e {\n            console.log('WebSocket connected.');\n            // Send auth token immediately after connection\n            socket.send(JSON.stringify({ type: 'auth', payload: { token } }));\n        };\n\n        socket.onmessage = handleMessage;\n\n        socket.onclose = () =\u003e {\n            console.log('WebSocket disconnected.');\n            socket = null;\n        };\n\n        socket.onerror = (error) =\u003e {\n            console.error('WebSocket error:', error);\n        };\n    },\n\n    disconnect: () =\u003e {\n        if (socket) {\n            socket.close();\n        }\n    },\n\n    sendMessage: (message) =\u003e {\n        if (socket \u0026\u0026 socket.readyState === WebSocket.OPEN) {\n            socket.send(JSON.stringify(message));\n        } else {\n            console.error('WebSocket is not connected.');\n        }\n    },\n\n    onEvent: (eventType, callback) =\u003e {\n        if (!eventListeners.has(eventType)) {\n            eventListeners.set(eventType, []);\n        }\n        eventListeners.get(eventType).push(callback);\n    },\n};\n",
  "web/templates/app.html": "\u003c!DOCTYPE html\u003e\n\u003chtml lang=\"en\" class=\"h-full bg-primary\"\u003e\n\u003chead\u003e\n    \u003cmeta charset=\"UTF-8\"\u003e\n    \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"\u003e\n    \u003ctitle\u003eQuikChat\u003c/title\u003e\n    \u003clink rel=\"stylesheet\" href=\"/static/css/style.css\"\u003e\n\u003c/head\u003e\n\u003cbody class=\"h-full text-text-main\"\u003e\n\n    \u003c!-- Auth View --\u003e\n    \u003cdiv id=\"auth-view\" class=\"flex items-center justify-center h-full\"\u003e\n        \u003cdiv class=\"w-full max-w-md p-8 space-y-8 bg-secondary rounded-lg shadow-lg\"\u003e\n            \u003cdiv\u003e\n                \u003ch2 class=\"text-3xl font-extrabold text-center text-highlight\"\u003eQuikChat\u003c/h2\u003e\n            \u003c/div\u003e\n            \u003c!-- Login / Register Tabs --\u003e\n            \u003cdiv class=\"flex border-b border-accent\"\u003e\n                \u003cbutton id=\"login-tab-btn\" class=\"flex-1 py-2 font-semibold text-highlight border-b-2 border-highlight\"\u003eLogin\u003c/button\u003e\n                \u003cbutton id=\"register-tab-btn\" class=\"flex-1 py-2 font-semibold text-text-dim\"\u003eRegister\u003c/button\u003e\n            \u003c/div\u003e\n\n            \u003c!-- Login Form --\u003e\n            \u003cform id=\"login-form\" class=\"mt-8 space-y-6\"\u003e\n                \u003cinput type=\"text\" id=\"login-username\" placeholder=\"Username\" required class=\"w-full px-3 py-2 bg-accent border border-transparent rounded-md focus:outline-none focus:ring-2 focus:ring-highlight\"\u003e\n                \u003cinput type=\"password\" id=\"login-password\" placeholder=\"Password\" required class=\"w-full px-3 py-2 bg-accent border border-transparent rounded-md focus:outline-none focus:ring-2 focus:ring-highlight\"\u003e\n                \u003cbutton type=\"submit\" class=\"w-full py-2 font-bold text-primary bg-highlight rounded-md hover:bg-teal-300\"\u003eSign In\u003c/button\u003e\n            \u003c/form\u003e\n\n            \u003c!-- Register Form --\u003e\n            \u003cform id=\"register-form\" class=\"hidden mt-8 space-y-6\"\u003e\n                \u003cinput type=\"text\" id=\"register-username\" placeholder=\"Username (a-z, 0-9, _)\" required class=\"w-full px-3 py-2 bg-accent border border-transparent rounded-md focus:outline-none focus:ring-2 focus:ring-highlight\"\u003e\n                \u003cinput type=\"password\" id=\"register-password\" placeholder=\"Password (min 8 chars)\" required class=\"w-full px-3 py-2 bg-accent border border-transparent rounded-md focus:outline-none focus:ring-2 focus:ring-highlight\"\u003e\n                \u003cbutton type=\"submit\" class=\"w-full py-2 font-bold text-primary bg-highlight rounded-md hover:bg-teal-300\"\u003eCreate Account\u003c/button\u003e\n            \u003c/form\u003e\n            \u003cp id=\"auth-error\" class=\"text-sm text-center text-red-400\"\u003e\u003c/p\u003e\n        \u003c/div\u003e\n    \u003c/div\u003e\n\n    \u003c!-- Chat View --\u003e\n    \u003cdiv id=\"chat-view\" class=\"hidden h-full\"\u003e\n        \u003cdiv class=\"flex h-full\"\u003e\n            \u003c!-- Sidebar --\u003e\n            \u003caside class=\"flex flex-col w-80 bg-secondary\"\u003e\n                \u003c!-- User Profile --\u003e\n                \u003cdiv id=\"user-profile-container\" class=\"p-4 border-b border-accent\"\u003e\u003c/div\u003e\n                \n                \u003c!-- Conversations --\u003e\n                \u003cdiv class=\"flex-1 overflow-y-auto chat-scrollbar\"\u003e\n                    \u003c!-- Friends List --\u003e\n                    \u003cdiv id=\"friends-list-container\" class=\"p-4\"\u003e\u003c/div\u003e\n                    \u003c!-- Groups List --\u003e\n                    \u003cdiv id=\"groups-list-container\" class=\"p-4\"\u003e\u003c/div\u003e\n                \u003c/div\u003e\n\n                \u003c!-- Actions --\u003e\n                \u003cdiv class=\"p-4 border-t border-accent\"\u003e\n                    \u003cbutton id=\"logout-btn\" class=\"w-full py-2 text-sm font-bold text-primary bg-highlight rounded-md hover:bg-teal-300\"\u003eLogout\u003c/button\u003e\n                \u003c/div\u003e\n            \u003c/aside\u003e\n\n            \u003c!-- Main Chat Area --\u003e\n            \u003cmain class=\"flex flex-col flex-1 bg-primary\"\u003e\n                \u003c!-- Chat Header --\u003e\n                \u003cheader id=\"chat-header\" class=\"flex items-center p-4 border-b shadow-md h-18 border-accent\"\u003e\n                    \u003ch2 id=\"chat-title\" class=\"text-xl font-bold\"\u003eSelect a conversation\u003c/h2\u003e\n                \u003c/header\u003e\n\n                \u003c!-- Messages --\u003e\n                \u003cdiv id=\"messages-container\" class=\"flex-1 p-4 overflow-y-auto chat-scrollbar\"\u003e\n                    \u003c!-- Messages will be rendered here --\u003e\n                \u003c/div\u003e\n\n                \u003c!-- Message Input --\u003e\n                \u003cfooter class=\"p-4\"\u003e\n                    \u003cform id=\"message-form\" class=\"flex items-center\"\u003e\n                        \u003cinput id=\"message-input\" type=\"text\" placeholder=\"Type a message...\" autocomplete=\"off\" class=\"w-full px-4 py-2 bg-accent rounded-l-md focus:outline-none focus:ring-2 focus:ring-highlight\" disabled\u003e\n                        \u003cbutton type=\"submit\" class=\"px-4 py-2 font-bold text-primary bg-highlight rounded-r-md hover:bg-teal-300\" disabled\u003eSend\u003c/button\u003e\n                    \u003c/form\u003e\n                \u003c/footer\u003e\n            \u003c/main\u003e\n        \u003c/div\u003e\n    \u003c/div\u003e\n\n    \u003cscript type=\"module\" src=\"/static/js/main.js\"\u003e\u003c/script\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n"
}