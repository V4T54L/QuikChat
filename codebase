{
  "Makefile": ".PHONY: up down logs psql migrate-up run build\n\n# Docker Compose commands\nup:\n\t@echo \"Starting Docker containers...\"\n\tdocker-compose up -d\n\ndown:\n\t@echo \"Stopping Docker containers...\"\n\tdocker-compose down\n\nlogs:\n\t@echo \"Tailing logs...\"\n\tdocker-compose logs -f\n\n# Database commands\npsql:\n\t@echo \"Connecting to PostgreSQL container...\"\n\tdocker-compose exec postgres psql -U user -d chatdb\n\nmigrate-up:\n\t@echo \"Applying database migrations...\"\n\tdocker-compose exec -T postgres psql -U user -d chatdb \u003c backend/migrations/000001_create_users_table.up.sql\n\tdocker-compose exec -T postgres psql -U user -d chatdb \u003c backend/migrations/000002_create_sessions_table.up.sql\n\n# Go application commands\nrun:\n\t@echo \"Running the Go application...\"\n\tgo run ./backend/cmd/server/main.go\n\nbuild:\n\t@echo \"Building the Go application...\"\n\tgo build -o ./bin/server ./backend/cmd/server/main.go\n",
  "backend/cmd/server/main.go": "package main\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"log\"\n\t\"net/http\"\n\t\"time\"\n\n\t\"chat-app/backend/internal/adapter/localfile\"\n\t\"chat-app/backend/internal/adapter/postgres\"\n\t\"chat-app/backend/internal/adapter/redis\"\n\t\"chat-app/backend/internal/delivery/websocket\"\n\t\"chat-app/backend/internal/repository\" // Added from attempted\n\t\"chat-app/backend/internal/service\"\n\t\"chat-app/backend/internal/usecase\" // Added from attempted\n\t\"chat-app/backend/pkg/config\"\n\n\thttpRouter \"chat-app/backend/internal/delivery/http\" // Alias for custom http router\n)\n\nfunc main() {\n\t// Load configuration\n\tcfg := config.Load()\n\n\t// Initialize database connection\n\tdbPool, err := postgres.NewDB(cfg.DatabaseURL) // Changed to include error handling\n\tif err != nil {\n\t\tlog.Fatalf(\"Could not connect to the database: %v\", err)\n\t}\n\tdefer dbPool.Close()\n\tlog.Println(\"Database connection established.\")\n\n\t// Initialize Redis client\n\tredisClient := redis.NewClient(cfg.RedisURL)\n\n\t// Initialize repositories\n\tuserRepo := postgres.NewPostgresUserRepository(dbPool)\n\tsessionRepo := postgres.NewPostgresSessionRepository(dbPool)\n\tfileRepo, err := localfile.NewLocalFileRepository(cfg.UploadDir)\n\tif err != nil {\n\t\tlog.Fatalf(\"Could not create file repository: %v\", err) // Updated error message\n\t}\n\tredisEventRepo := redis.NewRedisEventRepository(redisClient)\n\tpgEventRepo := postgres.NewPostgresEventRepository(dbPool)\n\tfriendRepo := postgres.NewPostgresFriendRepository(dbPool)\n\tgroupRepo := postgres.NewPostgresGroupRepository(dbPool)\n\tmessageRepo := postgres.NewPostgresMessageRepository(dbPool) // Added messageRepo\n\n\t// Initialize use cases/services\n\tauthUsecase := service.NewAuthService(userRepo, sessionRepo, cfg)\n\tuserUsecase := service.NewUserService(userRepo, fileRepo)\n\teventUsecase := service.NewEventService(redisEventRepo, pgEventRepo, userRepo)\n\tfriendUsecase := service.NewFriendService(friendRepo, userRepo, eventUsecase)\n\tgroupUsecase := service.NewGroupService(groupRepo, userRepo, friendRepo, fileRepo, eventUsecase)\n\tmessageUsecase := service.NewMessageService(messageRepo, userRepo, groupRepo, eventUsecase) // Added messageUsecase\n\n\t// Initialize WebSocket Hub\n\thub := websocket.NewHub(eventUsecase, messageUsecase) // Added messageUsecase to hub\n\tgo hub.Run()\n\n\t// Start background worker for event persistence\n\tgo func() {\n\t\tticker := time.NewTicker(1 * time.Minute)\n\t\tdefer ticker.Stop()\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase \u003c-ticker.C:\n\t\t\t\tlog.Println(\"Running background job: Persisting buffered events...\") // Updated log message\n\t\t\t\tif err := eventUsecase.PersistBufferedEvents(context.Background()); err != nil {\n\t\t\t\t\tlog.Printf(\"Error persisting buffered events: %v\", err)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}()\n\n\t// Initialize router\n\trouter := httpRouter.NewRouter(cfg, authUsecase, userUsecase, friendUsecase, groupUsecase, messageUsecase, hub) // Updated router package and added messageUsecase\n\n\t// Start server\n\tlog.Printf(\"Server starting on port %s\", cfg.Port)\n\tif err := http.ListenAndServe(fmt.Sprintf(\":%s\", cfg.Port), router); err != nil { // Used fmt.Sprintf and direct http.ListenAndServe\n\t\tlog.Fatalf(\"Could not start server: %v\", err) // Updated error message\n\t}\n}",
  "backend/go.mod": "module chat-app\n\ngo 1.24.0\n",
  "backend/internal/adapter/localfile/file_repository.go": "package localfile\n\nimport (\n\t\"chat-app/internal/repository\"\n\t\"chat-app/pkg/util\"\n\t\"context\"\n\t\"fmt\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"strings\"\n)\n\ntype localFileRepository struct {\n\tuploadDir string\n}\n\nfunc NewLocalFileRepository(uploadDir string) (repository.FileRepository, error) {\n\tif err := os.MkdirAll(uploadDir, os.ModePerm); err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to create upload directory: %w\", err)\n\t}\n\treturn \u0026localFileRepository{uploadDir: uploadDir}, nil\n}\n\nfunc (r *localFileRepository) SaveProfilePicture(_ context.Context, fileData []byte, fileType string) (string, error) {\n\tvar ext string\n\tswitch fileType {\n\tcase \"image/jpeg\", \"image/jpg\":\n\t\text = \".jpg\"\n\tcase \"image/png\":\n\t\text = \".png\"\n\tcase \"image/webp\":\n\t\text = \".webp\"\n\tdefault:\n\t\treturn \"\", fmt.Errorf(\"unsupported file type: %s\", fileType)\n\t}\n\n\tfilename := util.NewUUID() + ext\n\tfilePath := filepath.Join(r.uploadDir, filename)\n\n\terr := os.WriteFile(filePath, fileData, 0644)\n\tif err != nil {\n\t\treturn \"\", fmt.Errorf(\"failed to write file: %w\", err)\n\t}\n\n\treturn filename, nil\n}\n",
  "backend/internal/adapter/postgres/event_repository.go": "package postgres\n\nimport (\n\t\"chat-app/internal/domain\"\n\t\"chat-app/internal/repository\"\n\t\"context\"\n\t\"fmt\"\n\t\"github.com/jackc/pgx/v5/pgxpool\"\n)\n\ntype postgresEventRepository struct {\n\tdb *pgxpool.Pool\n}\n\nfunc NewPostgresEventRepository(db *pgxpool.Pool) repository.EventRepository {\n\treturn \u0026postgresEventRepository{db: db}\n}\n\nfunc (r *postgresEventRepository) StoreEvents(ctx context.Context, events []*domain.Event) error {\n\tif len(events) == 0 {\n\t\treturn nil\n\t}\n\n\ttx, err := r.db.Begin(ctx)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to begin transaction: %w\", err)\n\t}\n\tdefer tx.Rollback(ctx)\n\n\tquery := `INSERT INTO events (id, type, payload, recipient_id, created_at) VALUES ($1, $2, $3, $4, $5)`\n\tfor _, event := range events {\n\t\t_, err := tx.Exec(ctx, query, event.ID, event.Type, event.Payload, event.RecipientID, event.CreatedAt)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"failed to insert event: %w\", err)\n\t\t}\n\t}\n\n\treturn tx.Commit(ctx)\n}\n\nfunc (r *postgresEventRepository) GetUndeliveredEvents(ctx context.Context, userID string) ([]*domain.Event, error) {\n\tquery := `SELECT id, type, payload, recipient_id, is_delivered, created_at FROM events WHERE recipient_id = $1 AND is_delivered = FALSE ORDER BY created_at ASC`\n\trows, err := r.db.Query(ctx, query, userID)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to query undelivered events: %w\", err)\n\t}\n\tdefer rows.Close()\n\n\tvar events []*domain.Event\n\tfor rows.Next() {\n\t\tvar event domain.Event\n\t\tif err := rows.Scan(\u0026event.ID, \u0026event.Type, \u0026event.Payload, \u0026event.RecipientID, \u0026event.IsDelivered, \u0026event.CreatedAt); err != nil {\n\t\t\treturn nil, fmt.Errorf(\"failed to scan event row: %w\", err)\n\t\t}\n\t\tevents = append(events, \u0026event)\n\t}\n\treturn events, nil\n}\n\nfunc (r *postgresEventRepository) MarkEventsAsDelivered(ctx context.Context, eventIDs []string) error {\n\tif len(eventIDs) == 0 {\n\t\treturn nil\n\t}\n\tquery := `UPDATE events SET is_delivered = TRUE WHERE id = ANY($1::uuid[])`\n\t_, err := r.db.Exec(ctx, query, eventIDs)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to mark events as delivered: %w\", err)\n\t}\n\treturn nil\n}\n\n// These methods are for the Redis implementation, so they are no-ops here.\nfunc (r *postgresEventRepository) BufferEvent(ctx context.Context, event *domain.Event) error {\n\treturn nil\n}\nfunc (r *postgresEventRepository) GetBufferedEventsForUser(ctx context.Context, userID string) ([]*domain.Event, error) {\n\treturn nil, nil\n}\nfunc (r *postgresEventRepository) ClearUserBuffer(ctx context.Context, userID string) error {\n\treturn nil\n}\n",
  "backend/internal/adapter/postgres/friend_repository.go": "package postgres\n\nimport (\n\t\"context\"\n\t\"database/sql\"\n\t\"errors\"\n\t\"fmt\"\n\t\"time\"\n\n\t\"chat-app/internal/domain\"\n\t\"chat-app/internal/repository\"\n\n\t\"github.com/jackc/pgx/v5\"\n\t\"github.com/jackc/pgx/v5/pgconn\"\n\t\"github.com/jackc/pgx/v5/pgxpool\"\n)\n\ntype postgresFriendRepository struct {\n\tdb *pgxpool.Pool\n}\n\nfunc NewPostgresFriendRepository(db *pgxpool.Pool) repository.FriendRepository {\n\treturn \u0026postgresFriendRepository{db: db}\n}\n\nfunc (r *postgresFriendRepository) CreateRequest(ctx context.Context, req *domain.FriendRequest) error {\n\tquery := `\n        INSERT INTO friend_requests (id, sender_id, receiver_id, status, created_at, updated_at)\n        VALUES ($1, $2, $3, $4, $5, $6)\n    `\n\t_, err := r.db.Exec(ctx, query, req.ID, req.SenderID, req.ReceiverID, req.Status, req.CreatedAt, req.UpdatedAt)\n\tif err != nil {\n\t\tvar pgErr *pgconn.PgError\n\t\tif errors.As(err, \u0026pgErr) \u0026\u0026 pgErr.Code == \"23505\" { // unique_violation\n\t\t\treturn repository.ErrFriendRequestExists\n\t\t}\n\t\treturn fmt.Errorf(\"failed to create friend request: %w\", err)\n\t}\n\treturn nil\n}\n\nfunc (r *postgresFriendRepository) GetRequestByID(ctx context.Context, id string) (*domain.FriendRequest, error) {\n\tquery := `\n        SELECT id, sender_id, receiver_id, status, created_at, updated_at\n        FROM friend_requests\n        WHERE id = $1\n    `\n\treq := \u0026domain.FriendRequest{}\n\terr := r.db.QueryRow(ctx, query, id).Scan(\u0026req.ID, \u0026req.SenderID, \u0026req.ReceiverID, \u0026req.Status, \u0026req.CreatedAt, \u0026req.UpdatedAt)\n\tif err != nil {\n\t\tif errors.Is(err, pgx.ErrNoRows) {\n\t\t\treturn nil, repository.ErrNotFound\n\t\t}\n\t\treturn nil, fmt.Errorf(\"failed to get friend request by id: %w\", err)\n\t}\n\treturn req, nil\n}\n\nfunc (r *postgresFriendRepository) UpdateRequestStatus(ctx context.Context, id, status string) error {\n\tquery := `\n        UPDATE friend_requests\n        SET status = $1, updated_at = $2\n        WHERE id = $3\n    `\n\tcmdTag, err := r.db.Exec(ctx, query, status, time.Now().UTC(), id)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to update friend request status: %w\", err)\n\t}\n\tif cmdTag.RowsAffected() == 0 {\n\t\treturn repository.ErrNotFound\n\t}\n\treturn nil\n}\n\nfunc (r *postgresFriendRepository) AreFriends(ctx context.Context, userID1, userID2 string) (bool, error) {\n\tif userID1 \u003e userID2 {\n\t\tuserID1, userID2 = userID2, userID1\n\t}\n\tquery := `\n        SELECT EXISTS (\n            SELECT 1 FROM friendships WHERE user_id1 = $1 AND user_id2 = $2\n        )\n    `\n\tvar exists bool\n\terr := r.db.QueryRow(ctx, query, userID1, userID2).Scan(\u0026exists)\n\tif err != nil {\n\t\treturn false, fmt.Errorf(\"failed to check friendship: %w\", err)\n\t}\n\treturn exists, nil\n}\n\nfunc (r *postgresFriendRepository) AddFriendship(ctx context.Context, userID1, userID2 string) error {\n\tif userID1 \u003e userID2 {\n\t\tuserID1, userID2 = userID2, userID1\n\t}\n\tquery := `\n        INSERT INTO friendships (user_id1, user_id2)\n        VALUES ($1, $2)\n        ON CONFLICT (user_id1, user_id2) DO NOTHING\n    `\n\t_, err := r.db.Exec(ctx, query, userID1, userID2)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to add friendship: %w\", err)\n\t}\n\treturn nil\n}\n\nfunc (r *postgresFriendRepository) RemoveFriendship(ctx context.Context, userID1, userID2 string) error {\n\tif userID1 \u003e userID2 {\n\t\tuserID1, userID2 = userID2, userID1\n\t}\n\tquery := `\n        DELETE FROM friendships\n        WHERE user_id1 = $1 AND user_id2 = $2\n    `\n\t_, err := r.db.Exec(ctx, query, userID1, userID2)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to remove friendship: %w\", err)\n\t}\n\treturn nil\n}\n\nfunc (r *postgresFriendRepository) GetPendingRequests(ctx context.Context, userID string) ([]*domain.FriendRequest, error) {\n\tquery := `\n        SELECT fr.id, fr.sender_id, fr.receiver_id, fr.status, fr.created_at, fr.updated_at,\n               s.username as sender_username, s.profile_pic_url as sender_profile_pic_url,\n               rc.username as receiver_username, rc.profile_pic_url as receiver_profile_pic_url\n        FROM friend_requests fr\n        JOIN users s ON fr.sender_id = s.id\n        JOIN users rc ON fr.receiver_id = rc.id\n        WHERE (fr.receiver_id = $1 OR fr.sender_id = $1) AND fr.status = 'pending'\n        ORDER BY fr.created_at DESC\n    `\n\trows, err := r.db.Query(ctx, query, userID)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to get pending requests: %w\", err)\n\t}\n\tdefer rows.Close()\n\n\tvar requests []*domain.FriendRequest\n\tfor rows.Next() {\n\t\treq := \u0026domain.FriendRequest{\n\t\t\tSender:   \u0026domain.User{},\n\t\t\tReceiver: \u0026domain.User{},\n\t\t}\n\t\terr := rows.Scan(\n\t\t\t\u0026req.ID, \u0026req.SenderID, \u0026req.ReceiverID, \u0026req.Status, \u0026req.CreatedAt, \u0026req.UpdatedAt,\n\t\t\t\u0026req.Sender.Username, \u0026req.Sender.ProfilePicURL,\n\t\t\t\u0026req.Receiver.Username, \u0026req.Receiver.ProfilePicURL,\n\t\t)\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"failed to scan pending request: %w\", err)\n\t\t}\n\t\treq.Sender.ID = req.SenderID\n\t\treq.Receiver.ID = req.ReceiverID\n\t\trequests = append(requests, req)\n\t}\n\treturn requests, nil\n}\n\nfunc (r *postgresFriendRepository) GetFriendsByUserID(ctx context.Context, userID string) ([]*domain.User, error) {\n\tquery := `\n        SELECT u.id, u.username, u.profile_pic_url, u.created_at\n        FROM friendships f\n        JOIN users u ON u.id = CASE WHEN f.user_id1 = $1 THEN f.user_id2 ELSE f.user_id1 END\n        WHERE f.user_id1 = $1 OR f.user_id2 = $1\n        ORDER BY u.username\n    `\n\trows, err := r.db.Query(ctx, query, userID)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to get friends by user id: %w\", err)\n\t}\n\tdefer rows.Close()\n\n\tvar friends []*domain.User\n\tfor rows.Next() {\n\t\tfriend := \u0026domain.User{}\n\t\tvar createdAt sql.NullTime\n\t\terr := rows.Scan(\u0026friend.ID, \u0026friend.Username, \u0026friend.ProfilePicURL, \u0026createdAt)\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"failed to scan friend: %w\", err)\n\t\t}\n\t\tif createdAt.Valid {\n\t\t\tfriend.CreatedAt = createdAt.Time\n\t\t}\n\t\tfriends = append(friends, friend)\n\t}\n\treturn friends, nil\n}\n\nfunc (r *postgresFriendRepository) HasPendingRequest(ctx context.Context, userID1, userID2 string) (bool, error) {\n\tquery := `\n        SELECT EXISTS (\n            SELECT 1 FROM friend_requests\n            WHERE ((sender_id = $1 AND receiver_id = $2) OR (sender_id = $2 AND receiver_id = $1))\n            AND status = 'pending'\n        )\n    `\n\tvar exists bool\n\terr := r.db.QueryRow(ctx, query, userID1, userID2).Scan(\u0026exists)\n\tif err != nil {\n\t\treturn false, fmt.Errorf(\"failed to check for pending request: %w\", err)\n\t}\n\treturn exists, nil\n}\n",
  "backend/internal/adapter/postgres/group_repository.go": "package postgres\n\nimport (\n\t\"chat-app/internal/domain\"\n\t\"chat-app/internal/repository\"\n\t\"context\"\n\t\"errors\"\n\t\"fmt\"\n\n\t\"github.com/jackc/pgx/v5\"\n\t\"github.com/jackc/pgx/v5/pgconn\"\n\t\"github.com/jackc/pgx/v5/pgxpool\"\n)\n\ntype postgresGroupRepository struct {\n\tdb *pgxpool.Pool\n}\n\nfunc NewPostgresGroupRepository(db *pgxpool.Pool) repository.GroupRepository {\n\treturn \u0026postgresGroupRepository{db: db}\n}\n\nfunc (r *postgresGroupRepository) Create(ctx context.Context, group *domain.Group) error {\n\tquery := `INSERT INTO groups (id, handle, name, owner_id, profile_pic_url)\n              VALUES ($1, $2, $3, $4, $5)`\n\t_, err := r.db.Exec(ctx, query, group.ID, group.Handle, group.Name, group.OwnerID, group.ProfilePicURL)\n\tif err != nil {\n\t\tvar pgErr *pgconn.PgError\n\t\tif errors.As(err, \u0026pgErr) \u0026\u0026 pgErr.Code == \"23505\" { // unique_violation\n\t\t\treturn repository.ErrGroupHandleExists\n\t\t}\n\t\treturn fmt.Errorf(\"failed to create group: %w\", err)\n\t}\n\treturn nil\n}\n\nfunc (r *postgresGroupRepository) CreateMember(ctx context.Context, member *domain.GroupMember) error {\n\tquery := `INSERT INTO group_members (group_id, user_id, role) VALUES ($1, $2, $3)`\n\t_, err := r.db.Exec(ctx, query, member.GroupID, member.UserID, member.Role)\n\tif err != nil {\n\t\tvar pgErr *pgconn.PgError\n\t\tif errors.As(err, \u0026pgErr) \u0026\u0026 pgErr.Code == \"23505\" { // unique_violation\n\t\t\treturn repository.ErrGroupMemberExists\n\t\t}\n\t\treturn fmt.Errorf(\"failed to create group member: %w\", err)\n\t}\n\treturn nil\n}\n\nfunc (r *postgresGroupRepository) GetByID(ctx context.Context, id string) (*domain.Group, error) {\n\tquery := `SELECT id, handle, name, owner_id, profile_pic_url, created_at, updated_at\n              FROM groups WHERE id = $1`\n\tvar group domain.Group\n\terr := r.db.QueryRow(ctx, query, id).Scan(\n\t\t\u0026group.ID, \u0026group.Handle, \u0026group.Name, \u0026group.OwnerID,\n\t\t\u0026group.ProfilePicURL, \u0026group.CreatedAt, \u0026group.UpdatedAt,\n\t)\n\tif err != nil {\n\t\tif errors.Is(err, pgx.ErrNoRows) {\n\t\t\treturn nil, repository.ErrNotFound\n\t\t}\n\t\treturn nil, fmt.Errorf(\"failed to get group by id: %w\", err)\n\t}\n\treturn \u0026group, nil\n}\n\nfunc (r *postgresGroupRepository) GetByHandle(ctx context.Context, handle string) (*domain.Group, error) {\n\tquery := `SELECT id, handle, name, owner_id, profile_pic_url, created_at, updated_at\n              FROM groups WHERE handle = $1`\n\tvar group domain.Group\n\terr := r.db.QueryRow(ctx, query, handle).Scan(\n\t\t\u0026group.ID, \u0026group.Handle, \u0026group.Name, \u0026group.OwnerID,\n\t\t\u0026group.ProfilePicURL, \u0026group.CreatedAt, \u0026group.UpdatedAt,\n\t)\n\tif err != nil {\n\t\tif errors.Is(err, pgx.ErrNoRows) {\n\t\t\treturn nil, repository.ErrNotFound\n\t\t}\n\t\treturn nil, fmt.Errorf(\"failed to get group by handle: %w\", err)\n\t}\n\treturn \u0026group, nil\n}\n\nfunc (r *postgresGroupRepository) Update(ctx context.Context, group *domain.Group) error {\n\tquery := `UPDATE groups SET name = $1, owner_id = $2, profile_pic_url = $3, updated_at = NOW()\n              WHERE id = $4`\n\t_, err := r.db.Exec(ctx, query, group.Name, group.OwnerID, group.ProfilePicURL, group.ID)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to update group: %w\", err)\n\t}\n\treturn nil\n}\n\nfunc (r *postgresGroupRepository) FindMember(ctx context.Context, groupID, userID string) (*domain.GroupMember, error) {\n\tquery := `SELECT group_id, user_id, role, created_at FROM group_members\n              WHERE group_id = $1 AND user_id = $2`\n\tvar member domain.GroupMember\n\terr := r.db.QueryRow(ctx, query, groupID, userID).Scan(\n\t\t\u0026member.GroupID, \u0026member.UserID, \u0026member.Role, \u0026member.CreatedAt,\n\t)\n\tif err != nil {\n\t\tif errors.Is(err, pgx.ErrNoRows) {\n\t\t\treturn nil, repository.ErrNotFound\n\t\t}\n\t\treturn nil, fmt.Errorf(\"failed to find group member: %w\", err)\n\t}\n\treturn \u0026member, nil\n}\n\nfunc (r *postgresGroupRepository) RemoveMember(ctx context.Context, groupID, userID string) error {\n\tquery := `DELETE FROM group_members WHERE group_id = $1 AND user_id = $2`\n\tcmdTag, err := r.db.Exec(ctx, query, groupID, userID)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to remove group member: %w\", err)\n\t}\n\tif cmdTag.RowsAffected() == 0 {\n\t\treturn repository.ErrNotFound\n\t}\n\treturn nil\n}\n\nfunc (r *postgresGroupRepository) GetMembersWithUserDetails(ctx context.Context, groupID string) ([]*domain.GroupMember, error) {\n\tquery := `SELECT gm.group_id, gm.user_id, gm.role, gm.created_at,\n                     u.username, u.profile_pic_url\n              FROM group_members gm\n              JOIN users u ON gm.user_id = u.id\n              WHERE gm.group_id = $1\n              ORDER BY gm.created_at`\n\trows, err := r.db.Query(ctx, query, groupID)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to get group members: %w\", err)\n\t}\n\tdefer rows.Close()\n\n\tvar members []*domain.GroupMember\n\tfor rows.Next() {\n\t\tvar member domain.GroupMember\n\t\tmember.User = \u0026domain.User{}\n\t\terr := rows.Scan(\n\t\t\t\u0026member.GroupID, \u0026member.UserID, \u0026member.Role, \u0026member.CreatedAt,\n\t\t\t\u0026member.User.Username, \u0026member.User.ProfilePicURL,\n\t\t)\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"failed to scan group member: %w\", err)\n\t\t}\n\t\tmember.User.ID = member.UserID\n\t\tmembers = append(members, \u0026member)\n\t}\n\treturn members, nil\n}\n\nfunc (r *postgresGroupRepository) GetGroupsByUserID(ctx context.Context, userID string) ([]*domain.Group, error) {\n\tquery := `SELECT g.id, g.handle, g.name, g.owner_id, g.profile_pic_url, g.created_at, g.updated_at\n              FROM groups g\n              JOIN group_members gm ON g.id = gm.group_id\n              WHERE gm.user_id = $1\n              ORDER BY g.name`\n\trows, err := r.db.Query(ctx, query, userID)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to get groups by user id: %w\", err)\n\t}\n\tdefer rows.Close()\n\n\tvar groups []*domain.Group\n\tfor rows.Next() {\n\t\tvar group domain.Group\n\t\terr := rows.Scan(\n\t\t\t\u0026group.ID, \u0026group.Handle, \u0026group.Name, \u0026group.OwnerID,\n\t\t\t\u0026group.ProfilePicURL, \u0026group.CreatedAt, \u0026group.UpdatedAt,\n\t\t)\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"failed to scan group: %w\", err)\n\t\t}\n\t\tgroups = append(groups, \u0026group)\n\t}\n\treturn groups, nil\n}\n\nfunc (r *postgresGroupRepository) SearchByHandle(ctx context.Context, query string) ([]*domain.Group, error) {\n\tsqlQuery := `SELECT id, handle, name, owner_id, profile_pic_url, created_at, updated_at\n                 FROM groups WHERE handle ILIKE $1 LIMIT 20`\n\trows, err := r.db.Query(ctx, sqlQuery, \"%\"+query+\"%\")\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to search groups: %w\", err)\n\t}\n\tdefer rows.Close()\n\n\tvar groups []*domain.Group\n\tfor rows.Next() {\n\t\tvar group domain.Group\n\t\terr := rows.Scan(\n\t\t\t\u0026group.ID, \u0026group.Handle, \u0026group.Name, \u0026group.OwnerID,\n\t\t\t\u0026group.ProfilePicURL, \u0026group.CreatedAt, \u0026group.UpdatedAt,\n\t\t)\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"failed to scan group during search: %w\", err)\n\t\t}\n\t\tgroups = append(groups, \u0026group)\n\t}\n\treturn groups, nil\n}\n\nfunc (r *postgresGroupRepository) GetOldestMember(ctx context.Context, groupID, excludeUserID string) (*domain.GroupMember, error) {\n\tquery := `SELECT group_id, user_id, role, created_at FROM group_members\n              WHERE group_id = $1 AND user_id != $2\n              ORDER BY created_at ASC LIMIT 1`\n\tvar member domain.GroupMember\n\terr := r.db.QueryRow(ctx, query, groupID, excludeUserID).Scan(\n\t\t\u0026member.GroupID, \u0026member.UserID, \u0026member.Role, \u0026member.CreatedAt,\n\t)\n\tif err != nil {\n\t\tif errors.Is(err, pgx.ErrNoRows) {\n\t\t\treturn nil, repository.ErrNotFound\n\t\t}\n\t\treturn nil, fmt.Errorf(\"failed to get oldest group member: %w\", err)\n\t}\n\treturn \u0026member, nil\n}\n",
  "backend/internal/adapter/postgres/message_repository.go": "package postgres\n\nimport (\n\t\"context\"\n\t\"time\"\n\n\t\"chat-app/backend/internal/domain\"\n\t\"chat-app/backend/internal/repository\"\n\n\t\"github.com/jackc/pgx/v5/pgxpool\"\n)\n\ntype postgresMessageRepository struct {\n\tdb *pgxpool.Pool\n}\n\nfunc NewPostgresMessageRepository(db *pgxpool.Pool) repository.MessageRepository {\n\treturn \u0026postgresMessageRepository{db: db}\n}\n\nfunc (r *postgresMessageRepository) Create(ctx context.Context, message *domain.Message) error {\n\tquery := `\n        INSERT INTO messages (id, conversation_id, sender_id, content, created_at)\n        VALUES ($1, $2, $3, $4, $5)\n    `\n\t_, err := r.db.Exec(ctx, query, message.ID, message.ConversationID, message.SenderID, message.Content, message.CreatedAt)\n\treturn err\n}\n\nfunc (r *postgresMessageRepository) GetByConversationID(ctx context.Context, conversationID string, before time.Time, limit int) ([]*domain.Message, error) {\n\tquery := `\n        SELECT m.id, m.conversation_id, m.sender_id, m.content, m.created_at,\n               u.username as sender_username, u.profile_pic_url as sender_profile_pic_url\n        FROM messages m\n        JOIN users u ON m.sender_id = u.id\n        WHERE m.conversation_id = $1 AND m.created_at \u003c $2\n        ORDER BY m.created_at DESC\n        LIMIT $3\n    `\n\trows, err := r.db.Query(ctx, query, conversationID, before, limit)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer rows.Close()\n\n\tvar messages []*domain.Message\n\tfor rows.Next() {\n\t\tvar msg domain.Message\n\t\tmsg.Sender = \u0026domain.User{}\n\t\terr := rows.Scan(\n\t\t\t\u0026msg.ID,\n\t\t\t\u0026msg.ConversationID,\n\t\t\t\u0026msg.SenderID,\n\t\t\t\u0026msg.Content,\n\t\t\t\u0026msg.CreatedAt,\n\t\t\t\u0026msg.Sender.Username,\n\t\t\t\u0026msg.Sender.ProfilePicURL,\n\t\t)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tmessages = append(messages, \u0026msg)\n\t}\n\n\t// Reverse slice to return messages in ascending order\n\tfor i, j := 0, len(messages)-1; i \u003c j; i, j = i+1, j-1 {\n\t\tmessages[i], messages[j] = messages[j], messages[i]\n\t}\n\n\treturn messages, nil\n}\n",
  "backend/internal/adapter/postgres/postgres.go": "package postgres\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"log\"\n\n\t\"github.com/jackc/pgx/v5/pgxpool\"\n)\n\nfunc NewDB(databaseURL string) *pgxpool.Pool {\n\tdbpool, err := pgxpool.New(context.Background(), databaseURL)\n\tif err != nil {\n\t\tlog.Fatalf(\"Unable to create connection pool: %v\\n\", err)\n\t}\n\n\terr = dbpool.Ping(context.Background())\n\tif err != nil {\n\t\tlog.Fatalf(\"Unable to ping database: %v\\n\", err)\n\t}\n\n\tfmt.Println(\"Successfully connected to PostgreSQL!\")\n\treturn dbpool\n}\n",
  "backend/internal/adapter/postgres/session_repository.go": "package postgres\n\nimport (\n\t\"context\"\n\t\"errors\"\n\n\t\"chat-app/internal/domain\"\n\t\"chat-app/internal/repository\"\n\n\t\"github.com/jackc/pgx/v5\"\n\t\"github.com/jackc/pgx/v5/pgxpool\"\n)\n\ntype postgresSessionRepository struct {\n\tdb *pgxpool.Pool\n}\n\nfunc NewPostgresSessionRepository(db *pgxpool.Pool) repository.SessionRepository {\n\treturn \u0026postgresSessionRepository{db: db}\n}\n\nfunc (r *postgresSessionRepository) Store(ctx context.Context, session *domain.Session) error {\n\tquery := `INSERT INTO sessions (id, user_id, expires_at) VALUES ($1, $2, $3)`\n\t_, err := r.db.Exec(ctx, query, session.ID, session.UserID, session.ExpiresAt)\n\treturn err\n}\n\nfunc (r *postgresSessionRepository) GetByID(ctx context.Context, id string) (*domain.Session, error) {\n\tquery := `SELECT id, user_id, expires_at, created_at FROM sessions WHERE id = $1`\n\n\tsession := \u0026domain.Session{}\n\terr := r.db.QueryRow(ctx, query, id).Scan(\n\t\t\u0026session.ID,\n\t\t\u0026session.UserID,\n\t\t\u0026session.ExpiresAt,\n\t\t\u0026session.CreatedAt,\n\t)\n\tif err != nil {\n\t\tif errors.Is(err, pgx.ErrNoRows) {\n\t\t\treturn nil, nil // Not found\n\t\t}\n\t\treturn nil, err\n\t}\n\treturn session, nil\n}\n\nfunc (r *postgresSessionRepository) Delete(ctx context.Context, id string) error {\n\tquery := `DELETE FROM sessions WHERE id = $1`\n\t_, err := r.db.Exec(ctx, query, id)\n\treturn err\n}\n\nfunc (r *postgresSessionRepository) DeleteAllForUser(ctx context.Context, userID string) error {\n\tquery := `DELETE FROM sessions WHERE user_id = $1`\n\t_, err := r.db.Exec(ctx, query, userID)\n\treturn err\n}\n",
  "backend/internal/adapter/postgres/user_repository.go": "package postgres\n\nimport (\n\t\"context\"\n\t\"errors\"\n\n\t\"chat-app/internal/domain\"\n\t\"chat-app/internal/repository\"\n\n\t\"github.com/jackc/pgx/v5\"\n\t\"github.com/jackc/pgx/v5/pgxpool\"\n)\n\ntype postgresUserRepository struct {\n\tdb *pgxpool.Pool\n}\n\nfunc NewPostgresUserRepository(db *pgxpool.Pool) repository.UserRepository {\n\treturn \u0026postgresUserRepository{db: db}\n}\n\nfunc (r *postgresUserRepository) Create(ctx context.Context, user *domain.User) error {\n\tquery := `INSERT INTO users (id, username, password_hash) VALUES ($1, $2, $3)`\n\t_, err := r.db.Exec(ctx, query, user.ID, user.Username, user.PasswordHash)\n\treturn err\n}\n\nfunc (r *postgresUserRepository) GetByUsername(ctx context.Context, username string) (*domain.User, error) {\n\tquery := `SELECT id, username, password_hash, profile_pic_url, created_at, updated_at FROM users WHERE username = $1`\n\tuser := \u0026domain.User{}\n\terr := r.db.QueryRow(ctx, query, username).Scan(\u0026user.ID, \u0026user.Username, \u0026user.PasswordHash, \u0026user.ProfilePicURL, \u0026user.CreatedAt, \u0026user.UpdatedAt)\n\tif err != nil {\n\t\tif errors.Is(err, pgx.ErrNoRows) {\n\t\t\treturn nil, nil\n\t\t}\n\t\treturn nil, err\n\t}\n\treturn user, nil\n}\n\nfunc (r *postgresUserRepository) GetByID(ctx context.Context, id string) (*domain.User, error) {\n\tquery := `SELECT id, username, password_hash, profile_pic_url, created_at, updated_at FROM users WHERE id = $1`\n\tuser := \u0026domain.User{}\n\terr := r.db.QueryRow(ctx, query, id).Scan(\u0026user.ID, \u0026user.Username, \u0026user.PasswordHash, \u0026user.ProfilePicURL, \u0026user.CreatedAt, \u0026user.UpdatedAt)\n\tif err != nil {\n\t\tif errors.Is(err, pgx.ErrNoRows) {\n\t\t\treturn nil, nil\n\t\t}\n\t\treturn nil, err\n\t}\n\treturn user, nil\n}\n\nfunc (r *postgresUserRepository) Update(ctx context.Context, user *domain.User) error {\n\tquery := `UPDATE users SET username = $1, password_hash = $2, profile_pic_url = $3, updated_at = NOW() WHERE id = $4`\n\t_, err := r.db.Exec(ctx, query, user.Username, user.PasswordHash, user.ProfilePicURL, user.ID)\n\treturn err\n}\n",
  "backend/internal/adapter/redis/event_repository.go": "package redis\n\nimport (\n\t\"chat-app/internal/domain\"\n\t\"chat-app/internal/repository\"\n\t\"context\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"github.com/redis/go-redis/v9\"\n\t\"time\"\n)\n\nconst (\n\tuserEventBufferKeyPrefix = \"events:\"\n\tbufferTTL                = 48 * time.Hour\n)\n\ntype redisEventRepository struct {\n\tclient *redis.Client\n}\n\nfunc NewRedisEventRepository(client *redis.Client) repository.EventRepository {\n\treturn \u0026redisEventRepository{client: client}\n}\n\nfunc (r *redisEventRepository) userBufferKey(userID string) string {\n\treturn fmt.Sprintf(\"%s%s\", userEventBufferKeyPrefix, userID)\n}\n\nfunc (r *redisEventRepository) BufferEvent(ctx context.Context, event *domain.Event) error {\n\tkey := r.userBufferKey(event.RecipientID)\n\n\teventJSON, err := json.Marshal(event)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to marshal event: %w\", err)\n\t}\n\n\tpipe := r.client.Pipeline()\n\tpipe.LPush(ctx, key, eventJSON)\n\tpipe.Expire(ctx, key, bufferTTL)\n\n\t_, err = pipe.Exec(ctx)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to execute redis pipeline for buffering event: %w\", err)\n\t}\n\treturn nil\n}\n\nfunc (r *redisEventRepository) GetBufferedEventsForUser(ctx context.Context, userID string) ([]*domain.Event, error) {\n\tkey := r.userBufferKey(userID)\n\teventStrings, err := r.client.LRange(ctx, key, 0, -1).Result()\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to get buffered events from redis: %w\", err)\n\t}\n\n\tevents := make([]*domain.Event, 0, len(eventStrings))\n\tfor _, eventStr := range eventStrings {\n\t\tvar event domain.Event\n\t\tif err := json.Unmarshal([]byte(eventStr), \u0026event); err != nil {\n\t\t\t// Log error but continue processing other events\n\t\t\tfmt.Printf(\"Error unmarshalling event from redis: %v\\n\", err)\n\t\t\tcontinue\n\t\t}\n\t\tevents = append(events, \u0026event)\n\t}\n\treturn events, nil\n}\n\nfunc (r *redisEventRepository) ClearUserBuffer(ctx context.Context, userID string) error {\n\tkey := r.userBufferKey(userID)\n\tif err := r.client.Del(ctx, key).Err(); err != nil {\n\t\treturn fmt.Errorf(\"failed to clear user event buffer in redis: %w\", err)\n\t}\n\treturn nil\n}\n\n// These methods are for the Postgres implementation, so they are no-ops here.\nfunc (r *redisEventRepository) StoreEvents(ctx context.Context, events []*domain.Event) error {\n\treturn nil\n}\nfunc (r *redisEventRepository) GetUndeliveredEvents(ctx context.Context, userID string) ([]*domain.Event, error) {\n\treturn nil, nil\n}\nfunc (r *redisEventRepository) MarkEventsAsDelivered(ctx context.Context, eventIDs []string) error {\n\treturn nil\n}\n",
  "backend/internal/adapter/redis/redis.go": "package redis\n\nimport (\n\t\"context\"\n\t\"github.com/redis/go-redis/v9\"\n\t\"log\"\n)\n\nfunc NewClient(redisURL string) *redis.Client {\n\topts, err := redis.ParseURL(redisURL)\n\tif err != nil {\n\t\tlog.Fatalf(\"Could not parse Redis URL: %v\", err)\n\t}\n\n\tclient := redis.NewClient(opts)\n\n\tif err := client.Ping(context.Background()).Err(); err != nil {\n\t\tlog.Fatalf(\"Could not connect to Redis: %v\", err)\n\t}\n\n\tlog.Println(\"Successfully connected to Redis\")\n\treturn client\n}\n",
  "backend/internal/delivery/http/handler/auth_handler.go": "package handler\n\nimport (\n\t\"encoding/json\"\n\t\"errors\"\n\t\"net/http\"\n\n\t\"chat-app/internal/service\"\n\t\"chat-app/internal/usecase\"\n)\n\ntype AuthHandler struct {\n\tauthUsecase usecase.AuthUsecase\n}\n\nfunc NewAuthHandler(authUsecase usecase.AuthUsecase) *AuthHandler {\n\treturn \u0026AuthHandler{authUsecase: authUsecase}\n}\n\nfunc (h *AuthHandler) SignUp(w http.ResponseWriter, r *http.Request) {\n\tvar input usecase.SignUpInput\n\tif err := json.NewDecoder(r.Body).Decode(\u0026input); err != nil {\n\t\thttp.Error(w, \"Invalid request body\", http.StatusBadRequest)\n\t\treturn\n\t}\n\n\tuser, err := h.authUsecase.SignUp(r.Context(), input)\n\tif err != nil {\n\t\thandleAuthError(w, err)\n\t\treturn\n\t}\n\n\t// Don't return password hash\n\tuser.PasswordHash = \"\"\n\n\tw.Header().Set(\"Content-Type\", \"application/json\")\n\tw.WriteHeader(http.StatusCreated)\n\tjson.NewEncoder(w).Encode(user)\n}\n\nfunc (h *AuthHandler) Login(w http.ResponseWriter, r *http.Request) {\n\tvar input usecase.LoginInput\n\tif err := json.NewDecoder(r.Body).Decode(\u0026input); err != nil {\n\t\thttp.Error(w, \"Invalid request body\", http.StatusBadRequest)\n\t\treturn\n\t}\n\n\ttokens, err := h.authUsecase.Login(r.Context(), input)\n\tif err != nil {\n\t\thandleAuthError(w, err)\n\t\treturn\n\t}\n\n\tw.Header().Set(\"Content-Type\", \"application/json\")\n\tjson.NewEncoder(w).Encode(tokens)\n}\n\nfunc (h *AuthHandler) Refresh(w http.ResponseWriter, r *http.Request) {\n\tvar body struct {\n\t\tRefreshToken string `json:\"refresh_token\"`\n\t}\n\tif err := json.NewDecoder(r.Body).Decode(\u0026body); err != nil {\n\t\thttp.Error(w, \"Invalid request body\", http.StatusBadRequest)\n\t\treturn\n\t}\n\n\ttokens, err := h.authUsecase.Refresh(r.Context(), body.RefreshToken)\n\tif err != nil {\n\t\thandleAuthError(w, err)\n\t\treturn\n\t}\n\n\tw.Header().Set(\"Content-Type\", \"application/json\")\n\tjson.NewEncoder(w).Encode(tokens)\n}\n\nfunc (h *AuthHandler) Logout(w http.ResponseWriter, r *http.Request) {\n\tvar body struct {\n\t\tRefreshToken string `json:\"refresh_token\"`\n\t}\n\tif err := json.NewDecoder(r.Body).Decode(\u0026body); err != nil {\n\t\thttp.Error(w, \"Invalid request body\", http.StatusBadRequest)\n\t\treturn\n\t}\n\n\terr := h.authUsecase.Logout(r.Context(), body.RefreshToken)\n\tif err != nil {\n\t\thandleAuthError(w, err)\n\t\treturn\n\t}\n\n\tw.WriteHeader(http.StatusNoContent)\n}\n\nfunc handleAuthError(w http.ResponseWriter, err error) {\n\tswitch {\n\tcase errors.Is(err, service.ErrUserExists),\n\t\terrors.Is(err, service.ErrInvalidUsername),\n\t\terrors.Is(err, service.ErrInvalidPassword):\n\t\thttp.Error(w, err.Error(), http.StatusBadRequest)\n\tcase errors.Is(err, service.ErrInvalidCredentials),\n\t\terrors.Is(err, service.ErrSessionNotFound),\n\t\terrors.Is(err, service.ErrSessionExpired):\n\t\thttp.Error(w, err.Error(), http.StatusUnauthorized)\n\tdefault:\n\t\thttp.Error(w, \"Internal server error\", http.StatusInternalServerError)\n\t}\n}\n",
  "backend/internal/delivery/http/handler/friend_handler.go": "package handler\n\nimport (\n\t\"encoding/json\"\n\t\"errors\"\n\t\"net/http\"\n\n\t\"chat-app/internal/delivery/http/middleware\"\n\t\"chat-app/internal/service\"\n\t\"chat-app/internal/usecase\"\n\n\t\"github.com/go-chi/chi/v5\"\n)\n\ntype FriendHandler struct {\n\tfriendUsecase usecase.FriendUsecase\n}\n\nfunc NewFriendHandler(uc usecase.FriendUsecase) *FriendHandler {\n\treturn \u0026FriendHandler{friendUsecase: uc}\n}\n\nfunc (h *FriendHandler) SendRequest(w http.ResponseWriter, r *http.Request) {\n\tuserID, ok := r.Context().Value(middleware.UserIDContextKey).(string)\n\tif !ok {\n\t\thttp.Error(w, \"Unauthorized\", http.StatusUnauthorized)\n\t\treturn\n\t}\n\n\tvar req struct {\n\t\tUsername string `json:\"username\"`\n\t}\n\tif err := json.NewDecoder(r.Body).Decode(\u0026req); err != nil {\n\t\thttp.Error(w, \"Invalid request body\", http.StatusBadRequest)\n\t\treturn\n\t}\n\n\tfriendRequest, err := h.friendUsecase.SendFriendRequest(r.Context(), userID, req.Username)\n\tif err != nil {\n\t\thandleFriendError(w, err)\n\t\treturn\n\t}\n\n\tw.Header().Set(\"Content-Type\", \"application/json\")\n\tw.WriteHeader(http.StatusCreated)\n\tjson.NewEncoder(w).Encode(friendRequest)\n}\n\nfunc (h *FriendHandler) GetPendingRequests(w http.ResponseWriter, r *http.Request) {\n\tuserID, ok := r.Context().Value(middleware.UserIDContextKey).(string)\n\tif !ok {\n\t\thttp.Error(w, \"Unauthorized\", http.StatusUnauthorized)\n\t\treturn\n\t}\n\n\trequests, err := h.friendUsecase.GetPendingRequests(r.Context(), userID)\n\tif err != nil {\n\t\thandleFriendError(w, err)\n\t\treturn\n\t}\n\n\tw.Header().Set(\"Content-Type\", \"application/json\")\n\tjson.NewEncoder(w).Encode(requests)\n}\n\nfunc (h *FriendHandler) AcceptRequest(w http.ResponseWriter, r *http.Request) {\n\tuserID, ok := r.Context().Value(middleware.UserIDContextKey).(string)\n\tif !ok {\n\t\thttp.Error(w, \"Unauthorized\", http.StatusUnauthorized)\n\t\treturn\n\t}\n\trequestID := chi.URLParam(r, \"requestID\")\n\n\tif err := h.friendUsecase.AcceptFriendRequest(r.Context(), userID, requestID); err != nil {\n\t\thandleFriendError(w, err)\n\t\treturn\n\t}\n\n\tw.WriteHeader(http.StatusNoContent)\n}\n\nfunc (h *FriendHandler) RejectRequest(w http.ResponseWriter, r *http.Request) {\n\tuserID, ok := r.Context().Value(middleware.UserIDContextKey).(string)\n\tif !ok {\n\t\thttp.Error(w, \"Unauthorized\", http.StatusUnauthorized)\n\t\treturn\n\t}\n\trequestID := chi.URLParam(r, \"requestID\")\n\n\tif err := h.friendUsecase.RejectFriendRequest(r.Context(), userID, requestID); err != nil {\n\t\thandleFriendError(w, err)\n\t\treturn\n\t}\n\n\tw.WriteHeader(http.StatusNoContent)\n}\n\nfunc (h *FriendHandler) Unfriend(w http.ResponseWriter, r *http.Request) {\n\tuserID, ok := r.Context().Value(middleware.UserIDContextKey).(string)\n\tif !ok {\n\t\thttp.Error(w, \"Unauthorized\", http.StatusUnauthorized)\n\t\treturn\n\t}\n\tfriendID := chi.URLParam(r, \"userID\")\n\n\tif err := h.friendUsecase.Unfriend(r.Context(), userID, friendID); err != nil {\n\t\thandleFriendError(w, err)\n\t\treturn\n\t}\n\n\tw.WriteHeader(http.StatusNoContent)\n}\n\nfunc (h *FriendHandler) ListFriends(w http.ResponseWriter, r *http.Request) {\n\tuserID, ok := r.Context().Value(middleware.UserIDContextKey).(string)\n\tif !ok {\n\t\thttp.Error(w, \"Unauthorized\", http.StatusUnauthorized)\n\t\treturn\n\t}\n\n\tfriends, err := h.friendUsecase.ListFriends(r.Context(), userID)\n\tif err != nil {\n\t\thandleFriendError(w, err)\n\t\treturn\n\t}\n\n\tw.Header().Set(\"Content-Type\", \"application/json\")\n\tjson.NewEncoder(w).Encode(friends)\n}\n\nfunc handleFriendError(w http.ResponseWriter, err error) {\n\tswitch {\n\tcase errors.Is(err, service.ErrFriendRequestInvalid),\n\t\terrors.Is(err, service.ErrFriendRequestYourself):\n\t\thttp.Error(w, err.Error(), http.StatusBadRequest)\n\tcase errors.Is(err, service.ErrUserNotFound):\n\t\thttp.Error(w, err.Error(), http.StatusNotFound)\n\tcase errors.Is(err, service.ErrFriendRequestExists),\n\t\terrors.Is(err, service.ErrAlreadyFriends):\n\t\thttp.Error(w, err.Error(), http.StatusConflict)\n\tcase errors.Is(err, service.ErrFriendRequestNotReceiver):\n\t\thttp.Error(w, err.Error(), http.StatusForbidden)\n\tdefault:\n\t\thttp.Error(w, \"Internal server error\", http.StatusInternalServerError)\n\t}\n}\n",
  "backend/internal/delivery/http/handler/group_handler.go": "package handler\n\nimport (\n\t\"chat-app/internal/delivery/http/middleware\"\n\t\"chat-app/internal/service\"\n\t\"chat-app/internal/usecase\"\n\t\"encoding/json\"\n\t\"errors\"\n\t\"net/http\"\n\n\t\"github.com/go-chi/chi/v5\"\n)\n\ntype GroupHandler struct {\n\tuc usecase.GroupUsecase\n}\n\nfunc NewGroupHandler(uc usecase.GroupUsecase) *GroupHandler {\n\treturn \u0026GroupHandler{uc: uc}\n}\n\nfunc (h *GroupHandler) CreateGroup(w http.ResponseWriter, r *http.Request) {\n\tuserID := r.Context().Value(middleware.UserIDContextKey).(string)\n\n\tif err := r.ParseMultipartForm(32 \u003c\u003c 20); err != nil { // 32MB max memory\n\t\thttp.Error(w, \"Failed to parse multipart form\", http.StatusBadRequest)\n\t\treturn\n\t}\n\n\tvar input usecase.CreateGroupInput\n\tinput.Handle = r.FormValue(\"handle\")\n\tinput.Name = r.FormValue(\"name\")\n\n\tfile, header, err := r.FormFile(\"photo\")\n\tif err != nil \u0026\u0026 !errors.Is(err, http.ErrMissingFile) {\n\t\thttp.Error(w, \"Failed to get photo from form\", http.StatusBadRequest)\n\t\treturn\n\t}\n\tif file != nil {\n\t\tdefer file.Close()\n\t}\n\n\tgroup, err := h.uc.CreateGroup(r.Context(), userID, input, file, header)\n\tif err != nil {\n\t\thandleGroupError(w, err)\n\t\treturn\n\t}\n\n\trespondWithJSON(w, http.StatusCreated, group)\n}\n\nfunc (h *GroupHandler) SearchGroups(w http.ResponseWriter, r *http.Request) {\n\tquery := r.URL.Query().Get(\"q\")\n\tif query == \"\" {\n\t\trespondWithJSON(w, http.StatusOK, []interface{}{})\n\t\treturn\n\t}\n\n\tgroups, err := h.uc.SearchGroups(r.Context(), query)\n\tif err != nil {\n\t\thandleGroupError(w, err)\n\t\treturn\n\t}\n\n\trespondWithJSON(w, http.StatusOK, groups)\n}\n\nfunc (h *GroupHandler) JoinGroup(w http.ResponseWriter, r *http.Request) {\n\tuserID := r.Context().Value(middleware.UserIDContextKey).(string)\n\thandle := chi.URLParam(r, \"handle\")\n\n\tgroup, err := h.uc.JoinGroup(r.Context(), userID, \"#\"+handle)\n\tif err != nil {\n\t\thandleGroupError(w, err)\n\t\treturn\n\t}\n\n\trespondWithJSON(w, http.StatusOK, group)\n}\n\nfunc (h *GroupHandler) GetGroupDetails(w http.ResponseWriter, r *http.Request) {\n\tgroupID := chi.URLParam(r, \"group_id\")\n\n\tdetails, err := h.uc.GetGroupDetails(r.Context(), groupID)\n\tif err != nil {\n\t\thandleGroupError(w, err)\n\t\treturn\n\t}\n\n\trespondWithJSON(w, http.StatusOK, details)\n}\n\nfunc (h *GroupHandler) UpdateGroup(w http.ResponseWriter, r *http.Request) {\n\tuserID := r.Context().Value(middleware.UserIDContextKey).(string)\n\tgroupID := chi.URLParam(r, \"group_id\")\n\n\tif err := r.ParseMultipartForm(32 \u003c\u003c 20); err != nil {\n\t\thttp.Error(w, \"Failed to parse multipart form\", http.StatusBadRequest)\n\t\treturn\n\t}\n\n\tvar input usecase.UpdateGroupInput\n\tif name := r.FormValue(\"name\"); name != \"\" {\n\t\tinput.Name = \u0026name\n\t}\n\n\tfile, header, err := r.FormFile(\"photo\")\n\tif err != nil \u0026\u0026 !errors.Is(err, http.ErrMissingFile) {\n\t\thttp.Error(w, \"Failed to get photo from form\", http.StatusBadRequest)\n\t\treturn\n\t}\n\tif file != nil {\n\t\tdefer file.Close()\n\t}\n\n\tgroup, err := h.uc.UpdateGroup(r.Context(), userID, groupID, input, file, header)\n\tif err != nil {\n\t\thandleGroupError(w, err)\n\t\treturn\n\t}\n\n\trespondWithJSON(w, http.StatusOK, group)\n}\n\nfunc (h *GroupHandler) TransferOwnership(w http.ResponseWriter, r *http.Request) {\n\tuserID := r.Context().Value(middleware.UserIDContextKey).(string)\n\tgroupID := chi.URLParam(r, \"group_id\")\n\n\tvar input struct {\n\t\tNewOwnerID string `json:\"new_owner_id\"`\n\t}\n\tif err := json.NewDecoder(r.Body).Decode(\u0026input); err != nil {\n\t\thttp.Error(w, \"Invalid request body\", http.StatusBadRequest)\n\t\treturn\n\t}\n\n\terr := h.uc.TransferOwnership(r.Context(), userID, groupID, input.NewOwnerID)\n\tif err != nil {\n\t\thandleGroupError(w, err)\n\t\treturn\n\t}\n\n\tw.WriteHeader(http.StatusNoContent)\n}\n\nfunc (h *GroupHandler) AddMember(w http.ResponseWriter, r *http.Request) {\n\tuserID := r.Context().Value(middleware.UserIDContextKey).(string)\n\tgroupID := chi.URLParam(r, \"group_id\")\n\n\tvar input struct {\n\t\tFriendID string `json:\"friend_id\"`\n\t}\n\tif err := json.NewDecoder(r.Body).Decode(\u0026input); err != nil {\n\t\thttp.Error(w, \"Invalid request body\", http.StatusBadRequest)\n\t\treturn\n\t}\n\n\terr := h.uc.AddMember(r.Context(), userID, groupID, input.FriendID)\n\tif err != nil {\n\t\thandleGroupError(w, err)\n\t\treturn\n\t}\n\n\tw.WriteHeader(http.StatusNoContent)\n}\n\nfunc (h *GroupHandler) RemoveMember(w http.ResponseWriter, r *http.Request) {\n\tuserID := r.Context().Value(middleware.UserIDContextKey).(string)\n\tgroupID := chi.URLParam(r, \"group_id\")\n\tmemberID := chi.URLParam(r, \"member_id\")\n\n\terr := h.uc.RemoveMember(r.Context(), userID, groupID, memberID)\n\tif err != nil {\n\t\thandleGroupError(w, err)\n\t\treturn\n\t}\n\n\tw.WriteHeader(http.StatusNoContent)\n}\n\nfunc (h *GroupHandler) LeaveGroup(w http.ResponseWriter, r *http.Request) {\n\tuserID := r.Context().Value(middleware.UserIDContextKey).(string)\n\tgroupID := chi.URLParam(r, \"group_id\")\n\n\terr := h.uc.LeaveGroup(r.Context(), userID, groupID)\n\tif err != nil {\n\t\thandleGroupError(w, err)\n\t\treturn\n\t}\n\n\tw.WriteHeader(http.StatusNoContent)\n}\n\nfunc (h *GroupHandler) ListMyGroups(w http.ResponseWriter, r *http.Request) {\n\tuserID := r.Context().Value(middleware.UserIDContextKey).(string)\n\n\tgroups, err := h.uc.ListUserGroups(r.Context(), userID)\n\tif err != nil {\n\t\thandleGroupError(w, err)\n\t\treturn\n\t}\n\n\trespondWithJSON(w, http.StatusOK, groups)\n}\n\nfunc handleGroupError(w http.ResponseWriter, err error) {\n\tswitch {\n\tcase errors.Is(err, service.ErrInvalidGroupHandle), errors.Is(err, service.ErrAddNotFriend), errors.Is(err, service.ErrTransferToNonMember), errors.Is(err, service.ErrTransferToSelf), errors.Is(err, service.ErrRemoveSelf):\n\t\thttp.Error(w, err.Error(), http.StatusBadRequest)\n\tcase errors.Is(err, service.ErrNotGroupOwner), errors.Is(err, service.ErrNotGroupMember):\n\t\thttp.Error(w, err.Error(), http.StatusForbidden)\n\tcase errors.Is(err, repository.ErrNotFound):\n\t\thttp.Error(w, \"Group not found\", http.StatusNotFound)\n\tcase errors.Is(err, repository.ErrGroupHandleExists), errors.Is(err, repository.ErrGroupMemberExists):\n\t\thttp.Error(w, err.Error(), http.StatusConflict)\n\tdefault:\n\t\thttp.Error(w, \"An internal error occurred\", http.StatusInternalServerError)\n\t}\n}\n",
  "backend/internal/delivery/http/handler/message_handler.go": "package handler\n\nimport (\n\t\"encoding/json\"\n\t\"net/http\"\n\t\"strconv\"\n\t\"time\"\n\n\t\"chat-app/backend/internal/delivery/http/middleware\"\n\t\"chat-app/backend/internal/usecase\"\n\n\t\"github.com/go-chi/chi/v5\"\n)\n\ntype MessageHandler struct {\n\tmessageUsecase usecase.MessageUsecase\n}\n\nfunc NewMessageHandler(uc usecase.MessageUsecase) *MessageHandler {\n\treturn \u0026MessageHandler{messageUsecase: uc}\n}\n\nfunc (h *MessageHandler) GetHistory(w http.ResponseWriter, r *http.Request) {\n\tuserID, ok := r.Context().Value(middleware.UserIDContextKey).(string)\n\tif !ok {\n\t\thttp.Error(w, \"Unauthorized\", http.StatusUnauthorized)\n\t\treturn\n\t}\n\n\tconversationID := chi.URLParam(r, \"conversation_id\")\n\tif conversationID == \"\" {\n\t\thttp.Error(w, \"Conversation ID is required\", http.StatusBadRequest)\n\t\treturn\n\t}\n\n\tbeforeStr := r.URL.Query().Get(\"before\")\n\tbefore := time.Now().UTC()\n\tif beforeStr != \"\" {\n\t\tvar err error\n\t\tbefore, err = time.Parse(time.RFC3339Nano, beforeStr)\n\t\tif err != nil {\n\t\t\thttp.Error(w, \"Invalid 'before' timestamp format\", http.StatusBadRequest)\n\t\t\treturn\n\t\t}\n\t}\n\n\tlimitStr := r.URL.Query().Get(\"limit\")\n\tlimit := 50 // Default limit\n\tif limitStr != \"\" {\n\t\tvar err error\n\t\tlimit, err = strconv.Atoi(limitStr)\n\t\tif err != nil || limit \u003c= 0 || limit \u003e 100 {\n\t\t\tlimit = 50 // Reset to default if invalid\n\t\t}\n\t}\n\n\tmessages, err := h.messageUsecase.GetMessageHistory(r.Context(), userID, conversationID, before, limit)\n\tif err != nil {\n\t\t// Here you might want to map specific service errors to HTTP status codes\n\t\thttp.Error(w, \"Failed to fetch message history\", http.StatusInternalServerError)\n\t\treturn\n\t}\n\n\tw.Header().Set(\"Content-Type\", \"application/json\")\n\tw.WriteHeader(http.StatusOK)\n\tjson.NewEncoder(w).Encode(messages)\n}\n",
  "backend/internal/delivery/http/handler/user_handler.go": "package handler\n\nimport (\n\t\"chat-app/internal/delivery/http/middleware\"\n\t\"chat-app/internal/service\"\n\t\"chat-app/internal/usecase\"\n\t\"encoding/json\"\n\t\"net/http\"\n\n\t\"github.com/go-chi/chi/v5\"\n)\n\ntype UserHandler struct {\n\tuserUsecase usecase.UserUsecase\n}\n\nfunc NewUserHandler(uc usecase.UserUsecase) *UserHandler {\n\treturn \u0026UserHandler{userUsecase: uc}\n}\n\nfunc (h *UserHandler) GetMyProfile(w http.ResponseWriter, r *http.Request) {\n\tuserID, ok := r.Context().Value(middleware.UserIDContextKey).(string)\n\tif !ok {\n\t\thttp.Error(w, \"Unauthorized\", http.StatusUnauthorized)\n\t\treturn\n\t}\n\n\tuser, err := h.userUsecase.GetProfile(r.Context(), userID)\n\tif err != nil {\n\t\thttp.Error(w, \"Internal server error\", http.StatusInternalServerError)\n\t\treturn\n\t}\n\tif user == nil {\n\t\thttp.Error(w, \"User not found\", http.StatusNotFound)\n\t\treturn\n\t}\n\n\tw.Header().Set(\"Content-Type\", \"application/json\")\n\tjson.NewEncoder(w).Encode(user)\n}\n\nfunc (h *UserHandler) GetUserProfile(w http.ResponseWriter, r *http.Request) {\n\tusername := chi.URLParam(r, \"username\")\n\tuser, err := h.userUsecase.GetUserByUsername(r.Context(), username)\n\tif err != nil {\n\t\thttp.Error(w, \"Internal server error\", http.StatusInternalServerError)\n\t\treturn\n\t}\n\tif user == nil {\n\t\thttp.Error(w, \"User not found\", http.StatusNotFound)\n\t\treturn\n\t}\n\n\tw.Header().Set(\"Content-Type\", \"application/json\")\n\tjson.NewEncoder(w).Encode(user)\n}\n\nfunc (h *UserHandler) UpdateMyProfile(w http.ResponseWriter, r *http.Request) {\n\tuserID, ok := r.Context().Value(middleware.UserIDContextKey).(string)\n\tif !ok {\n\t\thttp.Error(w, \"Unauthorized\", http.StatusUnauthorized)\n\t\treturn\n\t}\n\n\tif err := r.ParseMultipartForm(10 \u003c\u003c 20); err != nil { // 10 MB max memory\n\t\thttp.Error(w, \"Invalid request body: \"+err.Error(), http.StatusBadRequest)\n\t\treturn\n\t}\n\n\tvar updateInput usecase.UpdateUserInput\n\tusername := r.FormValue(\"username\")\n\tpassword := r.FormValue(\"password\")\n\n\tif username != \"\" {\n\t\tupdateInput.Username = \u0026username\n\t}\n\tif password != \"\" {\n\t\tupdateInput.Password = \u0026password\n\t}\n\n\tif updateInput.Username != nil || updateInput.Password != nil {\n\t\tif _, err := h.userUsecase.UpdateProfile(r.Context(), userID, updateInput); err != nil {\n\t\t\tswitch err {\n\t\t\tcase service.ErrUserExists, service.ErrInvalidUsername, service.ErrInvalidPassword:\n\t\t\t\thttp.Error(w, err.Error(), http.StatusBadRequest)\n\t\t\tdefault:\n\t\t\t\thttp.Error(w, \"Failed to update profile\", http.StatusInternalServerError)\n\t\t\t}\n\t\t\treturn\n\t\t}\n\t}\n\n\tfile, header, err := r.FormFile(\"profile_pic\")\n\tif err == nil {\n\t\tdefer file.Close()\n\t\tif _, err := h.userUsecase.UpdateProfilePicture(r.Context(), userID, file, header); err != nil {\n\t\t\tswitch err {\n\t\t\tcase service.ErrFileSizeExceeded, service.ErrInvalidFileType:\n\t\t\t\thttp.Error(w, err.Error(), http.StatusBadRequest)\n\t\t\tdefault:\n\t\t\t\thttp.Error(w, \"Failed to update profile picture\", http.StatusInternalServerError)\n\t\t\t}\n\t\t\treturn\n\t\t}\n\t} else if err != http.ErrMissingFile {\n\t\thttp.Error(w, \"Could not process file: \"+err.Error(), http.StatusBadRequest)\n\t\treturn\n\t}\n\n\tupdatedUser, err := h.userUsecase.GetProfile(r.Context(), userID)\n\tif err != nil {\n\t\thttp.Error(w, \"Internal server error\", http.StatusInternalServerError)\n\t\treturn\n\t}\n\n\tw.Header().Set(\"Content-Type\", \"application/json\")\n\tw.WriteHeader(http.StatusOK)\n\tjson.NewEncoder(w).Encode(updatedUser)\n}\n",
  "backend/internal/delivery/http/handler/websocket_handler.go": "package handler\n\nimport (\n\t\"chat-app/internal/delivery/http/middleware\"\n\tws \"chat-app/internal/delivery/websocket\"\n\t\"log\"\n\t\"net/http\"\n\n\t\"github.com/gorilla/websocket\"\n)\n\nvar upgrader = websocket.Upgrader{\n\tReadBufferSize:  1024,\n\tWriteBufferSize: 1024,\n\tCheckOrigin: func(r *http.Request) bool {\n\t\t// Allow all connections for development\n\t\treturn true\n\t},\n}\n\ntype WebSocketHandler struct {\n\thub *ws.Hub\n}\n\nfunc NewWebSocketHandler(hub *ws.Hub) *WebSocketHandler {\n\treturn \u0026WebSocketHandler{hub: hub}\n}\n\nfunc (h *WebSocketHandler) ServeWS(w http.ResponseWriter, r *http.Request) {\n\tuserID, ok := r.Context().Value(middleware.UserIDContextKey).(string)\n\tif !ok {\n\t\thttp.Error(w, \"Unauthorized\", http.StatusUnauthorized)\n\t\treturn\n\t}\n\n\tconn, err := upgrader.Upgrade(w, r, nil)\n\tif err != nil {\n\t\tlog.Println(err)\n\t\treturn\n\t}\n\n\tclient := \u0026ws.Client{\n\t\thub:    h.hub,\n\t\tconn:   conn,\n\t\tsend:   make(chan []byte, 256),\n\t\tuserID: userID,\n\t}\n\tclient.hub.register \u003c- client\n\n\t// Allow collection of memory referenced by the caller by doing all work in\n\t// new goroutines.\n\tgo client.writePump()\n\tgo client.readPump()\n}\n",
  "backend/internal/delivery/http/middleware/auth_middleware.go": "package middleware\n\nimport (\n\t\"context\"\n\t\"net/http\"\n\t\"strings\"\n\n\t\"chat-app/pkg/config\"\n\t\"chat-app/pkg/util\"\n)\n\ntype contextKey string\n\nconst UserIDContextKey = contextKey(\"userID\")\n\nfunc AuthMiddleware(cfg *config.Config) func(next http.Handler) http.Handler {\n\treturn func(next http.Handler) http.Handler {\n\t\treturn http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\t\tauthHeader := r.Header.Get(\"Authorization\")\n\t\t\tif authHeader == \"\" {\n\t\t\t\thttp.Error(w, \"Authorization header required\", http.StatusUnauthorized)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tparts := strings.Split(authHeader, \" \")\n\t\t\tif len(parts) != 2 || parts[0] != \"Bearer\" {\n\t\t\t\thttp.Error(w, \"Invalid authorization header format\", http.StatusUnauthorized)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\ttokenString := parts[1]\n\t\t\tclaims, err := util.ValidateToken(tokenString, cfg.JWTSecret)\n\t\t\tif err != nil {\n\t\t\t\thttp.Error(w, \"Invalid token\", http.StatusUnauthorized)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tctx := context.WithValue(r.Context(), UserIDContextKey, claims.UserID)\n\t\t\tnext.ServeHTTP(w, r.WithContext(ctx))\n\t\t})\n\t}\n}\n",
  "backend/internal/delivery/http/router.go": "package http\n\nimport (\n\t\"net/http\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"strings\"\n\n\t\"chat-app/backend/internal/delivery/http/handler\"\n\t\"chat-app/backend/internal/delivery/http/middleware\"\n\t\"chat-app/backend/internal/delivery/websocket\"\n\t\"chat-app/backend/internal/usecase\"\n\t\"chat-app/backend/pkg/config\"\n\n\t\"github.com/go-chi/chi/v5\"\n\tchiMiddleware \"github.com/go-chi/chi/v5/middleware\" // Changed alias to chiMiddleware\n)\n\nfunc NewRouter(\n\tcfg *config.Config,\n\tauthUsecase usecase.AuthUsecase,\n\tuserUsecase usecase.UserUsecase,\n\tfriendUsecase usecase.FriendUsecase,\n\tgroupUsecase usecase.GroupUsecase,\n\tmessageUsecase usecase.MessageUsecase, // Added messageUsecase\n\thub *websocket.Hub,\n) http.Handler {\n\tr := chi.NewRouter()\n\n\tr.Use(chiMiddleware.Logger)\n\tr.Use(chiMiddleware.Recoverer)\n\t// r.Use(chimiddleware.Heartbeat(\"/healthz\")) // Removed, replaced by explicit handler\n\n\tauthHandler := handler.NewAuthHandler(authUsecase)\n\tuserHandler := handler.NewUserHandler(userUsecase)\n\twsHandler := handler.NewWebSocketHandler(hub)\n\tfriendHandler := handler.NewFriendHandler(friendUsecase)\n\tgroupHandler := handler.NewGroupHandler(groupUsecase)\n\tmessageHandler := handler.NewMessageHandler(messageUsecase) // Added messageHandler\n\n\t// Public routes\n\tr.Get(\"/healthz\", func(w http.ResponseWriter, r *http.Request) { // Added healthz endpoint\n\t\tw.Write([]byte(\"OK\"))\n\t})\n\n\tr.Route(\"/api/v1\", func(r chi.Router) {\n\t\t// Auth\n\t\tr.Post(\"/auth/signup\", authHandler.SignUp)\n\t\tr.Post(\"/auth/login\", authHandler.Login)\n\t\tr.Post(\"/auth/refresh\", authHandler.Refresh)\n\n\t\t// Protected routes\n\t\tr.Group(func(r chi.Router) { // Grouped protected routes\n\t\t\tr.Use(middleware.AuthMiddleware(cfg))\n\n\t\t\t// WebSocket\n\t\t\tr.Get(\"/ws\", wsHandler.ServeWS)\n\n\t\t\t// Auth\n\t\t\tr.Post(\"/auth/logout\", authHandler.Logout)\n\n\t\t\t// User routes\n\t\t\tr.Get(\"/users/me\", userHandler.GetMyProfile)\n\t\t\tr.Put(\"/users/me\", userHandler.UpdateMyProfile)\n\t\t\tr.Get(\"/users/{username}\", userHandler.GetUserProfile)\n\n\t\t\t// Friend routes\n\t\t\tr.Post(\"/friends/requests\", friendHandler.SendRequest)\n\t\t\tr.Get(\"/friends/requests/pending\", friendHandler.GetPendingRequests)\n\t\t\tr.Put(\"/friends/requests/{request_id}/accept\", friendHandler.AcceptRequest)\n\t\t\tr.Put(\"/friends/requests/{request_id}/reject\", friendHandler.RejectRequest)\n\t\t\tr.Delete(\"/friends/{user_id}\", friendHandler.Unfriend)\n\t\t\tr.Get(\"/friends\", friendHandler.ListFriends)\n\n\t\t\t// Group routes\n\t\t\tr.Post(\"/groups\", groupHandler.CreateGroup)\n\t\t\tr.Get(\"/groups/search\", groupHandler.SearchGroups)\n\t\t\tr.Post(\"/groups/{handle}/join\", groupHandler.JoinGroup)\n\t\t\tr.Get(\"/groups/{group_id}\", groupHandler.GetGroupDetails)\n\t\t\tr.Put(\"/groups/{group_id}\", groupHandler.UpdateGroup)\n\t\t\tr.Put(\"/groups/{group_id}/transfer-ownership\", groupHandler.TransferOwnership)\n\t\t\tr.Post(\"/groups/{group_id}/members\", groupHandler.AddMember)\n\t\t\tr.Delete(\"/groups/{group_id}/members/{member_id}\", groupHandler.RemoveMember)\n\t\t\tr.Post(\"/groups/{group_id}/leave\", groupHandler.LeaveGroup)\n\t\t\tr.Get(\"/groups/me\", groupHandler.ListMyGroups)\n\n\t\t\t// Messages routes\n\t\t\tr.Get(\"/conversations/{conversation_id}/messages\", messageHandler.GetHistory) // Added message history route\n\t\t})\n\t})\n\n\t// Serve frontend files\n\tworkDir, _ := os.Getwd()\n\tfilesDir := http.Dir(filepath.Join(workDir, \"web\"))\n\tFileServer(r, \"/\", filesDir)\n\n\treturn r\n}\n\nfunc FileServer(r chi.Router, path string, root http.FileSystem) {\n\tif strings.ContainsAny(path, \"{}*\") {\n\t\tpanic(\"FileServer does not permit URL parameters.\")\n\t}\n\n\tfs := http.StripPrefix(path, http.FileServer(root))\n\n\tif path != \"/\" \u0026\u0026 path[len(path)-1] != '/' {\n\t\tr.Get(path, http.RedirectHandler(path+\"/\", http.StatusMovedPermanently).ServeHTTP)\n\t\tpath += \"/\"\n\t}\n\tpath += \"*\"\n\n\tr.Get(path, func(w http.ResponseWriter, r *http.Request) {\n\t\t// Check if the file exists\n\t\tf, err := root.Open(r.URL.Path)\n\t\tif os.IsNotExist(err) {\n\t\t\t// If not found, serve index.html for SPA routing\n\t\t\thttp.ServeFile(w, r, filepath.Join(string(root.(http.Dir)), \"templates/chat.html\")) // Updated path for SPA\n\t\t\treturn\n\t\t}\n\t\tif err != nil {\n\t\t\thttp.Error(w, http.StatusText(http.StatusInternalServerError), http.StatusInternalServerError)\n\t\t\treturn\n\t\t}\n\t\tf.Close()\n\t\tfs.ServeHTTP(w, r)\n\t})\n}",
  "backend/internal/delivery/websocket/client.go": "package websocket\n\nimport (\n\t\"bytes\"\n\t\"encoding/json\"\n\t\"log\"\n\t\"time\"\n\n\t\"github.com/gorilla/websocket\"\n)\n\nconst (\n\twriteWait      = 10 * time.Second\n\tpongWait       = 60 * time.Second\n\tpingPeriod     = (pongWait * 9) / 10\n\tmaxMessageSize = 512\n)\n\nvar (\n\tnewline = []byte{'\\n'}\n\tspace   = []byte{' '}\n)\n\n// Client is a middleman between the websocket connection and the hub.\ntype Client struct {\n\thub *Hub\n\n\t// The websocket connection.\n\tconn *websocket.Conn\n\n\t// Buffered channel of outbound messages.\n\tsend chan []byte\n\n\t// Authenticated user ID.\n\tuserID string\n}\n\n// IncomingEvent represents the structure of an event received from a client.\ntype IncomingEvent struct {\n\tType    string          `json:\"type\"`\n\tPayload json.RawMessage `json:\"payload\"`\n}\n\n// readPump pumps messages from the websocket connection to the hub.\nfunc (c *Client) readPump() {\n\tdefer func() {\n\t\tc.hub.unregister \u003c- c\n\t\tc.conn.Close()\n\t}()\n\tc.conn.SetReadLimit(maxMessageSize)\n\tc.conn.SetReadDeadline(time.Now().Add(pongWait))\n\tc.conn.SetPongHandler(func(string) error { c.conn.SetReadDeadline(time.Now().Add(pongWait)); return nil })\n\tfor {\n\t\t_, message, err := c.conn.ReadMessage()\n\t\tif err != nil {\n\t\t\tif websocket.IsUnexpectedCloseError(err, websocket.CloseGoingAway, websocket.CloseAbnormalClosure) {\n\t\t\t\tlog.Printf(\"error: %v\", err)\n\t\t\t}\n\t\t\tbreak\n\t\t}\n\t\tmessage = bytes.TrimSpace(bytes.Replace(message, newline, space, -1))\n\n\t\tvar event IncomingEvent\n\t\tif err := json.Unmarshal(message, \u0026event); err != nil {\n\t\t\tlog.Printf(\"error unmarshalling incoming event: %v\", err)\n\t\t\tcontinue\n\t\t}\n\n\t\tc.hub.broadcast \u003c- \u0026HubEvent{\n\t\t\tClient:  c,\n\t\t\tType:    event.Type,\n\t\t\tPayload: event.Payload,\n\t\t}\n\t}\n}\n\n// writePump pumps messages from the hub to the websocket connection.\nfunc (c *Client) writePump() {\n\tticker := time.NewTicker(pingPeriod)\n\tdefer func() {\n\t\tticker.Stop()\n\t\tc.conn.Close()\n\t}()\n\tfor {\n\t\tselect {\n\t\tcase message, ok := \u003c-c.send:\n\t\t\tc.conn.SetWriteDeadline(time.Now().Add(writeWait))\n\t\t\tif !ok {\n\t\t\t\t// The hub closed the channel.\n\t\t\t\tc.conn.WriteMessage(websocket.CloseMessage, []byte{})\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tw, err := c.conn.NextWriter(websocket.TextMessage)\n\t\t\tif err != nil {\n\t\t\t\treturn\n\t\t\t}\n\t\t\tw.Write(message)\n\n\t\t\t// Add queued chat messages to the current websocket message.\n\t\t\tn := len(c.send)\n\t\t\tfor i := 0; i \u003c n; i++ {\n\t\t\t\tw.Write(newline)\n\t\t\t\tw.Write(\u003c-c.send)\n\t\t\t}\n\n\t\t\tif err := w.Close(); err != nil {\n\t\t\t\treturn\n\t\t\t}\n\t\tcase \u003c-ticker.C:\n\t\t\tc.conn.SetWriteDeadline(time.Now().Add(writeWait))\n\t\t\tif err := c.conn.WriteMessage(websocket.PingMessage, nil); err != nil {\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t}\n}\n\n// SendEvent sends a domain event to the client.\nfunc (c *Client) SendEvent(event interface{}) {\n\tb, err := json.Marshal(event)\n\tif err != nil {\n\t\tlog.Printf(\"error marshalling event for client %s: %v\", c.userID, err)\n\t\treturn\n\t}\n\tselect {\n\tcase c.send \u003c- b:\n\tdefault:\n\t\tlog.Printf(\"client %s send channel full, dropping message\", c.userID)\n\t\tclose(c.send)\n\t\tdelete(c.hub.clients, c.userID)\n\t}\n}",
  "backend/internal/delivery/websocket/hub.go": "package websocket\n\nimport (\n\t\"context\"\n\t\"encoding/json\"\n\t\"log\"\n\n\t\"chat-app/backend/internal/usecase\"\n)\n\n// HubEvent represents an event received from a client via WebSocket.\ntype HubEvent struct {\n\tClient  *Client\n\tType    string\n\tPayload json.RawMessage\n}\n\n// Hub maintains the set of active clients and broadcasts messages to the\n// clients.\ntype Hub struct {\n\t// Registered clients.\n\tclients map[string]*Client\n\n\t// Inbound messages from the clients.\n\tbroadcast chan *HubEvent // Changed to HubEvent\n\n\t// Register requests from the clients.\n\tregister chan *Client\n\n\t// Unregister requests from clients.\n\tunregister chan *Client\n\n\teventUsecase   usecase.EventUsecase\n\tmessageUsecase usecase.MessageUsecase // Added messageUsecase\n}\n\nfunc NewHub(eventUsecase usecase.EventUsecase, messageUsecase usecase.MessageUsecase) *Hub { // Added messageUsecase parameter\n\treturn \u0026Hub{\n\t\tbroadcast:      make(chan *HubEvent), // Changed to HubEvent\n\t\tregister:       make(chan *Client),\n\t\tunregister:     make(chan *Client),\n\t\tclients:        make(map[string]*Client),\n\t\teventUsecase:   eventUsecase,\n\t\tmessageUsecase: messageUsecase, // Initialized messageUsecase\n\t}\n}\n\nfunc (h *Hub) Run() {\n\tfor {\n\t\tselect {\n\t\tcase client := \u003c-h.register:\n\t\t\th.clients[client.userID] = client\n\t\t\tlog.Printf(\"Client connected: %s. Total clients: %d\", client.userID, len(h.clients)) // Kept original log\n\t\t\t// TODO: Fetch and send undelivered events\n\t\tcase client := \u003c-h.unregister:\n\t\t\tif _, ok := h.clients[client.userID]; ok {\n\t\t\t\tdelete(h.clients, client.userID)\n\t\t\t\tclose(client.send)\n\t\t\t\tlog.Printf(\"Client disconnected: %s. Total clients: %d\", client.userID, len(h.clients)) // Kept original log\n\t\t\t}\n\t\tcase event := \u003c-h.broadcast: // Changed to HubEvent\n\t\t\th.handleIncomingEvent(event) // Delegated to new handler\n\t\t}\n\t}\n}\n\n// handleIncomingEvent processes events received from WebSocket clients.\nfunc (h *Hub) handleIncomingEvent(event *HubEvent) {\n\tctx := context.Background()\n\tswitch event.Type {\n\tcase \"send_message\":\n\t\tvar input usecase.SendMessageInput\n\t\tif err := json.Unmarshal(event.Payload, \u0026input); err != nil {\n\t\t\tlog.Printf(\"Error unmarshalling send_message payload: %v\", err)\n\t\t\t// Optionally send an error event back to the client\n\t\t\treturn\n\t\t}\n\n\t\tif _, err := h.messageUsecase.SendMessage(ctx, event.Client.userID, input); err != nil {\n\t\t\tlog.Printf(\"Error from SendMessage usecase: %v\", err)\n\t\t\t// Optionally send an error event back to the client\n\t\t}\n\tcase \"auth\":\n\t\t// This can be used for initial auth or re-auth\n\t\tlog.Printf(\"Client %s authenticated via WebSocket\", event.Client.userID)\n\tdefault:\n\t\tlog.Printf(\"Unknown incoming event type: %s\", event.Type)\n\t}\n}\n\n// BroadcastEvent sends an event to a specific user if they are online,\n// otherwise it buffers the event.\nfunc (h *Hub) BroadcastEvent(ctx context.Context, eventType string, payload interface{}, recipientID string) {\n\teventPayload, err := json.Marshal(payload)\n\tif err != nil {\n\t\tlog.Printf(\"Error marshalling event payload: %v\", err)\n\t\treturn\n\t}\n\n\tevent := map[string]interface{}{\n\t\t\"type\":    eventType,\n\t\t\"payload\": json.RawMessage(eventPayload),\n\t}\n\n\tif client, ok := h.clients[recipientID]; ok {\n\t\tclient.SendEvent(event)\n\t} else {\n\t\tif err := h.eventUsecase.CreateAndBufferEvent(ctx, eventType, payload, recipientID); err != nil {\n\t\t\tlog.Printf(\"Error buffering event for offline user %s: %v\", recipientID, err)\n\t\t}\n\t}\n}",
  "backend/internal/domain/event.go": "package domain\n\nimport (\n\t\"encoding/json\"\n\t\"time\"\n)\n\ntype Event struct {\n\tID          string          `json:\"id\"`\n\tType        string          `json:\"type\"`\n\tPayload     json.RawMessage `json:\"payload\"`\n\tRecipientID string          `json:\"recipient_id\"`\n\tIsDelivered bool            `json:\"is_delivered\"`\n\tCreatedAt   time.Time       `json:\"created_at\"`\n}\n",
  "backend/internal/domain/friend_request.go": "package domain\n\nimport \"time\"\n\ntype FriendRequest struct {\n\tID         string    `json:\"id\"`\n\tSenderID   string    `json:\"sender_id\"`\n\tReceiverID string    `json:\"receiver_id\"`\n\tStatus     string    `json:\"status\"` // e.g., \"pending\", \"accepted\", \"rejected\"\n\tCreatedAt  time.Time `json:\"created_at\"`\n\tUpdatedAt  time.Time `json:\"updated_at\"`\n\n\t// Fields for joining with users table\n\tSender   *User `json:\"sender,omitempty\"`\n\tReceiver *User `json:\"receiver,omitempty\"`\n}\n\nconst (\n\tFriendRequestStatusPending  = \"pending\"\n\tFriendRequestStatusAccepted = \"accepted\"\n\tFriendRequestStatusRejected = \"rejected\"\n)\n",
  "backend/internal/domain/group.go": "package domain\n\nimport \"time\"\n\nconst (\n\tGroupRoleOwner  = \"owner\"\n\tGroupRoleMember = \"member\"\n)\n\ntype Group struct {\n\tID            string    `json:\"id\"`\n\tHandle        string    `json:\"handle\"`\n\tName          string    `json:\"name\"`\n\tOwnerID       string    `json:\"owner_id\"`\n\tProfilePicURL string    `json:\"profile_pic_url\"`\n\tCreatedAt     time.Time `json:\"created_at\"`\n\tUpdatedAt     time.Time `json:\"updated_at\"`\n}\n\ntype GroupMember struct {\n\tGroupID   string    `json:\"group_id\"`\n\tUserID    string    `json:\"user_id\"`\n\tRole      string    `json:\"role\"`\n\tCreatedAt time.Time `json:\"created_at\"`\n\tUser      *User     `json:\"user,omitempty\"` // For joining\n}\n",
  "backend/internal/domain/message.go": "package domain\n\nimport \"time\"\n\ntype Message struct {\n\tID             string    `json:\"id\"`\n\tConversationID string    `json:\"conversation_id\"`\n\tSenderID       string    `json:\"sender_id\"`\n\tContent        string    `json:\"content\"`\n\tCreatedAt      time.Time `json:\"created_at\"`\n\tSender         *User     `json:\"sender,omitempty\"` // For including sender details\n}\n",
  "backend/internal/domain/session.go": "package domain\n\nimport \"time\"\n\ntype Session struct {\n\tID        string    `json:\"id\"` // This is the Refresh Token\n\tUserID    string    `json:\"user_id\"`\n\tExpiresAt time.Time `json:\"expires_at\"`\n\tCreatedAt time.Time `json:\"created_at\"`\n}\n",
  "backend/internal/domain/user.go": "package domain\n\nimport \"time\"\n\ntype User struct {\n\tID            string    `json:\"id\"`\n\tUsername      string    `json:\"username\"`\n\tPasswordHash  string    `json:\"-\"` // Do not expose password hash\n\tProfilePicURL string    `json:\"profile_pic_url\"`\n\tCreatedAt     time.Time `json:\"created_at\"`\n\tUpdatedAt     time.Time `json:\"updated_at\"`\n}\n",
  "backend/internal/repository/event_repo.go": "package repository\n\nimport (\n\t\"context\"\n\t\"chat-app/internal/domain\"\n)\n\ntype EventRepository interface {\n\t// Redis operations\n\tBufferEvent(ctx context.Context, event *domain.Event) error\n\tGetBufferedEventsForUser(ctx context.Context, userID string) ([]*domain.Event, error)\n\tClearUserBuffer(ctx context.Context, userID string) error\n\n\t// Postgres operations\n\tStoreEvents(ctx context.Context, events []*domain.Event) error\n\tGetUndeliveredEvents(ctx context.Context, userID string) ([]*domain.Event, error)\n\tMarkEventsAsDelivered(ctx context.Context, eventIDs []string) error\n}\n",
  "backend/internal/repository/file_repo.go": "package repository\n\nimport (\n\t\"context\"\n)\n\ntype FileRepository interface {\n\tSaveProfilePicture(ctx context.Context, fileData []byte, fileType string) (filename string, err error)\n}\n",
  "backend/internal/repository/friend_repo.go": "package repository\n\nimport (\n\t\"context\"\n\t\"errors\"\n\n\t\"chat-app/internal/domain\"\n)\n\nvar (\n\tErrFriendRequestExists = errors.New(\"friend request already exists\")\n\tErrNotFound            = errors.New(\"resource not found\")\n)\n\ntype FriendRepository interface {\n\tCreateRequest(ctx context.Context, req *domain.FriendRequest) error\n\tGetRequestByID(ctx context.Context, id string) (*domain.FriendRequest, error)\n\tUpdateRequestStatus(ctx context.Context, id, status string) error\n\tAreFriends(ctx context.Context, userID1, userID2 string) (bool, error)\n\tAddFriendship(ctx context.Context, userID1, userID2 string) error\n\tRemoveFriendship(ctx context.Context, userID1, userID2 string) error\n\tGetPendingRequests(ctx context.Context, userID string) ([]*domain.FriendRequest, error)\n\tGetFriendsByUserID(ctx context.Context, userID string) ([]*domain.User, error)\n\tHasPendingRequest(ctx context.Context, userID1, userID2 string) (bool, error)\n}\n",
  "backend/internal/repository/group_repo.go": "package repository\n\nimport (\n\t\"chat-app/internal/domain\"\n\t\"context\"\n)\n\nvar (\n\tErrGroupHandleExists = NewRepositoryError(\"group handle already exists\")\n\tErrGroupMemberExists = NewRepositoryError(\"user is already a member of this group\")\n)\n\ntype GroupRepository interface {\n\tCreate(ctx context.Context, group *domain.Group) error\n\tCreateMember(ctx context.Context, member *domain.GroupMember) error\n\tGetByID(ctx context.Context, id string) (*domain.Group, error)\n\tGetByHandle(ctx context.Context, handle string) (*domain.Group, error)\n\tUpdate(ctx context.Context, group *domain.Group) error\n\tFindMember(ctx context.Context, groupID, userID string) (*domain.GroupMember, error)\n\tRemoveMember(ctx context.Context, groupID, userID string) error\n\tGetMembersWithUserDetails(ctx context.Context, groupID string) ([]*domain.GroupMember, error)\n\tGetGroupsByUserID(ctx context.Context, userID string) ([]*domain.Group, error)\n\tSearchByHandle(ctx context.Context, query string) ([]*domain.Group, error)\n\tGetOldestMember(ctx context.Context, groupID, excludeUserID string) (*domain.GroupMember, error)\n}\n",
  "backend/internal/repository/message_repo.go": "package repository\n\nimport (\n\t\"context\"\n\t\"time\"\n\n\t\"chat-app/backend/internal/domain\"\n)\n\ntype MessageRepository interface {\n\tCreate(ctx context.Context, message *domain.Message) error\n\tGetByConversationID(ctx context.Context, conversationID string, before time.Time, limit int) ([]*domain.Message, error)\n}\n",
  "backend/internal/repository/session_repo.go": "package repository\n\nimport (\n\t\"context\"\n\t\"chat-app/internal/domain\"\n)\n\ntype SessionRepository interface {\n\tStore(ctx context.Context, session *domain.Session) error\n\tGetByID(ctx context.Context, id string) (*domain.Session, error)\n\tDelete(ctx context.Context, id string) error\n\tDeleteAllForUser(ctx context.Context, userID string) error\n}\n",
  "backend/internal/repository/user_repo.go": "package repository\n\nimport (\n\t\"chat-app/internal/domain\"\n\t\"context\"\n)\n\ntype UserRepository interface {\n\tCreate(ctx context.Context, user *domain.User) error\n\tGetByUsername(ctx context.Context, username string) (*domain.User, error)\n\tGetByID(ctx context.Context, id string) (*domain.User, error)\n\tUpdate(ctx context.Context, user *domain.User) error\n}\n",
  "backend/internal/service/auth_service.go": "package service\n\nimport (\n\t\"context\"\n\t\"errors\"\n\t\"regexp\"\n\t\"strings\"\n\t\"time\"\n\n\t\"chat-app/internal/domain\"\n\t\"chat-app/internal/repository\"\n\t\"chat-app/internal/usecase\"\n\t\"chat-app/pkg/config\"\n\t\"chat-app/pkg/util\"\n)\n\nvar (\n\tErrUserExists         = errors.New(\"user with this username already exists\")\n\tErrUserNotFound       = errors.New(\"user not found\")\n\tErrInvalidCredentials = errors.New(\"invalid username or password\")\n\tErrInvalidUsername    = errors.New(\"username format is invalid\")\n\tErrInvalidPassword    = errors.New(\"password is too short\")\n\tErrSessionNotFound    = errors.New(\"session not found or expired\")\n\tErrSessionExpired     = errors.New(\"session has expired\")\n)\n\ntype authService struct {\n\tuserRepo    repository.UserRepository\n\tsessionRepo repository.SessionRepository\n\tcfg         *config.Config\n}\n\nfunc NewAuthService(userRepo repository.UserRepository, sessionRepo repository.SessionRepository, cfg *config.Config) usecase.AuthUsecase {\n\treturn \u0026authService{\n\t\tuserRepo:    userRepo,\n\t\tsessionRepo: sessionRepo,\n\t\tcfg:         cfg,\n\t}\n}\n\nfunc (s *authService) SignUp(ctx context.Context, input usecase.SignUpInput) (*domain.User, error) {\n\t// Validate username\n\tif err := validateUsername(input.Username); err != nil {\n\t\treturn nil, err\n\t}\n\t// Validate password\n\tif len(input.Password) \u003c 8 {\n\t\treturn nil, ErrInvalidPassword\n\t}\n\n\t// Check if user exists\n\texistingUser, err := s.userRepo.GetByUsername(ctx, input.Username)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif existingUser != nil {\n\t\treturn nil, ErrUserExists\n\t}\n\n\t// Hash password\n\thashedPassword, err := util.HashPassword(input.Password)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Create user\n\tuser := \u0026domain.User{\n\t\tID:           util.NewUUID(),\n\t\tUsername:     strings.ToLower(input.Username),\n\t\tPasswordHash: hashedPassword,\n\t}\n\n\tif err := s.userRepo.Create(ctx, user); err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn user, nil\n}\n\nfunc (s *authService) Login(ctx context.Context, input usecase.LoginInput) (*usecase.AuthTokens, error) {\n\tuser, err := s.userRepo.GetByUsername(ctx, input.Username)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif user == nil {\n\t\treturn nil, ErrInvalidCredentials\n\t}\n\n\tif !util.CheckPasswordHash(input.Password, user.PasswordHash) {\n\t\treturn nil, ErrInvalidCredentials\n\t}\n\n\t// Single device policy: remove all old sessions\n\tif err := s.sessionRepo.DeleteAllForUser(ctx, user.ID); err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn s.createSession(ctx, user.ID)\n}\n\nfunc (s *authService) Refresh(ctx context.Context, refreshToken string) (*usecase.AuthTokens, error) {\n\tsession, err := s.sessionRepo.GetByID(ctx, refreshToken)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif session == nil {\n\t\treturn nil, ErrSessionNotFound\n\t}\n\n\tif session.ExpiresAt.Before(time.Now()) {\n\t\t// Clean up expired session\n\t\t_ = s.sessionRepo.Delete(ctx, session.ID)\n\t\treturn nil, ErrSessionExpired\n\t}\n\n\t// Sliding window: delete old session and create a new one\n\tif err := s.sessionRepo.Delete(ctx, session.ID); err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn s.createSession(ctx, session.UserID)\n}\n\nfunc (s *authService) Logout(ctx context.Context, refreshToken string) error {\n\treturn s.sessionRepo.Delete(ctx, refreshToken)\n}\n\nfunc (s *authService) createSession(ctx context.Context, userID string) (*usecase.AuthTokens, error) {\n\taccessToken, err := util.GenerateAccessToken(userID, s.cfg.JWTSecret, s.cfg.AccessTokenTTL)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tsession := \u0026domain.Session{\n\t\tID:        util.NewUUID(), // This is the refresh token\n\t\tUserID:    userID,\n\t\tExpiresAt: time.Now().Add(s.cfg.RefreshTokenTTL),\n\t}\n\n\tif err := s.sessionRepo.Store(ctx, session); err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn \u0026usecase.AuthTokens{\n\t\tAccessToken:  accessToken,\n\t\tRefreshToken: session.ID,\n\t}, nil\n}\n\nfunc validateUsername(username string) error {\n\tif len(username) \u003c 4 || len(username) \u003e 50 {\n\t\treturn ErrInvalidUsername\n\t}\n\t// Allowed characters: lowercase letters (a-z), digits (0-9), and underscore (_)\n\tmatch, _ := regexp.MatchString(\"^[a-z0-9_]+$\", username)\n\tif !match {\n\t\treturn ErrInvalidUsername\n\t}\n\treturn nil\n}\n",
  "backend/internal/service/event_service.go": "package service\n\nimport (\n\t\"chat-app/internal/domain\"\n\t\"chat-app/internal/repository\"\n\t\"chat-app/internal/usecase\"\n\t\"chat-app/pkg/util\"\n\t\"context\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"log\"\n\t\"time\"\n)\n\ntype eventService struct {\n\tredisEventRepo repository.EventRepository\n\tpgEventRepo    repository.EventRepository\n\tuserRepo       repository.UserRepository\n}\n\nfunc NewEventService(redisEventRepo, pgEventRepo repository.EventRepository, userRepo repository.UserRepository) usecase.EventUsecase {\n\treturn \u0026eventService{\n\t\tredisEventRepo: redisEventRepo,\n\t\tpgEventRepo:    pgEventRepo,\n\t\tuserRepo:       userRepo,\n\t}\n}\n\nfunc (s *eventService) CreateAndBufferEvent(ctx context.Context, eventType string, payload interface{}, recipientID string) error {\n\tpayloadJSON, err := json.Marshal(payload)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to marshal event payload: %w\", err)\n\t}\n\n\tevent := \u0026domain.Event{\n\t\tID:          util.NewUUID(),\n\t\tType:        eventType,\n\t\tPayload:     payloadJSON,\n\t\tRecipientID: recipientID,\n\t\tCreatedAt:   time.Now(),\n\t}\n\n\treturn s.redisEventRepo.BufferEvent(ctx, event)\n}\n\n// PersistBufferedEvents is intended to be run as a background job.\n// It's a simplified implementation. A real-world scenario would need more robust handling\n// of user lists, locking, and error recovery.\nfunc (s *eventService) PersistBufferedEvents(ctx context.Context) {\n\t// In a real app, you'd get a list of active users with buffered events.\n\t// For this project, we'll assume we can iterate through all users, which is not scalable.\n\t// This is a placeholder for a more complex logic.\n\tlog.Println(\"Background worker: Persisting buffered events from Redis to Postgres is not fully implemented for scalability. This is a conceptual placeholder.\")\n\t// A proper implementation would:\n\t// 1. Get a list of all user IDs that have buffered events (e.g., from a Redis SET).\n\t// 2. For each user:\n\t//    a. Get all buffered events.\n\t//    b. Store them in Postgres.\n\t//    c. Clear the Redis buffer for that user.\n\t// This needs careful implementation to avoid race conditions and data loss.\n}\n",
  "backend/internal/service/friend_service.go": "package service\n\nimport (\n\t\"context\"\n\t\"errors\"\n\t\"fmt\"\n\t\"time\"\n\n\t\"chat-app/internal/domain\"\n\t\"chat-app/internal/repository\"\n\t\"chat-app/internal/usecase\"\n\t\"chat-app/pkg/util\"\n)\n\nvar (\n\tErrFriendRequestYourself    = errors.New(\"cannot send friend request to yourself\")\n\tErrAlreadyFriends           = errors.New(\"users are already friends\")\n\tErrFriendRequestExists      = errors.New(\"a pending friend request already exists\")\n\tErrFriendRequestInvalid     = errors.New(\"invalid friend request\")\n\tErrFriendRequestNotReceiver = errors.New(\"only the receiver can accept or reject a friend request\")\n)\n\ntype friendService struct {\n\tfriendRepo repository.FriendRepository\n\tuserRepo   repository.UserRepository\n\teventUcase usecase.EventUsecase\n}\n\nfunc NewFriendService(friendRepo repository.FriendRepository, userRepo repository.UserRepository, eventUsecase usecase.EventUsecase) usecase.FriendUsecase {\n\treturn \u0026friendService{\n\t\tfriendRepo: friendRepo,\n\t\tuserRepo:   userRepo,\n\t\teventUcase: eventUsecase,\n\t}\n}\n\nfunc (s *friendService) SendFriendRequest(ctx context.Context, senderID, receiverUsername string) (*domain.FriendRequest, error) {\n\tsender, err := s.userRepo.GetByID(ctx, senderID)\n\tif err != nil || sender == nil {\n\t\treturn nil, fmt.Errorf(\"sender not found: %w\", err)\n\t}\n\n\treceiver, err := s.userRepo.GetByUsername(ctx, receiverUsername)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"error fetching receiver: %w\", err)\n\t}\n\tif receiver == nil {\n\t\treturn nil, ErrUserNotFound\n\t}\n\n\tif senderID == receiver.ID {\n\t\treturn nil, ErrFriendRequestYourself\n\t}\n\n\tareFriends, err := s.friendRepo.AreFriends(ctx, senderID, receiver.ID)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif areFriends {\n\t\treturn nil, ErrAlreadyFriends\n\t}\n\n\thasPending, err := s.friendRepo.HasPendingRequest(ctx, senderID, receiver.ID)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif hasPending {\n\t\treturn nil, ErrFriendRequestExists\n\t}\n\n\treq := \u0026domain.FriendRequest{\n\t\tID:         util.NewUUID(),\n\t\tSenderID:   senderID,\n\t\tReceiverID: receiver.ID,\n\t\tStatus:     domain.FriendRequestStatusPending,\n\t\tCreatedAt:  time.Now().UTC(),\n\t\tUpdatedAt:  time.Now().UTC(),\n\t}\n\n\tif err := s.friendRepo.CreateRequest(ctx, req); err != nil {\n\t\tif errors.Is(err, repository.ErrFriendRequestExists) {\n\t\t\treturn nil, ErrFriendRequestExists\n\t\t}\n\t\treturn nil, err\n\t}\n\n\t// Create event for receiver\n\teventPayload := map[string]interface{}{\n\t\t\"request_id\": req.ID,\n\t\t\"sender\": map[string]string{\n\t\t\t\"id\":              sender.ID,\n\t\t\t\"username\":        sender.Username,\n\t\t\t\"profile_pic_url\": sender.ProfilePicURL,\n\t\t},\n\t}\n\ts.eventUcase.CreateAndBufferEvent(ctx, \"friend_request_received\", eventPayload, receiver.ID)\n\n\treq.Sender = sender\n\treq.Receiver = receiver\n\treturn req, nil\n}\n\nfunc (s *friendService) AcceptFriendRequest(ctx context.Context, userID, requestID string) error {\n\treq, err := s.friendRepo.GetRequestByID(ctx, requestID)\n\tif err != nil {\n\t\tif errors.Is(err, repository.ErrNotFound) {\n\t\t\treturn ErrFriendRequestInvalid\n\t\t}\n\t\treturn err\n\t}\n\n\tif req.ReceiverID != userID {\n\t\treturn ErrFriendRequestNotReceiver\n\t}\n\n\tif req.Status != domain.FriendRequestStatusPending {\n\t\treturn ErrFriendRequestInvalid\n\t}\n\n\tif err := s.friendRepo.AddFriendship(ctx, req.SenderID, req.ReceiverID); err != nil {\n\t\treturn err\n\t}\n\n\tif err := s.friendRepo.UpdateRequestStatus(ctx, requestID, domain.FriendRequestStatusAccepted); err != nil {\n\t\t// Attempt to rollback friendship, but don't fail the whole operation if this fails\n\t\t_ = s.friendRepo.RemoveFriendship(ctx, req.SenderID, req.ReceiverID)\n\t\treturn err\n\t}\n\n\t// Create event for sender\n\treceiver, err := s.userRepo.GetByID(ctx, userID)\n\tif err != nil {\n\t\t// Log error but continue\n\t\tfmt.Printf(\"Error fetching receiver user for event: %v\\n\", err)\n\t} else {\n\t\teventPayload := map[string]interface{}{\n\t\t\t\"request_id\": requestID,\n\t\t\t\"receiver\": map[string]string{\n\t\t\t\t\"id\":              receiver.ID,\n\t\t\t\t\"username\":        receiver.Username,\n\t\t\t\t\"profile_pic_url\": receiver.ProfilePicURL,\n\t\t\t},\n\t\t}\n\t\ts.eventUcase.CreateAndBufferEvent(ctx, \"friend_request_accepted\", eventPayload, req.SenderID)\n\t}\n\n\treturn nil\n}\n\nfunc (s *friendService) RejectFriendRequest(ctx context.Context, userID, requestID string) error {\n\treq, err := s.friendRepo.GetRequestByID(ctx, requestID)\n\tif err != nil {\n\t\tif errors.Is(err, repository.ErrNotFound) {\n\t\t\treturn ErrFriendRequestInvalid\n\t\t}\n\t\treturn err\n\t}\n\n\tif req.ReceiverID != userID \u0026\u0026 req.SenderID != userID {\n\t\treturn ErrFriendRequestNotReceiver // Or a more generic \"not authorized\"\n\t}\n\n\tif req.Status != domain.FriendRequestStatusPending {\n\t\treturn ErrFriendRequestInvalid\n\t}\n\n\tif err := s.friendRepo.UpdateRequestStatus(ctx, requestID, domain.FriendRequestStatusRejected); err != nil {\n\t\treturn err\n\t}\n\n\t// Create event for the other user\n\tvar otherUserID string\n\tif userID == req.SenderID {\n\t\totherUserID = req.ReceiverID\n\t} else {\n\t\totherUserID = req.SenderID\n\t}\n\n\trejecter, err := s.userRepo.GetByID(ctx, userID)\n\tif err != nil {\n\t\tfmt.Printf(\"Error fetching rejecting user for event: %v\\n\", err)\n\t} else {\n\t\teventPayload := map[string]interface{}{\n\t\t\t\"request_id\": requestID,\n\t\t\t\"user\": map[string]string{\n\t\t\t\t\"id\":       rejecter.ID,\n\t\t\t\t\"username\": rejecter.Username,\n\t\t\t},\n\t\t}\n\t\ts.eventUcase.CreateAndBufferEvent(ctx, \"friend_request_rejected\", eventPayload, otherUserID)\n\t}\n\n\treturn nil\n}\n\nfunc (s *friendService) Unfriend(ctx context.Context, userID, friendID string) error {\n\tareFriends, err := s.friendRepo.AreFriends(ctx, userID, friendID)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif !areFriends {\n\t\treturn nil // Idempotent\n\t}\n\n\tif err := s.friendRepo.RemoveFriendship(ctx, userID, friendID); err != nil {\n\t\treturn err\n\t}\n\n\t// Create event for the unfriended user\n\tunfriender, err := s.userRepo.GetByID(ctx, userID)\n\tif err != nil {\n\t\tfmt.Printf(\"Error fetching unfriender user for event: %v\\n\", err)\n\t} else {\n\t\teventPayload := map[string]interface{}{\n\t\t\t\"user\": map[string]string{\n\t\t\t\t\"id\":       unfriender.ID,\n\t\t\t\t\"username\": unfriender.Username,\n\t\t\t},\n\t\t}\n\t\ts.eventUcase.CreateAndBufferEvent(ctx, \"unfriended\", eventPayload, friendID)\n\t}\n\n\treturn nil\n}\n\nfunc (s *friendService) GetPendingRequests(ctx context.Context, userID string) ([]*domain.FriendRequest, error) {\n\treturn s.friendRepo.GetPendingRequests(ctx, userID)\n}\n\nfunc (s *friendService) ListFriends(ctx context.Context, userID string) ([]*domain.User, error) {\n\treturn s.friendRepo.GetFriendsByUserID(ctx, userID)\n}\n",
  "backend/internal/service/group_service.go": "package service\n\nimport (\n\t\"chat-app/internal/domain\"\n\t\"chat-app/internal/repository\"\n\t\"chat-app/internal/usecase\"\n\t\"chat-app/pkg/util\"\n\t\"context\"\n\t\"errors\"\n\t\"fmt\"\n\t\"mime/multipart\"\n\t\"regexp\"\n\t\"strings\"\n)\n\nvar (\n\tErrInvalidGroupHandle   = errors.New(\"invalid group handle format\")\n\tErrNotGroupOwner        = errors.New(\"only the group owner can perform this action\")\n\tErrNotGroupMember       = errors.New(\"user is not a member of this group\")\n\tErrCannotRemoveOwner    = errors.New(\"group owner cannot be removed\")\n\tErrCannotLeaveAsOwner   = errors.New(\"owner must transfer ownership before leaving\")\n\tErrAddNotFriend         = errors.New(\"you can only add your friends to a group\")\n\tErrTransferToNonMember  = errors.New(\"can only transfer ownership to a group member\")\n\tErrTransferToSelf       = errors.New(\"cannot transfer ownership to yourself\")\n\tErrRemoveSelf           = errors.New(\"cannot remove yourself from a group, use leave group instead\")\n\tErrLastMemberCannotLeave = errors.New(\"last member cannot leave the group, it will be deleted\")\n)\n\nvar groupHandleRegex = regexp.MustCompile(`^[a-z0-9_]{4,50}$`)\n\ntype groupService struct {\n\tgroupRepo  repository.GroupRepository\n\tuserRepo   repository.UserRepository\n\tfriendRepo repository.FriendRepository\n\tfileRepo   repository.FileRepository\n\teventUsecase usecase.EventUsecase\n}\n\nfunc NewGroupService(\n\tgroupRepo repository.GroupRepository,\n\tuserRepo repository.UserRepository,\n\tfriendRepo repository.FriendRepository,\n\tfileRepo repository.FileRepository,\n\teventUsecase usecase.EventUsecase,\n) usecase.GroupUsecase {\n\treturn \u0026groupService{\n\t\tgroupRepo:  groupRepo,\n\t\tuserRepo:   userRepo,\n\t\tfriendRepo: friendRepo,\n\t\tfileRepo:   fileRepo,\n\t\teventUsecase: eventUsecase,\n\t}\n}\n\nfunc (s *groupService) validateGroupHandle(handle string) error {\n\tif !strings.HasPrefix(handle, \"#\") {\n\t\treturn ErrInvalidGroupHandle\n\t}\n\tcleanHandle := strings.TrimPrefix(handle, \"#\")\n\tif !groupHandleRegex.MatchString(cleanHandle) {\n\t\treturn ErrInvalidGroupHandle\n\t}\n\treturn nil\n}\n\nfunc (s *groupService) CreateGroup(ctx context.Context, userID string, input usecase.CreateGroupInput, file multipart.File, fileHeader *multipart.FileHeader) (*domain.Group, error) {\n\tif err := s.validateGroupHandle(input.Handle); err != nil {\n\t\treturn nil, err\n\t}\n\n\tvar picURL string\n\tif file != nil {\n\t\t// Re-use user profile picture logic for group pictures\n\t\turl, err := NewUserService(s.userRepo, s.fileRepo).UpdateProfilePicture(ctx, \"\", file, fileHeader)\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"failed to save group picture: %w\", err)\n\t\t}\n\t\tpicURL = url\n\t}\n\n\tgroup := \u0026domain.Group{\n\t\tID:            util.NewUUID(),\n\t\tHandle:        input.Handle,\n\t\tName:          input.Name,\n\t\tOwnerID:       userID,\n\t\tProfilePicURL: picURL,\n\t}\n\n\tif err := s.groupRepo.Create(ctx, group); err != nil {\n\t\treturn nil, err\n\t}\n\n\townerMember := \u0026domain.GroupMember{\n\t\tGroupID: group.ID,\n\t\tUserID:  userID,\n\t\tRole:    domain.GroupRoleOwner,\n\t}\n\tif err := s.groupRepo.CreateMember(ctx, ownerMember); err != nil {\n\t\t// TODO: Add transaction to rollback group creation\n\t\treturn nil, err\n\t}\n\n\treturn group, nil\n}\n\nfunc (s *groupService) GetGroupDetails(ctx context.Context, groupID string) (*usecase.GroupDetails, error) {\n\tgroup, err := s.groupRepo.GetByID(ctx, groupID)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tmembers, err := s.groupRepo.GetMembersWithUserDetails(ctx, groupID)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn \u0026usecase.GroupDetails{\n\t\tGroup:   group,\n\t\tMembers: members,\n\t}, nil\n}\n\nfunc (s *groupService) UpdateGroup(ctx context.Context, userID, groupID string, input usecase.UpdateGroupInput, file multipart.File, fileHeader *multipart.FileHeader) (*domain.Group, error) {\n\tgroup, err := s.groupRepo.GetByID(ctx, groupID)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tif group.OwnerID != userID {\n\t\treturn nil, ErrNotGroupOwner\n\t}\n\n\tif input.Name != nil {\n\t\tgroup.Name = *input.Name\n\t}\n\n\tif file != nil {\n\t\turl, err := NewUserService(s.userRepo, s.fileRepo).UpdateProfilePicture(ctx, \"\", file, fileHeader)\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"failed to update group picture: %w\", err)\n\t\t}\n\t\tgroup.ProfilePicURL = url\n\t}\n\n\tif err := s.groupRepo.Update(ctx, group); err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn group, nil\n}\n\nfunc (s *groupService) SearchGroups(ctx context.Context, query string) ([]*domain.Group, error) {\n\treturn s.groupRepo.SearchByHandle(ctx, query)\n}\n\nfunc (s *groupService) JoinGroup(ctx context.Context, userID, groupHandle string) (*domain.Group, error) {\n\tgroup, err := s.groupRepo.GetByHandle(ctx, groupHandle)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tmember := \u0026domain.GroupMember{\n\t\tGroupID: group.ID,\n\t\tUserID:  userID,\n\t\tRole:    domain.GroupRoleMember,\n\t}\n\n\tif err := s.groupRepo.CreateMember(ctx, member); err != nil {\n\t\tif errors.Is(err, repository.ErrGroupMemberExists) {\n\t\t\treturn group, nil // Idempotent: already a member, return success\n\t\t}\n\t\treturn nil, err\n\t}\n\n\treturn group, nil\n}\n\nfunc (s *groupService) LeaveGroup(ctx context.Context, userID, groupID string) error {\n\tgroup, err := s.groupRepo.GetByID(ctx, groupID)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif group.OwnerID == userID {\n\t\t// Check for other members\n\t\toldestMember, err := s.groupRepo.GetOldestMember(ctx, groupID, userID)\n\t\tif err != nil {\n\t\t\tif errors.Is(err, repository.ErrNotFound) {\n\t\t\t\t// This is the last member, they can't leave.\n\t\t\t\t// In a real app, this might trigger group deletion.\n\t\t\t\treturn ErrLastMemberCannotLeave\n\t\t\t}\n\t\t\treturn err\n\t\t}\n\t\t// Auto-transfer ownership\n\t\tif err := s.TransferOwnership(ctx, userID, groupID, oldestMember.UserID); err != nil {\n\t\t\treturn fmt.Errorf(\"failed to auto-transfer ownership: %w\", err)\n\t\t}\n\t}\n\n\treturn s.groupRepo.RemoveMember(ctx, groupID, userID)\n}\n\nfunc (s *groupService) AddMember(ctx context.Context, currentUserID, groupID, friendID string) error {\n\t// 1. Check if current user is a member of the group\n\t_, err := s.groupRepo.FindMember(ctx, groupID, currentUserID)\n\tif err != nil {\n\t\tif errors.Is(err, repository.ErrNotFound) {\n\t\t\treturn ErrNotGroupMember\n\t\t}\n\t\treturn err\n\t}\n\n\t// 2. Check if the user to be added is a friend of the current user\n\tareFriends, err := s.friendRepo.AreFriends(ctx, currentUserID, friendID)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif !areFriends {\n\t\treturn ErrAddNotFriend\n\t}\n\n\t// 3. Add the friend to the group\n\tnewMember := \u0026domain.GroupMember{\n\t\tGroupID: groupID,\n\t\tUserID:  friendID,\n\t\tRole:    domain.GroupRoleMember,\n\t}\n\tif err := s.groupRepo.CreateMember(ctx, newMember); err != nil {\n\t\tif errors.Is(err, repository.ErrGroupMemberExists) {\n\t\t\treturn nil // Idempotent\n\t\t}\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\nfunc (s *groupService) RemoveMember(ctx context.Context, ownerID, groupID, memberID string) error {\n\tif ownerID == memberID {\n\t\treturn ErrRemoveSelf\n\t}\n\n\tgroup, err := s.groupRepo.GetByID(ctx, groupID)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif group.OwnerID != ownerID {\n\t\treturn ErrNotGroupOwner\n\t}\n\n\tif group.OwnerID == memberID {\n\t\treturn ErrCannotRemoveOwner\n\t}\n\n\treturn s.groupRepo.RemoveMember(ctx, groupID, memberID)\n}\n\nfunc (s *groupService) TransferOwnership(ctx context.Context, currentOwnerID, groupID, newOwnerID string) error {\n\tif currentOwnerID == newOwnerID {\n\t\treturn ErrTransferToSelf\n\t}\n\n\tgroup, err := s.groupRepo.GetByID(ctx, groupID)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif group.OwnerID != currentOwnerID {\n\t\treturn ErrNotGroupOwner\n\t}\n\n\t// Check if new owner is a member\n\t_, err = s.groupRepo.FindMember(ctx, groupID, newOwnerID)\n\tif err != nil {\n\t\tif errors.Is(err, repository.ErrNotFound) {\n\t\t\treturn ErrTransferToNonMember\n\t\t}\n\t\treturn err\n\t}\n\n\t// Perform transfer in a transaction (conceptual)\n\t// 1. Update group owner_id\n\tgroup.OwnerID = newOwnerID\n\tif err := s.groupRepo.Update(ctx, group); err != nil {\n\t\treturn err\n\t}\n\n\t// 2. Update roles in group_members table\n\t// This would require a new repo method, e.g., UpdateMemberRole\n\t// For simplicity, we'll assume this is handled or not strictly required by the current schema\n\t// A more robust implementation would have a transaction and update both tables.\n\n\treturn nil\n}\n\nfunc (s *groupService) ListUserGroups(ctx context.Context, userID string) ([]*domain.Group, error) {\n\treturn s.groupRepo.GetGroupsByUserID(ctx, userID)\n}\n",
  "backend/internal/service/message_service.go": "package service\n\nimport (\n\t\"context\"\n\t\"errors\"\n\t\"sort\"\n\t\"strings\"\n\t\"time\"\n\t\"unicode/utf8\"\n\n\t\"chat-app/backend/internal/domain\"\n\t\"chat-app/backend/internal/repository\"\n\t\"chat-app/backend/internal/usecase\"\n\t\"chat-app/backend/pkg/util\"\n)\n\nvar (\n\tErrMessageTooLong      = errors.New(\"message content exceeds 200 characters\")\n\tErrInvalidConversation = errors.New(\"invalid conversation or user not a member\")\n)\n\ntype messageService struct {\n\tmessageRepo repository.MessageRepository\n\tuserRepo    repository.UserRepository\n\tgroupRepo   repository.GroupRepository\n\teventUsecase  usecase.EventUsecase\n}\n\nfunc NewMessageService(\n\tmessageRepo repository.MessageRepository,\n\tuserRepo repository.UserRepository,\n\tgroupRepo repository.GroupRepository,\n\teventUsecase usecase.EventUsecase,\n) usecase.MessageUsecase {\n\treturn \u0026messageService{\n\t\tmessageRepo: messageRepo,\n\t\tuserRepo:    userRepo,\n\t\tgroupRepo:   groupRepo,\n\t\teventUsecase:  eventUsecase,\n\t}\n}\n\nfunc (s *messageService) SendMessage(ctx context.Context, senderID string, input usecase.SendMessageInput) (*domain.Message, error) {\n\tif utf8.RuneCountInString(input.Content) \u003e 200 {\n\t\treturn nil, ErrMessageTooLong\n\t}\n\n\trecipients, err := s.getConversationRecipients(ctx, senderID, input.ConversationID)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tsender, err := s.userRepo.GetByID(ctx, senderID)\n\tif err != nil || sender == nil {\n\t\treturn nil, ErrUserNotFound\n\t}\n\n\tmessage := \u0026domain.Message{\n\t\tID:             util.NewUUID(),\n\t\tConversationID: input.ConversationID,\n\t\tSenderID:       senderID,\n\t\tContent:        input.Content,\n\t\tCreatedAt:      time.Now().UTC(),\n\t\tSender: \u0026domain.User{\n\t\t\tID:            sender.ID,\n\t\t\tUsername:      sender.Username,\n\t\t\tProfilePicURL: sender.ProfilePicURL,\n\t\t},\n\t}\n\n\tif err := s.messageRepo.Create(ctx, message); err != nil {\n\t\treturn nil, err\n\t}\n\n\tfor _, recipientID := range recipients {\n\t\ts.eventUsecase.CreateAndBufferEvent(ctx, \"new_message\", message, recipientID)\n\t}\n\n\treturn message, nil\n}\n\nfunc (s *messageService) GetMessageHistory(ctx context.Context, userID, conversationID string, before time.Time, limit int) ([]*domain.Message, error) {\n\tisMember, err := s.isUserConversationMember(ctx, userID, conversationID)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif !isMember {\n\t\treturn nil, ErrInvalidConversation\n\t}\n\n\treturn s.messageRepo.GetByConversationID(ctx, conversationID, before, limit)\n}\n\nfunc (s *messageService) getConversationRecipients(ctx context.Context, senderID, conversationID string) ([]string, error) {\n\t// Check if it's a group conversation\n\tif _, err := util.ParseUUID(conversationID); err == nil {\n\t\tgroup, err := s.groupRepo.GetByID(ctx, conversationID)\n\t\tif err != nil {\n\t\t\treturn nil, ErrInvalidConversation\n\t\t}\n\t\tmembers, err := s.groupRepo.GetMembersWithUserDetails(ctx, group.ID)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\tvar recipientIDs []string\n\t\tisSenderMember := false\n\t\tfor _, member := range members {\n\t\t\tif member.UserID == senderID {\n\t\t\t\tisSenderMember = true\n\t\t\t} else {\n\t\t\t\trecipientIDs = append(recipientIDs, member.UserID)\n\t\t\t}\n\t\t}\n\n\t\tif !isSenderMember {\n\t\t\treturn nil, ErrInvalidConversation\n\t\t}\n\t\treturn recipientIDs, nil\n\t}\n\n\t// Assume it's a P2P conversation\n\tids := strings.Split(conversationID, \":\")\n\tif len(ids) != 2 {\n\t\treturn nil, ErrInvalidConversation\n\t}\n\tuser1ID, user2ID := ids[0], ids[1]\n\n\tif senderID != user1ID \u0026\u0026 senderID != user2ID {\n\t\treturn nil, ErrInvalidConversation\n\t}\n\n\tvar recipientID string\n\tif senderID == user1ID {\n\t\trecipientID = user2ID\n\t} else {\n\t\trecipientID = user1ID\n\t}\n\n\treturn []string{recipientID}, nil\n}\n\nfunc (s *messageService) isUserConversationMember(ctx context.Context, userID, conversationID string) (bool, error) {\n\t// Check if it's a group conversation\n\tif _, err := util.ParseUUID(conversationID); err == nil {\n\t\tmember, err := s.groupRepo.FindMember(ctx, conversationID, userID)\n\t\tif err != nil \u0026\u0026 err != repository.ErrNotFound {\n\t\t\treturn false, err\n\t\t}\n\t\treturn member != nil, nil\n\t}\n\n\t// Assume it's a P2P conversation\n\tids := strings.Split(conversationID, \":\")\n\tif len(ids) != 2 {\n\t\treturn false, nil // Invalid format, so not a member\n\t}\n\treturn userID == ids[0] || userID == ids[1], nil\n}\n",
  "backend/internal/service/user_service.go": "package service\n\nimport (\n\t\"chat-app/internal/domain\"\n\t\"chat-app/internal/repository\"\n\t\"chat-app/internal/usecase\"\n\t\"chat-app/pkg/util\"\n\t\"context\"\n\t\"errors\"\n\t\"io\"\n\t\"mime/multipart\"\n\t\"regexp\"\n)\n\nvar (\n\tErrProfileUpdateFailed = errors.New(\"profile update failed\")\n\tErrInvalidFileType     = errors.New(\"invalid file type for profile picture, allowed: png, jpg, jpeg, webp\")\n\tErrFileSizeExceeded    = errors.New(\"file size exceeds the 200KB limit\")\n)\n\ntype userService struct {\n\tuserRepo repository.UserRepository\n\tfileRepo repository.FileRepository\n}\n\nfunc NewUserService(userRepo repository.UserRepository, fileRepo repository.FileRepository) usecase.UserUsecase {\n\treturn \u0026userService{\n\t\tuserRepo: userRepo,\n\t\tfileRepo: fileRepo,\n\t}\n}\n\nfunc (s *userService) GetProfile(ctx context.Context, userID string) (*domain.User, error) {\n\treturn s.userRepo.GetByID(ctx, userID)\n}\n\nfunc (s *userService) GetUserByUsername(ctx context.Context, username string) (*domain.User, error) {\n\treturn s.userRepo.GetByUsername(ctx, username)\n}\n\nfunc (s *userService) UpdateProfile(ctx context.Context, userID string, input usecase.UpdateUserInput) (*domain.User, error) {\n\tuser, err := s.userRepo.GetByID(ctx, userID)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif user == nil {\n\t\treturn nil, ErrUserNotFound\n\t}\n\n\tif input.Username != nil {\n\t\tif err := validateUsername(*input.Username); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\texistingUser, err := s.userRepo.GetByUsername(ctx, *input.Username)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tif existingUser != nil \u0026\u0026 existingUser.ID != userID {\n\t\t\treturn nil, ErrUserExists\n\t\t}\n\t\tuser.Username = *input.Username\n\t}\n\n\tif input.Password != nil {\n\t\tif len(*input.Password) \u003c 8 {\n\t\t\treturn nil, ErrInvalidPassword\n\t\t}\n\t\thashedPassword, err := util.HashPassword(*input.Password)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tuser.PasswordHash = hashedPassword\n\t}\n\n\tif err := s.userRepo.Update(ctx, user); err != nil {\n\t\treturn nil, ErrProfileUpdateFailed\n\t}\n\n\treturn user, nil\n}\n\nfunc (s *userService) UpdateProfilePicture(ctx context.Context, userID string, file multipart.File, fileHeader *multipart.FileHeader) (string, error) {\n\tif fileHeader.Size \u003e 200*1024 { // 200 KB\n\t\treturn \"\", ErrFileSizeExceeded\n\t}\n\n\tcontentType := fileHeader.Header.Get(\"Content-Type\")\n\tallowedTypes := []string{\"image/png\", \"image/jpeg\", \"image/jpg\", \"image/webp\"}\n\tisValidType := false\n\tfor _, t := range allowedTypes {\n\t\tif contentType == t {\n\t\t\tisValidType = true\n\t\t\tbreak\n\t\t}\n\t}\n\tif !isValidType {\n\t\treturn \"\", ErrInvalidFileType\n\t}\n\n\tfileBytes, err := io.ReadAll(file)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\tfilename, err := s.fileRepo.SaveProfilePicture(ctx, fileBytes, contentType)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\tuser, err := s.userRepo.GetByID(ctx, userID)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\tif user == nil {\n\t\treturn \"\", ErrUserNotFound\n\t}\n\n\tuser.ProfilePicURL = \"/uploads/\" + filename\n\tif err := s.userRepo.Update(ctx, user); err != nil {\n\t\treturn \"\", ErrProfileUpdateFailed\n\t}\n\n\treturn user.ProfilePicURL, nil\n}\n\nfunc validateUsername(username string) error {\n\tif len(username) \u003c 4 || len(username) \u003e 50 {\n\t\treturn ErrInvalidUsername\n\t}\n\tmatch, _ := regexp.MatchString(\"^[a-z0-9_]+$\")\n\tif !match {\n\t\treturn ErrInvalidUsername\n\t}\n\treturn nil\n}\n",
  "backend/internal/usecase/auth_ucase.go": "package usecase\n\nimport (\n\t\"context\"\n\t\"chat-app/internal/domain\"\n)\n\ntype SignUpInput struct {\n\tUsername string `json:\"username\"`\n\tPassword string `json:\"password\"`\n}\n\ntype LoginInput struct {\n\tUsername string `json:\"username\"`\n\tPassword string `json:\"password\"`\n}\n\ntype AuthTokens struct {\n\tAccessToken  string `json:\"access_token\"`\n\tRefreshToken string `json:\"refresh_token\"`\n}\n\ntype AuthUsecase interface {\n\tSignUp(ctx context.Context, input SignUpInput) (*domain.User, error)\n\tLogin(ctx context.Context, input LoginInput) (*AuthTokens, error)\n\tRefresh(ctx context.Context, refreshToken string) (*AuthTokens, error)\n\tLogout(ctx context.Context, refreshToken string) error\n}\n",
  "backend/internal/usecase/event_ucase.go": "package usecase\n\nimport (\n\t\"chat-app/internal/domain\"\n\t\"context\"\n)\n\ntype EventUsecase interface {\n\tCreateAndBufferEvent(ctx context.Context, eventType string, payload interface{}, recipientID string) error\n\tPersistBufferedEvents(ctx context.Context)\n}\n",
  "backend/internal/usecase/friend_ucase.go": "package usecase\n\nimport (\n\t\"context\"\n\n\t\"chat-app/internal/domain\"\n)\n\ntype FriendUsecase interface {\n\tSendFriendRequest(ctx context.Context, senderID, receiverUsername string) (*domain.FriendRequest, error)\n\tAcceptFriendRequest(ctx context.Context, userID, requestID string) error\n\tRejectFriendRequest(ctx context.Context, userID, requestID string) error\n\tUnfriend(ctx context.Context, userID, friendID string) error\n\tGetPendingRequests(ctx context.Context, userID string) ([]*domain.FriendRequest, error)\n\tListFriends(ctx context.Context, userID string) ([]*domain.User, error)\n}\n",
  "backend/internal/usecase/group_ucase.go": "package usecase\n\nimport (\n\t\"chat-app/internal/domain\"\n\t\"context\"\n\t\"mime/multipart\"\n)\n\ntype CreateGroupInput struct {\n\tHandle string `json:\"handle\"`\n\tName   string `json:\"name\"`\n}\n\ntype UpdateGroupInput struct {\n\tName *string `json:\"name\"`\n}\n\ntype AddGroupMemberInput struct {\n\tUserID string `json:\"user_id\"`\n}\n\ntype TransferOwnershipInput struct {\n\tNewOwnerID string `json:\"new_owner_id\"`\n}\n\ntype GroupDetails struct {\n\t*domain.Group\n\tMembers []*domain.GroupMember `json:\"members\"`\n}\n\ntype GroupUsecase interface {\n\tCreateGroup(ctx context.Context, userID string, input CreateGroupInput, file multipart.File, fileHeader *multipart.FileHeader) (*domain.Group, error)\n\tGetGroupDetails(ctx context.Context, groupID string) (*GroupDetails, error)\n\tUpdateGroup(ctx context.Context, userID, groupID string, input UpdateGroupInput, file multipart.File, fileHeader *multipart.FileHeader) (*domain.Group, error)\n\tSearchGroups(ctx context.Context, query string) ([]*domain.Group, error)\n\tJoinGroup(ctx context.Context, userID, groupHandle string) (*domain.Group, error)\n\tLeaveGroup(ctx context.Context, userID, groupID string) error\n\tAddMember(ctx context.Context, currentUserID, groupID, friendID string) error\n\tRemoveMember(ctx context.Context, ownerID, groupID, memberID string) error\n\tTransferOwnership(ctx context.Context, currentOwnerID, groupID, newOwnerID string) error\n\tListUserGroups(ctx context.Context, userID string) ([]*domain.Group, error)\n}\n",
  "backend/internal/usecase/message_ucase.go": "package usecase\n\nimport (\n\t\"context\"\n\t\"time\"\n\n\t\"chat-app/backend/internal/domain\"\n)\n\ntype SendMessageInput struct {\n\tConversationID string `json:\"conversation_id\"`\n\tContent        string `json:\"content\"`\n}\n\ntype MessageUsecase interface {\n\tSendMessage(ctx context.Context, senderID string, input SendMessageInput) (*domain.Message, error)\n\tGetMessageHistory(ctx context.Context, userID, conversationID string, before time.Time, limit int) ([]*domain.Message, error)\n}\n",
  "backend/internal/usecase/user_ucase.go": "package usecase\n\nimport (\n\t\"chat-app/internal/domain\"\n\t\"context\"\n\t\"mime/multipart\"\n)\n\ntype UpdateUserInput struct {\n\tUsername *string\n\tPassword *string\n}\n\ntype UserUsecase interface {\n\tGetProfile(ctx context.Context, userID string) (*domain.User, error)\n\tGetUserByUsername(ctx context.Context, username string) (*domain.User, error)\n\tUpdateProfile(ctx context.Context, userID string, input UpdateUserInput) (*domain.User, error)\n\tUpdateProfilePicture(ctx context.Context, userID string, file multipart.File, fileHeader *multipart.FileHeader) (string, error)\n}\n",
  "backend/migrations/000001_create_users_table.up.sql": "CREATE EXTENSION IF NOT EXISTS \"uuid-ossp\";\nCREATE EXTENSION IF NOT EXISTS \"citext\";\n\nCREATE TABLE IF NOT EXISTS users (\n    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),\n    username CITEXT NOT NULL UNIQUE,\n    password_hash VARCHAR(255) NOT NULL,\n    profile_pic_url VARCHAR(255) DEFAULT '',\n    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),\n    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()\n);\n\nCREATE INDEX IF NOT EXISTS users_username_idx ON users(username);\n",
  "backend/migrations/000002_create_sessions_table.up.sql": "CREATE TABLE IF NOT EXISTS sessions (\n    id UUID PRIMARY KEY,\n    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,\n    expires_at TIMESTAMPTZ NOT NULL,\n    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()\n);\n\nCREATE INDEX IF NOT EXISTS sessions_user_id_idx ON sessions(user_id);\n",
  "backend/migrations/000003_create_events_table.up.sql": "CREATE TABLE IF NOT EXISTS events (\n    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),\n    type VARCHAR(50) NOT NULL,\n    payload JSONB NOT NULL,\n    recipient_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,\n    is_delivered BOOLEAN NOT NULL DEFAULT FALSE,\n    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()\n);\n\nCREATE INDEX IF NOT EXISTS events_recipient_id_is_delivered_idx ON events (recipient_id, is_delivered);\n",
  "backend/migrations/000004_create_friends_tables.up.sql": "CREATE TABLE IF NOT EXISTS friend_requests (\n    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),\n    sender_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,\n    receiver_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,\n    status VARCHAR(20) NOT NULL CHECK (status IN ('pending', 'accepted', 'rejected')),\n    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),\n    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),\n    UNIQUE(sender_id, receiver_id)\n);\n\nCREATE TABLE IF NOT EXISTS friendships (\n    user_id1 UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,\n    user_id2 UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,\n    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),\n    PRIMARY KEY (user_id1, user_id2),\n    CHECK (user_id1 \u003c user_id2)\n);\n\nCREATE INDEX ON friend_requests (sender_id);\nCREATE INDEX ON friend_requests (receiver_id);\nCREATE INDEX ON friendships (user_id1);\nCREATE INDEX ON friendships (user_id2);\n",
  "backend/migrations/000005_create_groups_tables.up.sql": "CREATE TABLE groups (\n    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),\n    handle VARCHAR(100) UNIQUE NOT NULL,\n    name VARCHAR(100) NOT NULL,\n    owner_id UUID NOT NULL REFERENCES users(id) ON DELETE RESTRICT,\n    profile_pic_url VARCHAR(255) DEFAULT '',\n    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),\n    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()\n);\n\nCREATE INDEX groups_handle_idx ON groups(handle);\n\nCREATE TABLE group_members (\n    group_id UUID NOT NULL REFERENCES groups(id) ON DELETE CASCADE,\n    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,\n    role VARCHAR(20) NOT NULL CHECK (role IN ('owner', 'member')),\n    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),\n    PRIMARY KEY (group_id, user_id)\n);\n\nCREATE INDEX group_members_user_id_idx ON group_members(user_id);\nCREATE INDEX group_members_created_at_idx ON group_members(created_at);\n",
  "backend/migrations/000006_create_messages_table.up.sql": "CREATE TABLE IF NOT EXISTS messages (\n    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),\n    conversation_id VARCHAR(100) NOT NULL,\n    sender_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,\n    content TEXT NOT NULL,\n    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()\n);\n\nCREATE INDEX IF NOT EXISTS messages_conversation_id_created_at_idx ON messages (conversation_id, created_at DESC);\n",
  "backend/pkg/config/config.go": "package config\n\nimport (\n\t\"log\"\n\t\"os\"\n\t\"time\"\n\n\t\"github.com/joho/godotenv\"\n)\n\ntype Config struct {\n\tPort            string\n\tDatabaseURL     string\n\tRedisURL        string\n\tJWTSecret       string\n\tAccessTokenTTL  time.Duration\n\tRefreshTokenTTL time.Duration\n\tUploadDir       string\n}\n\nfunc Load() *Config {\n\tif err := godotenv.Load(); err != nil {\n\t\tlog.Println(\"No .env file found, using environment variables\")\n\t}\n\n\treturn \u0026Config{\n\t\tPort:            getEnv(\"PORT\", \"8080\"),\n\t\tDatabaseURL:     getEnv(\"DATABASE_URL\", \"postgres://user:password@localhost:5432/chatdb?sslmode=disable\"),\n\t\tRedisURL:        getEnv(\"REDIS_URL\", \"redis://localhost:6379/0\"),\n\t\tJWTSecret:       getEnv(\"JWT_SECRET\", \"a-very-secret-key\"),\n\t\tAccessTokenTTL:  10 * time.Minute,\n\t\tRefreshTokenTTL: 8 * time.Hour,\n\t\tUploadDir:       getEnv(\"UPLOAD_DIR\", \"uploads\"),\n\t}\n}\n\nfunc getEnv(key, fallback string) string {\n\tif value, ok := os.LookupEnv(key); ok {\n\t\treturn value\n\t}\n\treturn fallback\n}",
  "backend/pkg/util/hash.go": "package util\n\nimport \"golang.org/x/crypto/bcrypt\"\n\nfunc HashPassword(password string) (string, error) {\n\tbytes, err := bcrypt.GenerateFromPassword([]byte(password), bcrypt.DefaultCost)\n\treturn string(bytes), err\n}\n\nfunc CheckPasswordHash(password, hash string) bool {\n\terr := bcrypt.CompareHashAndPassword([]byte(hash), []byte(password))\n\treturn err == nil\n}\n",
  "backend/pkg/util/jwt.go": "package util\n\nimport (\n\t\"fmt\"\n\t\"time\"\n\n\t\"github.com/golang-jwt/jwt/v5\"\n)\n\ntype Claims struct {\n\tUserID string `json:\"user_id\"`\n\tjwt.RegisteredClaims\n}\n\nfunc GenerateAccessToken(userID, secret string, ttl time.Duration) (string, error) {\n\tclaims := \u0026Claims{\n\t\tUserID: userID,\n\t\tRegisteredClaims: jwt.RegisteredClaims{\n\t\t\tExpiresAt: jwt.NewNumericDate(time.Now().Add(ttl)),\n\t\t\tIssuedAt:  jwt.NewNumericDate(time.Now()),\n\t\t},\n\t}\n\n\ttoken := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)\n\treturn token.SignedString([]byte(secret))\n}\n\nfunc ValidateToken(tokenString, secret string) (*Claims, error) {\n\ttoken, err := jwt.ParseWithClaims(tokenString, \u0026Claims{}, func(token *jwt.Token) (interface{}, error) {\n\t\tif _, ok := token.Method.(*jwt.SigningMethodHMAC); !ok {\n\t\t\treturn nil, fmt.Errorf(\"unexpected signing method: %v\", token.Header[\"alg\"])\n\t\t}\n\t\treturn []byte(secret), nil\n\t})\n\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tif claims, ok := token.Claims.(*Claims); ok \u0026\u0026 token.Valid {\n\t\treturn claims, nil\n\t}\n\n\treturn nil, fmt.Errorf(\"invalid token\")\n}\n",
  "backend/pkg/util/uuid.go": "package util\n\nimport \"github.com/google/uuid\"\n\nfunc NewUUID() string {\n\treturn uuid.New().String()\n}\n\nfunc ParseUUID(s string) (uuid.UUID, error) {\n\treturn uuid.Parse(s)\n}\n```",
  "backend/web/static/css/style.css": "/* Placeholder for compiled Tailwind CSS */\n",
  "backend/web/static/js/api.js": "/**\n * @typedef {object} User\n * @property {string} id\n * @property {string} username\n * @property {string} profile_pic_url\n * @property {string} created_at\n * @property {string} updated_at\n */\n\n/**\n * @typedef {object} AuthTokens\n * @property {string} access_token\n * @property {string} refresh_token\n */\n\n/**\n * @typedef {object} Group\n * @property {string} id\n * @property {string} handle\n * @property {string} name\n * @property {string} photo_url\n * @property {string} owner_id\n * @property {string} created_at\n * @property {string} updated_at\n */\n\n/**\n * @typedef {object} Message\n * @property {string} id\n * @property {string} conversation_id\n * @property {string} sender_id\n * @property {string} content\n * @property {string} created_at\n * @property {User} sender\n */\n\nimport * as store from './store.js'; // Changed import style\n\nconst API_BASE = '/api/v1';\n\n/**\n * Generic request handler\n * @param {string} endpoint\n * @param {RequestInit} options\n * @returns {Promise\u003cany\u003e}\n */\nasync function request(endpoint, options = {}) {\n    const url = `${API_BASE}${endpoint}`;\n    const headers = {\n        ...options.headers,\n    };\n\n    const token = store.getAccessToken(); // Used store.getAccessToken()\n    if (token) {\n        headers['Authorization'] = `Bearer ${token}`;\n    }\n\n    if (!(options.body instanceof FormData)) {\n        headers['Content-Type'] = 'application/json';\n    }\n\n    const config = {\n        ...options,\n        headers,\n    };\n\n    try {\n        const response = await fetch(url, config);\n\n        if (!response.ok) {\n            if (response.status === 401) {\n                store.clearTokens(); // Used store.clearTokens()\n                window.location.href = '/';\n            }\n            const errorData = await response.json(); // Simplified error parsing\n            throw new Error(errorData.error || 'API request failed');\n        }\n\n        if (response.status === 204) {\n            return null;\n        }\n\n        return response.json();\n    } catch (error) {\n        console.error(`API Error on ${endpoint}:`, error); // Updated error logging\n        throw error;\n    }\n}\n\n// --- Auth ---\n/** @returns {Promise\u003cUser\u003e} */\nexport const signup = (username, password) =\u003e request('/auth/signup', {\n    method: 'POST',\n    body: JSON.stringify({ username, password }),\n});\n\n/** @returns {Promise\u003cAuthTokens\u003e} */\nexport const login = (username, password) =\u003e request('/auth/login', {\n    method: 'POST',\n    body: JSON.stringify({ username, password }),\n});\n\nexport const logout = () =\u003e {\n    store.clearTokens(); // Used store.clearTokens()\n};\n\n// --- Users ---\n/** @returns {Promise\u003cUser\u003e} */\nexport const getMe = () =\u003e request('/users/me');\n\n/** @returns {Promise\u003cUser\u003e} */\nexport const updateProfile = (formData) =\u003e request('/users/me', {\n    method: 'PUT',\n    body: formData,\n});\n\n/** @returns {Promise\u003cUser\u003e} */\nexport const getUserByUsername = (username) =\u003e request(`/users/${username}`);\n\n\n// --- Friends ---\nexport const sendFriendRequest = (username) =\u003e request('/friends/requests', {\n    method: 'POST',\n    body: JSON.stringify({ username }),\n});\n\nexport const getPendingFriendRequests = () =\u003e request('/friends/requests/pending');\n\nexport const acceptFriendRequest = (requestID) =\u003e request(`/friends/requests/${requestID}/accept`, {\n    method: 'PUT',\n});\n\nexport const rejectFriendRequest = (requestID) =\u003e request(`/friends/requests/${requestID}/reject`, {\n    method: 'PUT',\n});\n\nexport const unfriendUser = (userID) =\u003e request(`/friends/${userID}`, {\n    method: 'DELETE',\n});\n\nexport const listFriends = () =\u003e request('/friends');\n\n// --- Groups ---\n/** @returns {Promise\u003cGroup\u003e} */\nexport const createGroup = (formData) =\u003e request('/groups', {\n    method: 'POST',\n    body: formData,\n});\n\n/** @returns {Promise\u003cGroup[]\u003e} */\nexport const searchGroups = (query) =\u003e request(`/groups/search?q=${encodeURIComponent(query)}`);\n\n/** @returns {Promise\u003cvoid\u003e} */\nexport const joinGroup = (handle) =\u003e request(`/groups/${handle}/join`, { method: 'POST' });\n\n/** @returns {Promise\u003cGroup\u003e} */\nexport const getGroupDetails = (groupId) =\u003e request(`/groups/${groupId}`);\n\n/** @returns {Promise\u003cGroup\u003e} */\nexport const updateGroup = (groupId, formData) =\u003e request(`/groups/${groupId}`, {\n    method: 'PUT',\n    body: formData,\n});\n\n/** @returns {Promise\u003cvoid\u003e} */\nexport const addGroupMember = (groupId, friendId) =\u003e request(`/groups/${groupId}/members`, {\n    method: 'POST',\n    body: JSON.stringify({ friend_id: friendId }),\n});\n\n/** @returns {Promise\u003cvoid\u003e} */\nexport const removeGroupMember = (groupId, memberId) =\u003e request(`/groups/${groupId}/members/${memberId}`, { method: 'DELETE' });\n\n/** @returns {Promise\u003cvoid\u003e} */\nexport const leaveGroup = (groupId) =\u003e request(`/groups/${groupId}/leave`, { method: 'POST' });\n\n/** @returns {Promise\u003cvoid\u003e} */\nexport const transferGroupOwnership = (groupId, newOwnerId) =\u003e request(`/groups/${groupId}/transfer-ownership`, {\n    method: 'PUT',\n    body: JSON.stringify({ new_owner_id: newOwnerId }),\n});\n\n/** @returns {Promise\u003cGroup[]\u003e} */\nexport const listMyGroups = () =\u003e request('/groups/me');\n\n// --- Messages ---\n/** @returns {Promise\u003cMessage[]\u003e} */\nexport const getMessageHistory = (conversationId, before = null, limit = 50) =\u003e { // Added message history API\n    let query = `?limit=${limit}`;\n    if (before) {\n        query += `\u0026before=${encodeURIComponent(before)}`;\n    }\n    return request(`/conversations/${conversationId}/messages${query}`);\n};",
  "backend/web/static/js/main.js": "import * as api from './api.js';\nimport * as store from './store.js';\nimport * as ui from './ui.js';\nimport * as ws from './ws.js';\n\n// --- AUTH PAGE ---\nasync function handleAuthFormSubmit(event) {\n    event.preventDefault();\n    const form = event.target;\n    const isSignUp = form.id === 'signup-form';\n    const username = form.username.value;\n    const password = form.password.value;\n\n    try {\n        const data = isSignUp\n            ? await api.signup(username, password)\n            : await api.login(username, password);\n\n        if (isSignUp) {\n            ui.showNotification('Signup successful! Please log in.', 'success');\n            ui.toggleAuthForms();\n        } else {\n            store.setTokens(data.access_token, data.refresh_token);\n            window.location.href = '/chat.html'; // Redirect to chat.html\n        }\n    } catch (error) {\n        ui.showError(form.id, error.message);\n    }\n}\n\nfunction initAuthPage() {\n    document.getElementById('login-form')?.addEventListener('submit', handleAuthFormSubmit);\n    document.getElementById('signup-form')?.addEventListener('submit', handleAuthFormSubmit);\n    document.getElementById('show-signup-form')?.addEventListener('click', ui.toggleAuthForms);\n    document.getElementById('show-login-form')?.addEventListener('click', ui.toggleAuthForms);\n}\n\n// --- CHAT PAGE ---\nasync function handleProfileUpdateFormSubmit(event) {\n    event.preventDefault();\n    const form = event.target;\n    const formData = new FormData(form);\n\n    // Remove empty fields so they are not sent\n    if (!formData.get('username').trim()) formData.delete('username');\n    if (!formData.get('password').trim()) formData.delete('password');\n    if (!formData.get('profile_pic').name) formData.delete('profile_pic'); // More robust check for file input\n\n    try {\n        const updatedUser = await api.updateProfile(formData);\n        store.setCurrentUser(updatedUser);\n        ui.renderProfile(updatedUser);\n        ui.showNotification('Profile updated successfully!', 'success');\n        form.reset();\n    } catch (error) {\n        ui.showNotification(`Update failed: ${error.message}`, 'error');\n    }\n}\n\nfunction handleLogout() {\n    api.logout();\n    window.location.href = '/';\n}\n\nasync function handleAddFriendSubmit(event) {\n    event.preventDefault();\n    const form = event.target;\n    const username = form.username.value;\n    try {\n        await api.sendFriendRequest(username);\n        ui.showNotification(`Friend request sent to ${username}`, 'success');\n        form.reset();\n        ui.closeModal('add-friend-modal');\n        await refreshPendingRequests();\n    } catch (error) {\n        ui.showNotification(`Error: ${error.message}`, 'error');\n    }\n}\n\nasync function handleFriendAction(event) {\n    const button = event.target.closest('button'); // Use closest for delegation\n    if (!button) return;\n\n    const action = button.dataset.action;\n    const id = button.dataset.id;\n\n    try {\n        if (action === 'accept') {\n            await api.acceptFriendRequest(id);\n            ui.showNotification('Friend request accepted!', 'success');\n        } else if (action === 'reject') {\n            await api.rejectFriendRequest(id);\n            ui.showNotification('Friend request rejected.', 'info');\n        } else if (action === 'unfriend') {\n            if (confirm('Are you sure you want to unfriend this user?')) {\n                await api.unfriendUser(id);\n                ui.showNotification('User unfriended.', 'info');\n            }\n        }\n        await Promise.all([refreshFriendsList(), refreshPendingRequests()]);\n    } catch (error) {\n        ui.showNotification(`Error: ${error.message}`, 'error');\n    }\n}\n\nasync function handleCreateGroupSubmit(event) {\n    event.preventDefault();\n    const form = event.target;\n    const formData = new FormData(form);\n    try {\n        await api.createGroup(formData);\n        ui.showNotification('Group created successfully!', 'success');\n        form.reset();\n        ui.closeModal('create-group-modal');\n        await refreshGroupsList();\n    } catch (error) {\n        ui.showNotification(`Error: ${error.message}`, 'error');\n    }\n}\n\nlet searchTimeout;\nasync function handleSearchGroup(event) {\n    clearTimeout(searchTimeout);\n    const query = event.target.value;\n    if (query.length \u003c 2) {\n        ui.renderGroupSearchResults([]);\n        return;\n    }\n    searchTimeout = setTimeout(async () =\u003e {\n        try {\n            const groups = await api.searchGroups(query);\n            ui.renderGroupSearchResults(groups, handleJoinGroupClick);\n        } catch (error) {\n            ui.showNotification(`Search failed: ${error.message}`, 'error');\n        }\n    }, 300);\n}\n\nasync function handleJoinGroupClick(event) {\n    const handle = event.target.dataset.handle;\n    try {\n        await api.joinGroup(handle);\n        ui.showNotification(`Joined group ${handle}!`, 'success');\n        await refreshGroupsList();\n    } catch (error) {\n        ui.showNotification(`Failed to join: ${error.message}`, 'error');\n    }\n}\n\nasync function handleMessageSubmit(event) {\n    event.preventDefault();\n    const form = event.target;\n    const input = form.querySelector('input[name=\"message\"]');\n    const content = input.value.trim();\n    const activeChat = store.getActiveChat();\n\n    if (content \u0026\u0026 activeChat \u0026\u0026 activeChat.id) {\n        ws.send('send_message', {\n            conversation_id: activeChat.id,\n            content: content,\n        });\n        input.value = '';\n    }\n}\n\nexport async function handleNewMessage(message) {\n    const activeChat = store.getActiveChat();\n    const currentUser = store.getCurrentUser();\n\n    if (activeChat \u0026\u0026 activeChat.id === message.conversation_id) {\n        ui.appendMessage(message, currentUser.id);\n    } else {\n        const senderName = message.sender?.username || 'Someone';\n        ui.showNotification(`New message from ${senderName}`, 'info');\n        // Potentially update a badge count on the conversation list item\n    }\n}\n\nasync function selectChat(event) {\n    const target = event.currentTarget;\n    const type = target.dataset.chatType;\n    const id = target.dataset.chatId;\n    const name = target.dataset.chatName;\n    const pic = target.dataset.chatPic;\n\n    let conversationId = id;\n    if (type === 'friend') {\n        const currentUser = store.getCurrentUser();\n        // Ensure consistent conversation ID for direct messages\n        conversationId = [currentUser.id, id].sort().join(':');\n    }\n\n    store.setActiveChat(type, conversationId, name);\n    ui.renderChatWindow({ type, id, name, pic });\n    ui.clearMessages();\n\n    try {\n        const messages = await api.getMessageHistory(conversationId);\n        if (messages \u0026\u0026 messages.length \u003e 0) {\n            ui.prependMessages(messages, store.getCurrentUser().id);\n        }\n    } catch (error) {\n        ui.showNotification(`Failed to load messages: ${error.message}`, 'error');\n    }\n}\n\nexport async function refreshFriendsList() {\n    try {\n        const friends = await api.listFriends();\n        store.setFriends(friends || []); // Ensure array\n        ui.renderFriendList(friends || [], selectChat); // Pass selectChat handler\n    } catch (error) {\n        console.error('Failed to refresh friends list:', error);\n    }\n}\n\nexport async function refreshPendingRequests() {\n    try {\n        const requests = await api.getPendingFriendRequests();\n        store.setPendingRequests(requests || []); // Ensure array\n        ui.renderPendingRequests(requests || [], store.getCurrentUser().id);\n    } catch (error) {\n        console.error('Failed to refresh pending requests:', error);\n    }\n}\n\nexport async function refreshGroupsList() {\n    try {\n        const groups = await api.listMyGroups();\n        store.setGroups(groups || []); // Ensure array\n        ui.renderGroupList(groups || [], selectChat); // Pass selectChat handler\n    } catch (error) {\n        console.error('Failed to refresh groups list:', error);\n    }\n}\n\nasync function initChatPage() {\n    if (!store.getAccessToken()) {\n        window.location.href = '/';\n        return;\n    }\n\n    // Initial data fetch\n    try {\n        const user = await api.getMe();\n        store.setCurrentUser(user);\n        ui.renderProfile(user);\n\n        await Promise.all([\n            refreshFriendsList(),\n            refreshPendingRequests(),\n            refreshGroupsList(),\n        ]);\n\n        ws.connect();\n    } catch (error) {\n        console.error('Initialization failed:', error);\n        handleLogout(); // If we can't get user data, log out\n    }\n\n    // Bind event listeners\n    document.getElementById('profile-update-form').addEventListener('submit', handleProfileUpdateFormSubmit);\n    document.getElementById('logout-button').addEventListener('click', handleLogout);\n    document.getElementById('add-friend-form').addEventListener('submit', handleAddFriendSubmit);\n    document.getElementById('create-group-form').addEventListener('submit', handleCreateGroupSubmit);\n    document.getElementById('group-search-input').addEventListener('input', handleSearchGroup); // Updated ID\n    document.getElementById('message-form').addEventListener('submit', handleMessageSubmit); // Added message form listener\n\n    // Event delegation for dynamic lists\n    document.getElementById('friends-list').addEventListener('click', handleFriendAction);\n    document.getElementById('pending-requests-list').addEventListener('click', handleFriendAction);\n\n    // Modal triggers\n    document.getElementById('add-friend-btn').addEventListener('click', () =\u003e ui.openModal('add-friend-modal')); // Updated ID\n    document.getElementById('create-group-btn').addEventListener('click', () =\u003e ui.openModal('create-group-modal')); // Updated ID\n    document.getElementById('find-group-btn').addEventListener('click', () =\u003e ui.openModal('search-group-modal')); // Updated ID\n}\n\n// --- MAIN ---\ndocument.addEventListener('DOMContentLoaded', () =\u003e {\n    if (window.location.pathname.includes('chat.html')) { // Check for chat.html\n        initChatPage();\n    } else {\n        initAuthPage();\n    }\n});",
  "backend/web/static/js/store.js": "/**\n * @typedef {import('./api.js').User} User\n * @typedef {import('./api.js').Group} Group\n */\n\n/**\n * @typedef {object} FriendRequest\n * @property {string} id\n * @property {User} sender // Changed to User object\n * @property {User} receiver // Changed to User object\n * @property {string} status // Added status\n * @property {string} created_at\n */\n\n/**\n * @typedef {object} ActiveChat\n * @property {'friend'|'group'|null} type\n * @property {string|null} id - The conversation ID\n * @property {string|null} name - The display name // Added name\n */\n\nconst state = {\n    /** @type {User | null} */\n    currentUser: null,\n    accessToken: localStorage.getItem('accessToken'),\n    refreshToken: localStorage.getItem('refreshToken'),\n    /** @type {User[]} */\n    friends: [],\n    /** @type {FriendRequest[]} */\n    pendingRequests: [],\n    /** @type {Group[]} */\n    groups: [],\n    /** @type {ActiveChat} */\n    activeChat: { type: null, id: null, name: null }, // Initialized name\n};\n\n/** @param {User} user */\nexport function setCurrentUser(user) {\n    state.currentUser = user;\n}\n\nexport function getCurrentUser() {\n    return state.currentUser;\n}\n\nexport function setTokens(access, refresh) {\n    state.accessToken = access;\n    state.refreshToken = refresh;\n    localStorage.setItem('accessToken', access);\n    localStorage.setItem('refreshToken', refresh);\n}\n\nexport function getAccessToken() {\n    return state.accessToken;\n}\n\nexport function getRefreshToken() {\n    return state.refreshToken;\n}\n\nexport function clearTokens() {\n    state.currentUser = null;\n    state.accessToken = null;\n    state.refreshToken = null;\n    state.friends = [];\n    state.pendingRequests = [];\n    state.groups = [];\n    state.activeChat = { type: null, id: null, name: null }; // Cleared name\n    localStorage.removeItem('accessToken');\n    localStorage.removeItem('refreshToken');\n}\n\nexport function setFriends(friends) {\n    state.friends = friends;\n}\n\nexport function getFriends() {\n    return state.friends;\n}\n\nexport function setPendingRequests(requests) {\n    state.pendingRequests = requests;\n}\n\nexport function getPendingRequests() {\n    return state.pendingRequests;\n}\n\n/** @param {Group[]} groups */\nexport function setGroups(groups) {\n    state.groups = groups;\n}\n\n/** @returns {Group[]} */\nexport function getGroups() {\n    return state.groups;\n}\n\n/**\n * @param {'friend'|'group'|null} type\n * @param {string|null} id\n * @param {string|null} name\n */\nexport function setActiveChat(type, id, name) { // Added setActiveChat\n    state.activeChat = { type, id, name };\n}\n\n/** @returns {ActiveChat} */\nexport function getActiveChat() { // Added getActiveChat\n    return state.activeChat;\n}",
  "backend/web/static/js/ui.js": "/**\n * @typedef {import('./api.js').User} User\n * @typedef {import('./store.js').FriendRequest} FriendRequest\n * @typedef {import('./api.js').Group} Group\n * @typedef {import('./api.js').Message} Message // Added Message typedef\n */\n\n// --- AUTH ---\nexport function toggleAuthForms() {\n    document.getElementById('login-container').classList.toggle('hidden');\n    document.getElementById('signup-container').classList.toggle('hidden');\n}\n\n/**\n * @param {string} formId\n * @param {string} message\n */\nexport function showError(formId, message) {\n    const errorEl = document.querySelector(`#${formId} .error-message`);\n    if (errorEl) {\n        errorEl.textContent = message;\n        errorEl.classList.remove('hidden');\n    }\n}\n\n// --- NOTIFICATIONS ---\n/**\n * @param {string} message\n * @param {'info'|'success'|'error'} type\n */\nexport function showNotification(message, type = 'info') {\n    const container = document.getElementById('notification-container');\n    if (!container) return; // Added null check\n    const notification = document.createElement('div');\n    const colors = {\n        info: 'bg-blue-500',\n        success: 'bg-green-500',\n        error: 'bg-red-500',\n    };\n    notification.className = `text-white p-3 rounded-lg shadow-lg mb-2 ${colors[type] || colors.info}`; // Updated styling\n    notification.textContent = message;\n    container.appendChild(notification);\n    setTimeout(() =\u003e {\n        notification.remove();\n    }, 3000);\n}\n\n// --- MODALS ---\n/**\n * @param {string} modalId\n */\nexport function openModal(modalId) {\n    const modal = document.getElementById(modalId);\n    if (!modal) return; // Added null check\n\n    const overlay = modal.querySelector('.modal-overlay');\n    const closeButtons = modal.querySelectorAll('.modal-close'); // Changed class name\n\n    const closeModalHandler = () =\u003e closeModal(modalId);\n\n    modal.classList.remove('hidden');\n    document.body.classList.add('overflow-hidden'); // Added overflow-hidden to body\n\n    overlay.onclick = closeModalHandler;\n    closeButtons.forEach(btn =\u003e btn.onclick = closeModalHandler);\n    document.onkeydown = (evt) =\u003e { // Updated keydown handler\n        evt = evt || window.event;\n        if (evt.key === \"Escape\") {\n            closeModalHandler();\n        }\n    };\n\n    const firstInput = modal.querySelector('input, textarea, select'); // Focus on first input\n    if (firstInput) {\n        firstInput.focus();\n    }\n}\n\n/**\n * @param {string} modalId\n */\nexport function closeModal(modalId) {\n    const modal = document.getElementById(modalId);\n    if (modal) {\n        modal.classList.add('hidden');\n        document.body.classList.remove('overflow-hidden'); // Removed overflow-hidden from body\n        // Clean up event listeners\n        const overlay = modal.querySelector('.modal-overlay');\n        if (overlay) overlay.onclick = null; // Added null check\n        modal.querySelectorAll('.modal-close').forEach(btn =\u003e btn.onclick = null);\n        document.onkeydown = null;\n    }\n}\n\n// --- CHAT PAGE RENDERING ---\n/**\n * @param {User} user\n */\nexport function renderProfile(user) {\n    const container = document.getElementById('profile-container');\n    if (!container || !user) return;\n    container.innerHTML = `\n        \u003cimg src=\"${user.profile_pic_url || 'https://via.placeholder.com/40'}\" alt=\"My Profile\" class=\"w-10 h-10 rounded-full mr-3\"\u003e\n        \u003cdiv\u003e\n            \u003cp class=\"font-semibold text-white\"\u003e${user.username}\u003c/p\u003e\n            \u003cp class=\"text-xs text-gray-400\"\u003eJoined: ${new Date(user.created_at).toLocaleDateString()}\u003c/p\u003e\n        \u003c/div\u003e\n    `;\n}\n\n/**\n * @param {User[]} friends\n * @param {(event: Event) =\u003e void} selectChatHandler\n */\nexport function renderFriendList(friends, selectChatHandler) { // Added selectChatHandler\n    const list = document.getElementById('friends-list');\n    if (!list) return;\n    if (friends.length === 0) { // Added empty state\n        list.innerHTML = '\u003cli class=\"text-gray-500 text-sm p-2\"\u003eNo friends yet.\u003c/li\u003e';\n        return;\n    }\n    list.innerHTML = friends.map(friend =\u003e `\n        \u003cli class=\"flex items-center justify-between p-2 hover:bg-gray-700 rounded-md cursor-pointer\"\n            data-chat-type=\"friend\" data-chat-id=\"${friend.id}\" data-chat-name=\"${friend.username}\" data-chat-pic=\"${friend.profile_pic_url || 'https://via.placeholder.com/40'}\"\u003e\n            \u003cdiv class=\"flex items-center flex-grow\"\u003e\n                \u003cimg src=\"${friend.profile_pic_url || 'https://via.placeholder.com/40'}\" alt=\"${friend.username}\" class=\"w-8 h-8 rounded-full mr-3\"\u003e\n                \u003cspan class=\"text-gray-300\"\u003e${friend.username}\u003c/span\u003e\n            \u003c/div\u003e\n            \u003cbutton data-action=\"unfriend\" data-id=\"${friend.id}\" class=\"text-red-500 hover:text-red-400 text-xs p-1\"\u003eUnfriend\u003c/button\u003e\n        \u003c/li\u003e\n    `).join('');\n    list.querySelectorAll('li').forEach(item =\u003e item.addEventListener('click', selectChatHandler)); // Added event listener\n}\n\n/**\n * @param {Group[]} groups\n * @param {(event: Event) =\u003e void} selectChatHandler\n */\nexport function renderGroupList(groups, selectChatHandler) { // Added selectChatHandler\n    const list = document.getElementById('groups-list');\n    if (!list) return;\n    if (groups.length === 0) { // Added empty state\n        list.innerHTML = '\u003cli class=\"text-gray-500 text-sm p-2\"\u003eNo groups yet.\u003c/li\u003e';\n        return;\n    }\n    list.innerHTML = groups.map(group =\u003e `\n        \u003cli class=\"flex items-center p-2 hover:bg-gray-700 rounded-md cursor-pointer\"\n            data-chat-type=\"group\" data-chat-id=\"${group.id}\" data-chat-name=\"${group.name}\" data-chat-pic=\"${group.photo_url || 'https://via.placeholder.com/40'}\"\u003e\n            \u003cimg src=\"${group.photo_url || 'https://via.placeholder.com/40'}\" alt=\"${group.name}\" class=\"w-8 h-8 rounded-full mr-3\"\u003e\n            \u003cdiv\u003e\n                \u003cp class=\"text-gray-300\"\u003e${group.name}\u003c/p\u003e\n                \u003cp class=\"text-xs text-gray-500\"\u003e${group.handle}\u003c/p\u003e\n            \u003c/div\u003e\n        \u003c/li\u003e\n    `).join('');\n    list.querySelectorAll('li').forEach(item =\u003e item.addEventListener('click', selectChatHandler)); // Added event listener\n}\n\n/**\n * @param {FriendRequest[]} requests\n * @param {string} currentUserID\n */\nexport function renderPendingRequests(requests, currentUserID) {\n    const list = document.getElementById('pending-requests-list');\n    if (!list) return;\n    if (requests.length === 0) { // Added empty state\n        list.innerHTML = '\u003cli class=\"text-gray-500 text-sm p-2\"\u003eNo pending requests.\u003c/li\u003e';\n        return;\n    }\n    list.innerHTML = requests.map(req =\u003e {\n        const isIncoming = req.receiver.id === currentUserID; // Changed to req.receiver.id\n        const user = isIncoming ? req.sender : req.receiver; // Changed to req.sender/receiver\n        return `\n            \u003cli class=\"flex items-center justify-between p-2 rounded-md bg-gray-700 mb-2\"\u003e\n                \u003cdiv class=\"flex items-center\"\u003e\n                    \u003cimg src=\"${user.profile_pic_url || 'https://via.placeholder.com/32'}\" alt=\"${user.username}\" class=\"w-8 h-8 rounded-full mr-3\"\u003e\n                    \u003cdiv\u003e\n                        \u003cp class=\"text-gray-300\"\u003e${user.username}\u003c/p\u003e\n                        \u003cp class=\"text-xs ${isIncoming ? 'text-green-400' : 'text-yellow-400'}\"\u003e${isIncoming ? 'Incoming' : 'Outgoing'}\u003c/p\u003e\n                    \u003c/div\u003e\n                \u003c/div\u003e\n                ${isIncoming ? `\n                \u003cdiv\u003e\n                    \u003cbutton data-action=\"accept\" data-id=\"${req.id}\" class=\"bg-green-500 hover:bg-green-600 text-white text-xs px-2 py-1 rounded\"\u003eAccept\u003c/button\u003e\n                    \u003cbutton data-action=\"reject\" data-id=\"${req.id}\" class=\"bg-red-500 hover:bg-red-600 text-white text-xs px-2 py-1 rounded ml-1\"\u003eReject\u003c/button\u003e\n                \u003c/div\u003e\n                ` : ''}\n            \u003c/li\u003e\n        `;\n    }).join('');\n}\n\n/**\n * @param {Group[]} groups\n * @param {(event: Event) =\u003e void} joinHandler\n */\nexport function renderGroupSearchResults(groups, joinHandler) {\n    const resultsContainer = document.getElementById('group-search-results'); // Updated ID\n    if (!resultsContainer) return;\n    if (groups.length === 0) {\n        resultsContainer.innerHTML = '\u003cp class=\"text-gray-400 text-center\"\u003eNo groups found.\u003c/p\u003e'; // Updated styling\n        return;\n    }\n    resultsContainer.innerHTML = groups.map(group =\u003e `\n        \u003cdiv class=\"flex items-center justify-between p-2 border-b border-gray-600\"\u003e\n            \u003cdiv class=\"flex items-center\"\u003e\n                \u003cimg src=\"${group.photo_url || 'https://via.placeholder.com/40'}\" alt=\"${group.name}\" class=\"w-10 h-10 rounded-full mr-3\"\u003e\n                \u003cdiv\u003e\n                    \u003cp class=\"font-semibold text-white\"\u003e${group.name}\u003c/p\u003e\n                    \u003cp class=\"text-sm text-gray-400\"\u003e${group.handle}\u003c/p\u003e\n                \u003c/div\u003e\n            \u003c/div\u003e\n            \u003cbutton data-handle=\"${group.handle}\" class=\"join-group-btn bg-blue-500 hover:bg-blue-600 text-white px-3 py-1 rounded\"\u003eJoin\u003c/button\u003e\n        \u003c/div\u003e\n    `).join('');\n    resultsContainer.querySelectorAll('.join-group-btn').forEach(btn =\u003e btn.addEventListener('click', joinHandler)); // Updated class name\n}\n\n// --- MESSAGING UI ---\n/**\n * @param {object} chat\n * @param {'friend'|'group'} chat.type\n * @param {string} chat.id\n * @param {string} chat.name\n * @param {string} chat.pic\n */\nexport function renderChatWindow(chat) { // New function for rendering chat window\n    const container = document.getElementById('chat-container');\n    const header = document.getElementById('chat-header');\n    const welcomeScreen = document.getElementById('welcome-screen'); // Added welcome screen\n\n    if (!container || !header || !welcomeScreen) return;\n\n    if (!chat || !chat.id) {\n        container.classList.add('hidden');\n        welcomeScreen.classList.remove('hidden');\n        return;\n    }\n\n    container.classList.remove('hidden');\n    welcomeScreen.classList.add('hidden');\n    header.innerHTML = `\n        \u003cimg src=\"${chat.pic || 'https://via.placeholder.com/40'}\" alt=\"${chat.name}\" class=\"w-10 h-10 rounded-full mr-4\"\u003e\n        \u003ch2 class=\"text-xl font-semibold text-white\"\u003e${chat.name}\u003c/h2\u003e\n    `;\n}\n\n/**\n * @param {Message} message\n * @param {string} currentUserID\n */\nfunction renderMessage(message, currentUserID) { // New function for rendering a single message\n    const isOwnMessage = message.sender_id === currentUserID;\n    const senderName = isOwnMessage ? 'You' : message.sender?.username || '...';\n    const time = new Date(message.created_at).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });\n\n    return `\n        \u003cdiv class=\"flex items-start mb-4 ${isOwnMessage ? 'justify-end' : ''}\"\u003e\n            ${!isOwnMessage ? `\u003cimg src=\"${message.sender?.profile_pic_url || 'https://via.placeholder.com/40'}\" class=\"w-8 h-8 rounded-full mr-3\"\u003e` : ''}\n            \u003cdiv class=\"flex flex-col ${isOwnMessage ? 'items-end' : 'items-start'}\"\u003e\n                \u003cdiv class=\"${isOwnMessage ? 'bg-blue-600' : 'bg-gray-700'} text-white p-3 rounded-lg max-w-xs lg:max-w-md\"\u003e\n                    \u003cp class=\"text-sm\"\u003e${message.content}\u003c/p\u003e\n                \u003c/div\u003e\n                \u003cdiv class=\"text-xs text-gray-500 mt-1\"\u003e\n                    ${!isOwnMessage ? `\u003cspan class=\"font-semibold\"\u003e${senderName}\u003c/span\u003e at ` : ''}\n                    ${time}\n                \u003c/div\u003e\n            \u003c/div\u003e\n        \u003c/div\u003e\n    `;\n}\n\n/**\n * @param {Message} message\n * @param {string} currentUserID\n */\nexport function appendMessage(message, currentUserID) { // New function to append messages\n    const container = document.getElementById('messages-container');\n    if (!container) return;\n    container.innerHTML += renderMessage(message, currentUserID);\n    container.scrollTop = container.scrollHeight;\n}\n\n/**\n * @param {Message[]} messages\n * @param {string} currentUserID\n */\nexport function prependMessages(messages, currentUserID) { // New function to prepend messages (for history)\n    const container = document.getElementById('messages-container');\n    if (!container) return;\n    const oldScrollHeight = container.scrollHeight;\n    container.innerHTML = messages.map(msg =\u003e renderMessage(msg, currentUserID)).join('') + container.innerHTML;\n    container.scrollTop = container.scrollHeight - oldScrollHeight;\n}\n\nexport function clearMessages() { // New function to clear messages\n    const container = document.getElementById('messages-container');\n    if (container) {\n        container.innerHTML = '';\n    }\n}",
  "backend/web/static/js/ws.js": "import * as store from './store.js'; // Changed import style\nimport * as ui from './ui.js';       // Changed import style\nimport * as main from './main.js';    // Changed import style\n\nlet socket;\nlet reconnectInterval = 1000; // Start with 1 second\n\n/**\n * Handles incoming WebSocket events and dispatches actions.\n * @param {MessageEvent} event - The raw WebSocket message event.\n */\nfunction handleIncomingEvent(event) {\n    const data = JSON.parse(event.data);\n    console.log('WS Event Received:', data);\n\n    switch (data.type) {\n        case 'new_message':\n            main.handleNewMessage(data.payload); // Handled new message\n            break;\n        case 'friend_request_received':\n            ui.showNotification(`New friend request from ${data.payload.sender.username}`, 'info'); // Updated payload access\n            main.refreshPendingRequests();\n            break;\n        case 'friend_request_accepted':\n            ui.showNotification(`${data.payload.user.username} accepted your friend request!`, 'success'); // Updated payload access\n            main.refreshFriendsList();\n            main.refreshPendingRequests();\n            break;\n        case 'friend_request_rejected':\n            ui.showNotification(`${data.payload.user.username} rejected your friend request.`, 'info'); // Updated payload access\n            main.refreshPendingRequests();\n            break;\n        case 'unfriended':\n            ui.showNotification(`${data.payload.user.username} unfriended you.`, 'info'); // Updated payload access\n            main.refreshFriendsList();\n            break;\n        case 'group_joined':\n            ui.showNotification(`You joined the group: ${data.payload.group.name}`, 'success');\n            main.refreshGroupsList();\n            break;\n        case 'group_member_added':\n            ui.showNotification(`${data.payload.adder.username} added you to ${data.payload.group.name}`, 'info');\n            main.refreshGroupsList();\n            break;\n        // Removed other group events as they are not in attempted content\n        default:\n            console.warn('Unhandled event type:', data.type); // Added default warning\n    }\n}\n\nexport function connect() {\n    const token = store.getAccessToken(); // Used store.getAccessToken()\n    if (!token) {\n        console.log(\"No access token, WebSocket connection aborted.\");\n        return;\n    }\n\n    // Prevent multiple connections\n    if (socket \u0026\u0026 socket.readyState === WebSocket.OPEN) {\n        console.log(\"WebSocket is already connected.\");\n        return;\n    }\n\n    const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';\n    const host = window.location.host;\n    socket = new WebSocket(`${protocol}//${host}/api/v1/ws`); // Updated WebSocket URL\n\n    socket.onopen = () =\u003e {\n        console.log('WebSocket connected');\n        reconnectInterval = 1000; // Reset reconnect interval on successful connection\n        // Send auth event\n        send('auth', { token: token }); // Explicitly send token in payload\n        ui.showNotification('Connected to real-time service.', 'success'); // Kept notification\n    };\n\n    socket.onmessage = handleIncomingEvent;\n\n    socket.onclose = () =\u003e {\n        console.log('WebSocket disconnected. Attempting to reconnect...');\n        ui.showNotification('Real-time connection lost. Attempting to reconnect...', 'error'); // Kept notification\n        setTimeout(connect, reconnectInterval);\n        reconnectInterval = Math.min(reconnectInterval * 2, 30000); // Exponential backoff up to 30s\n    };\n\n    socket.onerror = (error) =\u003e {\n        console.error('WebSocket error:', error);\n        ui.showNotification('A real-time connection error occurred.', 'error'); // Kept notification\n        socket.close(); // This will trigger the onclose handler for reconnection\n    };\n}\n\n/**\n * Sends a message over the WebSocket connection.\n * @param {string} type - The type of the message.\n * @param {object} payload - The payload of the message.\n */\nexport function send(type, payload) {\n    if (socket \u0026\u0026 socket.readyState === WebSocket.OPEN) {\n        const message = JSON.stringify({ type, payload });\n        socket.send(message);\n    } else {\n        console.error('WebSocket is not connected.');\n        ui.showNotification('Not connected to server.', 'error'); // Kept notification\n    }\n}",
  "backend/web/templates/chat.html": "\u003c!DOCTYPE html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n    \u003cmeta charset=\"UTF-8\"\u003e\n    \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"\u003e\n    \u003ctitle\u003eQuikChat\u003c/title\u003e\n    \u003cscript src=\"https://cdn.tailwindcss.com\"\u003e\u003c/script\u003e\n\u003c/head\u003e\n\u003cbody class=\"bg-gray-900 text-gray-200 font-sans\"\u003e\n    \u003cdiv id=\"notification-container\" class=\"fixed bottom-5 right-5 z-50\"\u003e\u003c/div\u003e\n\n    \u003cdiv class=\"flex h-screen\"\u003e\n        \u003c!-- Sidebar --\u003e\n        \u003caside class=\"w-80 bg-gray-800 flex flex-col\"\u003e\n            \u003c!-- Profile Section --\u003e\n            \u003cdiv id=\"profile-container\" class=\"flex items-center p-4 border-b border-gray-700\"\u003e\n                \u003c!-- JS will render this --\u003e\n            \u003c/div\u003e\n\n            \u003c!-- Friends Section --\u003e\n            \u003cdiv id=\"friends-container\" class=\"p-4 border-b border-gray-700\"\u003e\n                \u003cdiv class=\"flex justify-between items-center mb-2\"\u003e\n                    \u003ch2 class=\"text-lg font-semibold text-white\"\u003eFriends\u003c/h2\u003e\n                    \u003cbutton id=\"add-friend-btn\" class=\"bg-blue-500 hover:bg-blue-600 text-white px-2 py-1 text-xs rounded\"\u003eAdd Friend\u003c/button\u003e\n                \u003c/div\u003e\n                \u003cul id=\"friends-list\" class=\"space-y-1 max-h-48 overflow-y-auto\"\u003e\n                    \u003c!-- JS will render this --\u003e\n                \u003c/ul\u003e\n            \u003c/div\u003e\n\n            \u003c!-- Groups Section --\u003e\n            \u003cdiv id=\"groups-container\" class=\"p-4 flex-grow overflow-y-auto\"\u003e\n                \u003cdiv class=\"flex justify-between items-center mb-2\"\u003e\n                    \u003ch2 class=\"text-lg font-semibold text-white\"\u003eGroups\u003c/h2\u003e\n                    \u003cdiv\u003e\n                        \u003cbutton id=\"find-group-btn\" class=\"bg-gray-600 hover:bg-gray-500 text-white px-2 py-1 text-xs rounded mr-1\"\u003eFind\u003c/button\u003e\n                        \u003cbutton id=\"create-group-btn\" class=\"bg-green-500 hover:bg-green-600 text-white px-2 py-1 text-xs rounded\"\u003eCreate\u003c/button\u003e\n                    \u003c/div\u003e\n                \u003c/div\u003e\n                \u003cul id=\"groups-list\" class=\"space-y-2\"\u003e\n                    \u003c!-- JS will render this --\u003e\n                \u003c/ul\u003e\n            \u003c/div\u003e\n\n            \u003c!-- Pending Requests Section --\u003e\n            \u003cdiv id=\"pending-requests-container\" class=\"p-4 border-t border-gray-700\"\u003e\n                \u003ch3 class=\"text-md font-semibold text-white mb-2\"\u003ePending Requests\u003c/h3\u003e\n                \u003cul id=\"pending-requests-list\" class=\"space-y-1 max-h-32 overflow-y-auto\"\u003e\n                    \u003c!-- JS will render this --\u003e\n                \u003c/ul\u003e\n            \u003c/div\u003e\n\n            \u003c!-- User Actions --\u003e\n            \u003cdiv class=\"p-4 border-t border-gray-700 mt-auto\"\u003e\n                \u003cform id=\"profile-update-form\" class=\"space-y-2 text-sm\"\u003e\n                    \u003cinput type=\"text\" name=\"username\" placeholder=\"New Username\" class=\"w-full bg-gray-700 p-2 rounded border border-gray-600 focus:outline-none focus:border-blue-500\"\u003e\n                    \u003cinput type=\"password\" name=\"password\" placeholder=\"New Password\" class=\"w-full bg-gray-700 p-2 rounded border border-gray-600 focus:outline-none focus:border-blue-500\"\u003e\n                    \u003cinput type=\"file\" name=\"profile_pic\" class=\"w-full text-gray-400 file:mr-4 file:py-1 file:px-2 file:rounded file:border-0 file:text-xs file:font-semibold file:bg-gray-600 file:text-gray-300 hover:file:bg-gray-500\"\u003e\n                    \u003cbutton type=\"submit\" class=\"w-full bg-indigo-500 hover:bg-indigo-600 text-white p-2 rounded\"\u003eUpdate Profile\u003c/button\u003e\n                \u003c/form\u003e\n                \u003cbutton id=\"logout-button\" class=\"w-full mt-2 bg-red-600 hover:bg-red-700 text-white p-2 rounded\"\u003eLogout\u003c/button\u003e\n            \u003c/div\u003e\n        \u003c/aside\u003e\n\n        \u003c!-- Main Chat Area --\u003e\n        \u003cmain class=\"flex-1 flex flex-col bg-gray-900\"\u003e\n            \u003cdiv id=\"chat-container\" class=\"flex flex-col h-full hidden\"\u003e\n                \u003c!-- Chat Header --\u003e\n                \u003cheader id=\"chat-header\" class=\"flex items-center p-4 bg-gray-800 border-b border-gray-700\"\u003e\n                    \u003c!-- JS will render this --\u003e\n                \u003c/header\u003e\n\n                \u003c!-- Messages --\u003e\n                \u003cdiv id=\"messages-container\" class=\"flex-grow overflow-y-auto p-4 space-y-4\"\u003e\n                    \u003c!-- JS will render messages here --\u003e\n                \u003c/div\u003e\n\n                \u003c!-- Message Input --\u003e\n                \u003cform id=\"message-form\" class=\"p-4 bg-gray-800 border-t border-gray-700\"\u003e\n                    \u003cinput type=\"text\" name=\"message\" placeholder=\"Type a message...\" autocomplete=\"off\"\n                           class=\"w-full bg-gray-700 p-3 rounded-lg border border-gray-600 focus:outline-none focus:border-blue-500 text-white\"\u003e\n                \u003c/form\u003e\n            \u003c/div\u003e\n            \u003cdiv id=\"welcome-screen\" class=\"flex items-center justify-center h-full\"\u003e\n                \u003cp class=\"text-gray-500 text-xl\"\u003eSelect a conversation to start chatting\u003c/p\u003e\n            \u003c/div\u003e\n        \u003c/main\u003e\n    \u003c/div\u003e\n\n    \u003c!-- Modals --\u003e\n    \u003c!-- Add Friend Modal --\u003e\n    \u003cdiv id=\"add-friend-modal\" class=\"fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center hidden\"\u003e\n        \u003cdiv class=\"modal-overlay absolute w-full h-full\"\u003e\u003c/div\u003e\n        \u003cdiv class=\"bg-gray-800 p-6 rounded-lg z-10 w-full max-w-md\"\u003e\n            \u003ch3 class=\"text-xl font-semibold mb-4\"\u003eAdd a Friend\u003c/h3\u003e\n            \u003cform id=\"add-friend-form\"\u003e\n                \u003cinput type=\"text\" name=\"username\" placeholder=\"Enter username\" class=\"w-full bg-gray-700 p-2 rounded border border-gray-600 mb-4\" required\u003e\n                \u003cdiv class=\"flex justify-end\"\u003e\n                    \u003cbutton type=\"button\" class=\"modal-close bg-gray-600 text-white px-4 py-2 rounded mr-2\"\u003eCancel\u003c/button\u003e\n                    \u003cbutton type=\"submit\" class=\"bg-blue-500 text-white px-4 py-2 rounded\"\u003eSend Request\u003c/button\u003e\n                \u003c/div\u003e\n            \u003c/form\u003e\n        \u003c/div\u003e\n    \u003c/div\u003e\n\n    \u003c!-- Create Group Modal --\u003e\n    \u003cdiv id=\"create-group-modal\" class=\"fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center hidden\"\u003e\n        \u003cdiv class=\"modal-overlay absolute w-full h-full\"\u003e\u003c/div\u003e\n        \u003cdiv class=\"bg-gray-800 p-6 rounded-lg z-10 w-full max-w-md\"\u003e\n            \u003ch3 class=\"text-xl font-semibold mb-4\"\u003eCreate a Group\u003c/h3\u003e\n            \u003cform id=\"create-group-form\" class=\"space-y-4\"\u003e\n                \u003cinput type=\"text\" name=\"handle\" placeholder=\"Group Handle (e.g., #cooldevs)\" class=\"w-full bg-gray-700 p-2 rounded border border-gray-600\" required\u003e\n                \u003cinput type=\"text\" name=\"name\" placeholder=\"Group Name\" class=\"w-full bg-gray-700 p-2 rounded border border-gray-600\" required\u003e\n                \u003cinput type=\"file\" name=\"group_photo\" class=\"w-full text-gray-400 file:mr-4 file:py-1 file:px-2 file:rounded file:border-0 file:text-xs file:font-semibold file:bg-gray-600 file:text-gray-300 hover:file:bg-gray-500\"\u003e\n                \u003cdiv class=\"flex justify-end\"\u003e\n                    \u003cbutton type=\"button\" class=\"modal-close bg-gray-600 text-white px-4 py-2 rounded mr-2\"\u003eCancel\u003c/button\u003e\n                    \u003cbutton type=\"submit\" class=\"bg-green-500 text-white px-4 py-2 rounded\"\u003eCreate\u003c/button\u003e\n                \u003c/div\u003e\n            \u003c/form\u003e\n        \u003c/div\u003e\n    \u003c/div\u003e\n\n    \u003c!-- Search Group Modal --\u003e\n    \u003cdiv id=\"search-group-modal\" class=\"fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center hidden\"\u003e\n        \u003cdiv class=\"modal-overlay absolute w-full h-full\"\u003e\u003c/div\u003e\n        \u003cdiv class=\"bg-gray-800 p-6 rounded-lg z-10 w-full max-w-lg\"\u003e\n            \u003ch3 class=\"text-xl font-semibold mb-4\"\u003eFind and Join Groups\u003c/h3\u003e\n            \u003cinput type=\"search\" id=\"group-search-input\" placeholder=\"Search by handle...\" class=\"w-full bg-gray-700 p-2 rounded border border-gray-600 mb-4\"\u003e\n            \u003cdiv id=\"group-search-results\" class=\"max-h-64 overflow-y-auto\"\u003e\n                \u003c!-- Search results will be rendered here --\u003e\n            \u003c/div\u003e\n            \u003cdiv class=\"flex justify-end mt-4\"\u003e\n                \u003cbutton type=\"button\" class=\"modal-close bg-gray-600 text-white px-4 py-2 rounded\"\u003eClose\u003c/button\u003e\n            \u003c/div\u003e\n        \u003c/div\u003e\n    \u003c/div\u003e\n\n    \u003cscript type=\"module\" src=\"/static/js/main.js\"\u003e\u003c/script\u003e\n\u003c/body\u003e\n\u003c/html\u003e",
  "backend/web/templates/index.html": "\u003c!DOCTYPE html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n    \u003cmeta charset=\"UTF-8\"\u003e\n    \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"\u003e\n    \u003ctitle\u003eWelcome to QuikChat\u003c/title\u003e\n    \u003cscript src=\"https://cdn.tailwindcss.com\"\u003e\u003c/script\u003e\n\u003c/head\u003e\n\u003cbody class=\"bg-gray-100 flex items-center justify-center h-screen\"\u003e\n    \u003cdiv class=\"w-full max-w-md\"\u003e\n        \u003c!-- Login Form --\u003e\n        \u003cdiv id=\"login-container\"\u003e\n            \u003cform id=\"login-form\" class=\"bg-white shadow-md rounded px-8 pt-6 pb-8 mb-4\"\u003e\n                \u003ch1 class=\"text-2xl font-bold text-center mb-6\"\u003eLogin to QuikChat\u003c/h1\u003e\n                \u003cdiv class=\"mb-4\"\u003e\n                    \u003clabel class=\"block text-gray-700 text-sm font-bold mb-2\" for=\"login-username\"\u003e\n                        Username\n                    \u003c/label\u003e\n                    \u003cinput class=\"shadow appearance-none border rounded w-full py-2 px-3 text-gray-700 leading-tight focus:outline-none focus:shadow-outline\" id=\"login-username\" name=\"username\" type=\"text\" placeholder=\"Username\" required\u003e\n                \u003c/div\u003e\n                \u003cdiv class=\"mb-6\"\u003e\n                    \u003clabel class=\"block text-gray-700 text-sm font-bold mb-2\" for=\"login-password\"\u003e\n                        Password\n                    \u003c/label\u003e\n                    \u003cinput class=\"shadow appearance-none border rounded w-full py-2 px-3 text-gray-700 mb-3 leading-tight focus:outline-none focus:shadow-outline\" id=\"login-password\" name=\"password\" type=\"password\" placeholder=\"******************\" required\u003e\n                \u003c/div\u003e\n                \u003cp class=\"error-message text-red-500 text-xs italic mb-4 hidden\"\u003e\u003c/p\u003e\n                \u003cdiv class=\"flex items-center justify-between\"\u003e\n                    \u003cbutton class=\"bg-blue-500 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded focus:outline-none focus:shadow-outline\" type=\"submit\"\u003e\n                        Sign In\n                    \u003c/button\u003e\n                    \u003ca id=\"show-signup-form\" class=\"inline-block align-baseline font-bold text-sm text-blue-500 hover:text-blue-800\" href=\"#\"\u003e\n                        Create an Account\n                    \u003c/a\u003e\n                \u003c/div\u003e\n            \u003c/form\u003e\n        \u003c/div\u003e\n\n        \u003c!-- Signup Form --\u003e\n        \u003cdiv id=\"signup-container\" class=\"hidden\"\u003e\n            \u003cform id=\"signup-form\" class=\"bg-white shadow-md rounded px-8 pt-6 pb-8 mb-4\"\u003e\n                \u003ch1 class=\"text-2xl font-bold text-center mb-6\"\u003eCreate Account\u003c/h1\u003e\n                \u003cdiv class=\"mb-4\"\u003e\n                    \u003clabel class=\"block text-gray-700 text-sm font-bold mb-2\" for=\"signup-username\"\u003e\n                        Username\n                    \u003c/label\u003e\n                    \u003cinput class=\"shadow appearance-none border rounded w-full py-2 px-3 text-gray-700 leading-tight focus:outline-none focus:shadow-outline\" id=\"signup-username\" name=\"username\" type=\"text\" placeholder=\"lowercase, 0-9, _\" required minlength=\"4\" maxlength=\"50\"\u003e\n                \u003c/div\u003e\n                \u003cdiv class=\"mb-6\"\u003e\n                    \u003clabel class=\"block text-gray-700 text-sm font-bold mb-2\" for=\"signup-password\"\u003e\n                        Password\n                    \u003c/label\u003e\n                    \u003cinput class=\"shadow appearance-none border rounded w-full py-2 px-3 text-gray-700 mb-3 leading-tight focus:outline-none focus:shadow-outline\" id=\"signup-password\" name=\"password\" type=\"password\" placeholder=\"******************\" required minlength=\"8\"\u003e\n                \u003c/div\u003e\n                \u003cp class=\"error-message text-red-500 text-xs italic mb-4 hidden\"\u003e\u003c/p\u003e\n                \u003cdiv class=\"flex items-center justify-between\"\u003e\n                    \u003cbutton class=\"bg-green-500 hover:bg-green-700 text-white font-bold py-2 px-4 rounded focus:outline-none focus:shadow-outline\" type=\"submit\"\u003e\n                        Sign Up\n                    \u003c/button\u003e\n                    \u003ca id=\"show-login-form\" class=\"inline-block align-baseline font-bold text-sm text-blue-500 hover:text-blue-800\" href=\"#\"\u003e\n                        Already have an account?\n                    \u003c/a\u003e\n                \u003c/div\u003e\n            \u003c/form\u003e\n        \u003c/div\u003e\n        \u003cp class=\"text-center text-gray-500 text-xs\"\u003e\n            \u0026copy;2024 QuikChat. All rights reserved.\n        \u003c/p\u003e\n    \u003c/div\u003e\n    \u003cscript type=\"module\" src=\"/static/js/main.js\"\u003e\u003c/script\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n```",
  "docker-compose.yml": "version: '3.8'\n\nservices:\n  postgres:\n    image: postgres:13\n    restart: always\n    environment:\n      POSTGRES_USER: user\n      POSTGRES_PASSWORD: password\n      POSTGRES_DB: chatdb\n    ports:\n      - \"5432:5432\"  # Expose Postgres port to host\n    volumes:\n      - postgres_data:/var/lib/postgresql/data\n\n  redis:\n    image: redis:6-alpine\n    restart: always\n    ports:\n      - \"6379:6379\"  # Expose Redis port to host\n    volumes:\n      - redis_data:/data\n\nvolumes:\n  postgres_data:\n  redis_data:\n"
}