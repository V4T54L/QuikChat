{
  "Makefile": ".PHONY: up down logs psql migrate-up run build\n\n# Docker Compose commands\nup:\n\t@echo \"Starting Docker containers...\"\n\tdocker-compose up -d\n\ndown:\n\t@echo \"Stopping Docker containers...\"\n\tdocker-compose down\n\nlogs:\n\t@echo \"Tailing logs...\"\n\tdocker-compose logs -f\n\n# Database commands\npsql:\n\t@echo \"Connecting to PostgreSQL container...\"\n\tdocker-compose exec postgres psql -U user -d chatdb\n\nmigrate-up:\n\t@echo \"Applying database migrations...\"\n\tdocker-compose exec -T postgres psql -U user -d chatdb \u003c backend/migrations/000001_create_users_table.up.sql\n\tdocker-compose exec -T postgres psql -U user -d chatdb \u003c backend/migrations/000002_create_sessions_table.up.sql\n\n# Go application commands\nrun:\n\t@echo \"Running the Go application...\"\n\tgo run ./backend/cmd/server/main.go\n\nbuild:\n\t@echo \"Building the Go application...\"\n\tgo build -o ./bin/server ./backend/cmd/server/main.go\n",
  "backend/cmd/server/main.go": "package main\n\nimport (\n\t\"context\"\n\t\"log\"\n\t\"time\"\n\n\t\"chat-app/internal/adapter/localfile\"\n\t\"chat-app/internal/adapter/postgres\"\n\t\"chat-app/internal/adapter/redis\"\n\t\"chat-app/internal/delivery/http\" // Changed from router\n\t\"chat-app/internal/delivery/websocket\"\n\t\"chat-app/internal/service\"\n\t\"chat-app/pkg/config\"\n\n\tnethttp \"net/http\" // Alias for standard http package\n)\n\nfunc main() {\n\tlog.Println(\"Starting QuikChat server...\")\n\n\t// Load configuration\n\tcfg := config.Load()\n\n\t// Initialize database connection\n\tdbPool := postgres.NewDB(cfg.DatabaseURL) // Changed variable name to dbPool\n\tdefer dbPool.Close()\n\tlog.Println(\"Database connection established.\")\n\n\t// Initialize Redis client\n\tredisClient := redis.NewClient(cfg.RedisURL)\n\n\t// Initialize repositories\n\tuserRepo := postgres.NewPostgresUserRepository(dbPool)\n\tsessionRepo := postgres.NewPostgresSessionRepository(dbPool)\n\tfileRepo, err := localfile.NewLocalFileRepository(cfg.UploadDir)\n\tif err != nil {\n\t\tlog.Fatalf(\"failed to create file repository: %v\", err)\n\t}\n\tredisEventRepo := redis.NewRedisEventRepository(redisClient)\n\tpgEventRepo := postgres.NewPostgresEventRepository(dbPool)\n\tfriendRepo := postgres.NewPostgresFriendRepository(dbPool)\n\tgroupRepo := postgres.NewPostgresGroupRepository(dbPool) // Added groupRepo\n\n\t// Initialize use cases/services\n\tauthUsecase := service.NewAuthService(userRepo, sessionRepo, cfg)\n\tuserUsecase := service.NewUserService(userRepo, fileRepo)\n\teventUsecase := service.NewEventService(redisEventRepo, pgEventRepo, userRepo)\n\tfriendUsecase := service.NewFriendService(friendRepo, userRepo, eventUsecase)\n\tgroupUsecase := service.NewGroupService(groupRepo, userRepo, friendRepo, fileRepo, eventUsecase) // Added groupUsecase\n\n\t// Initialize WebSocket Hub\n\thub := websocket.NewHub(eventUsecase)\n\tgo hub.Run()\n\n\t// Start background worker for event persistence\n\tgo func() {\n\t\tticker := time.NewTicker(1 * time.Minute) // Run every minute\n\t\tdefer ticker.Stop()\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase \u003c-ticker.C:\n\t\t\t\tlog.Println(\"Running background worker to persist events...\")\n\t\t\t\tif err := eventUsecase.PersistBufferedEvents(context.Background()); err != nil {\n\t\t\t\t\tlog.Printf(\"Error persisting buffered events: %v\", err)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}()\n\n\t// Initialize router\n\trouter := http.NewRouter(cfg, authUsecase, userUsecase, friendUsecase, groupUsecase, hub) // Updated router package and added groupUsecase\n\n\t// Start server\n\tlog.Printf(\"Server starting on port %s\", cfg.Port)\n\tif err := nethttp.ListenAndServe(\":\"+cfg.Port, router); err != nil \u0026\u0026 err != nethttp.ErrServerClosed { // Used nethttp alias\n\t\tlog.Fatalf(\"Failed to start server: %v\", err)\n\t}\n}\n",
  "backend/go.mod": "module chat-app\n\ngo 1.24.0\n",
  "backend/internal/adapter/localfile/file_repository.go": "package localfile\n\nimport (\n\t\"chat-app/internal/repository\"\n\t\"chat-app/pkg/util\"\n\t\"context\"\n\t\"fmt\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"strings\"\n)\n\ntype localFileRepository struct {\n\tuploadDir string\n}\n\nfunc NewLocalFileRepository(uploadDir string) (repository.FileRepository, error) {\n\tif err := os.MkdirAll(uploadDir, os.ModePerm); err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to create upload directory: %w\", err)\n\t}\n\treturn \u0026localFileRepository{uploadDir: uploadDir}, nil\n}\n\nfunc (r *localFileRepository) SaveProfilePicture(_ context.Context, fileData []byte, fileType string) (string, error) {\n\tvar ext string\n\tswitch fileType {\n\tcase \"image/jpeg\", \"image/jpg\":\n\t\text = \".jpg\"\n\tcase \"image/png\":\n\t\text = \".png\"\n\tcase \"image/webp\":\n\t\text = \".webp\"\n\tdefault:\n\t\treturn \"\", fmt.Errorf(\"unsupported file type: %s\", fileType)\n\t}\n\n\tfilename := util.NewUUID() + ext\n\tfilePath := filepath.Join(r.uploadDir, filename)\n\n\terr := os.WriteFile(filePath, fileData, 0644)\n\tif err != nil {\n\t\treturn \"\", fmt.Errorf(\"failed to write file: %w\", err)\n\t}\n\n\treturn filename, nil\n}\n",
  "backend/internal/adapter/postgres/event_repository.go": "package postgres\n\nimport (\n\t\"chat-app/internal/domain\"\n\t\"chat-app/internal/repository\"\n\t\"context\"\n\t\"fmt\"\n\t\"github.com/jackc/pgx/v5/pgxpool\"\n)\n\ntype postgresEventRepository struct {\n\tdb *pgxpool.Pool\n}\n\nfunc NewPostgresEventRepository(db *pgxpool.Pool) repository.EventRepository {\n\treturn \u0026postgresEventRepository{db: db}\n}\n\nfunc (r *postgresEventRepository) StoreEvents(ctx context.Context, events []*domain.Event) error {\n\tif len(events) == 0 {\n\t\treturn nil\n\t}\n\n\ttx, err := r.db.Begin(ctx)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to begin transaction: %w\", err)\n\t}\n\tdefer tx.Rollback(ctx)\n\n\tquery := `INSERT INTO events (id, type, payload, recipient_id, created_at) VALUES ($1, $2, $3, $4, $5)`\n\tfor _, event := range events {\n\t\t_, err := tx.Exec(ctx, query, event.ID, event.Type, event.Payload, event.RecipientID, event.CreatedAt)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"failed to insert event: %w\", err)\n\t\t}\n\t}\n\n\treturn tx.Commit(ctx)\n}\n\nfunc (r *postgresEventRepository) GetUndeliveredEvents(ctx context.Context, userID string) ([]*domain.Event, error) {\n\tquery := `SELECT id, type, payload, recipient_id, is_delivered, created_at FROM events WHERE recipient_id = $1 AND is_delivered = FALSE ORDER BY created_at ASC`\n\trows, err := r.db.Query(ctx, query, userID)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to query undelivered events: %w\", err)\n\t}\n\tdefer rows.Close()\n\n\tvar events []*domain.Event\n\tfor rows.Next() {\n\t\tvar event domain.Event\n\t\tif err := rows.Scan(\u0026event.ID, \u0026event.Type, \u0026event.Payload, \u0026event.RecipientID, \u0026event.IsDelivered, \u0026event.CreatedAt); err != nil {\n\t\t\treturn nil, fmt.Errorf(\"failed to scan event row: %w\", err)\n\t\t}\n\t\tevents = append(events, \u0026event)\n\t}\n\treturn events, nil\n}\n\nfunc (r *postgresEventRepository) MarkEventsAsDelivered(ctx context.Context, eventIDs []string) error {\n\tif len(eventIDs) == 0 {\n\t\treturn nil\n\t}\n\tquery := `UPDATE events SET is_delivered = TRUE WHERE id = ANY($1::uuid[])`\n\t_, err := r.db.Exec(ctx, query, eventIDs)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to mark events as delivered: %w\", err)\n\t}\n\treturn nil\n}\n\n// These methods are for the Redis implementation, so they are no-ops here.\nfunc (r *postgresEventRepository) BufferEvent(ctx context.Context, event *domain.Event) error {\n\treturn nil\n}\nfunc (r *postgresEventRepository) GetBufferedEventsForUser(ctx context.Context, userID string) ([]*domain.Event, error) {\n\treturn nil, nil\n}\nfunc (r *postgresEventRepository) ClearUserBuffer(ctx context.Context, userID string) error {\n\treturn nil\n}\n",
  "backend/internal/adapter/postgres/friend_repository.go": "package postgres\n\nimport (\n\t\"context\"\n\t\"database/sql\"\n\t\"errors\"\n\t\"fmt\"\n\t\"time\"\n\n\t\"chat-app/internal/domain\"\n\t\"chat-app/internal/repository\"\n\n\t\"github.com/jackc/pgx/v5\"\n\t\"github.com/jackc/pgx/v5/pgconn\"\n\t\"github.com/jackc/pgx/v5/pgxpool\"\n)\n\ntype postgresFriendRepository struct {\n\tdb *pgxpool.Pool\n}\n\nfunc NewPostgresFriendRepository(db *pgxpool.Pool) repository.FriendRepository {\n\treturn \u0026postgresFriendRepository{db: db}\n}\n\nfunc (r *postgresFriendRepository) CreateRequest(ctx context.Context, req *domain.FriendRequest) error {\n\tquery := `\n        INSERT INTO friend_requests (id, sender_id, receiver_id, status, created_at, updated_at)\n        VALUES ($1, $2, $3, $4, $5, $6)\n    `\n\t_, err := r.db.Exec(ctx, query, req.ID, req.SenderID, req.ReceiverID, req.Status, req.CreatedAt, req.UpdatedAt)\n\tif err != nil {\n\t\tvar pgErr *pgconn.PgError\n\t\tif errors.As(err, \u0026pgErr) \u0026\u0026 pgErr.Code == \"23505\" { // unique_violation\n\t\t\treturn repository.ErrFriendRequestExists\n\t\t}\n\t\treturn fmt.Errorf(\"failed to create friend request: %w\", err)\n\t}\n\treturn nil\n}\n\nfunc (r *postgresFriendRepository) GetRequestByID(ctx context.Context, id string) (*domain.FriendRequest, error) {\n\tquery := `\n        SELECT id, sender_id, receiver_id, status, created_at, updated_at\n        FROM friend_requests\n        WHERE id = $1\n    `\n\treq := \u0026domain.FriendRequest{}\n\terr := r.db.QueryRow(ctx, query, id).Scan(\u0026req.ID, \u0026req.SenderID, \u0026req.ReceiverID, \u0026req.Status, \u0026req.CreatedAt, \u0026req.UpdatedAt)\n\tif err != nil {\n\t\tif errors.Is(err, pgx.ErrNoRows) {\n\t\t\treturn nil, repository.ErrNotFound\n\t\t}\n\t\treturn nil, fmt.Errorf(\"failed to get friend request by id: %w\", err)\n\t}\n\treturn req, nil\n}\n\nfunc (r *postgresFriendRepository) UpdateRequestStatus(ctx context.Context, id, status string) error {\n\tquery := `\n        UPDATE friend_requests\n        SET status = $1, updated_at = $2\n        WHERE id = $3\n    `\n\tcmdTag, err := r.db.Exec(ctx, query, status, time.Now().UTC(), id)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to update friend request status: %w\", err)\n\t}\n\tif cmdTag.RowsAffected() == 0 {\n\t\treturn repository.ErrNotFound\n\t}\n\treturn nil\n}\n\nfunc (r *postgresFriendRepository) AreFriends(ctx context.Context, userID1, userID2 string) (bool, error) {\n\tif userID1 \u003e userID2 {\n\t\tuserID1, userID2 = userID2, userID1\n\t}\n\tquery := `\n        SELECT EXISTS (\n            SELECT 1 FROM friendships WHERE user_id1 = $1 AND user_id2 = $2\n        )\n    `\n\tvar exists bool\n\terr := r.db.QueryRow(ctx, query, userID1, userID2).Scan(\u0026exists)\n\tif err != nil {\n\t\treturn false, fmt.Errorf(\"failed to check friendship: %w\", err)\n\t}\n\treturn exists, nil\n}\n\nfunc (r *postgresFriendRepository) AddFriendship(ctx context.Context, userID1, userID2 string) error {\n\tif userID1 \u003e userID2 {\n\t\tuserID1, userID2 = userID2, userID1\n\t}\n\tquery := `\n        INSERT INTO friendships (user_id1, user_id2)\n        VALUES ($1, $2)\n        ON CONFLICT (user_id1, user_id2) DO NOTHING\n    `\n\t_, err := r.db.Exec(ctx, query, userID1, userID2)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to add friendship: %w\", err)\n\t}\n\treturn nil\n}\n\nfunc (r *postgresFriendRepository) RemoveFriendship(ctx context.Context, userID1, userID2 string) error {\n\tif userID1 \u003e userID2 {\n\t\tuserID1, userID2 = userID2, userID1\n\t}\n\tquery := `\n        DELETE FROM friendships\n        WHERE user_id1 = $1 AND user_id2 = $2\n    `\n\t_, err := r.db.Exec(ctx, query, userID1, userID2)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to remove friendship: %w\", err)\n\t}\n\treturn nil\n}\n\nfunc (r *postgresFriendRepository) GetPendingRequests(ctx context.Context, userID string) ([]*domain.FriendRequest, error) {\n\tquery := `\n        SELECT fr.id, fr.sender_id, fr.receiver_id, fr.status, fr.created_at, fr.updated_at,\n               s.username as sender_username, s.profile_pic_url as sender_profile_pic_url,\n               rc.username as receiver_username, rc.profile_pic_url as receiver_profile_pic_url\n        FROM friend_requests fr\n        JOIN users s ON fr.sender_id = s.id\n        JOIN users rc ON fr.receiver_id = rc.id\n        WHERE (fr.receiver_id = $1 OR fr.sender_id = $1) AND fr.status = 'pending'\n        ORDER BY fr.created_at DESC\n    `\n\trows, err := r.db.Query(ctx, query, userID)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to get pending requests: %w\", err)\n\t}\n\tdefer rows.Close()\n\n\tvar requests []*domain.FriendRequest\n\tfor rows.Next() {\n\t\treq := \u0026domain.FriendRequest{\n\t\t\tSender:   \u0026domain.User{},\n\t\t\tReceiver: \u0026domain.User{},\n\t\t}\n\t\terr := rows.Scan(\n\t\t\t\u0026req.ID, \u0026req.SenderID, \u0026req.ReceiverID, \u0026req.Status, \u0026req.CreatedAt, \u0026req.UpdatedAt,\n\t\t\t\u0026req.Sender.Username, \u0026req.Sender.ProfilePicURL,\n\t\t\t\u0026req.Receiver.Username, \u0026req.Receiver.ProfilePicURL,\n\t\t)\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"failed to scan pending request: %w\", err)\n\t\t}\n\t\treq.Sender.ID = req.SenderID\n\t\treq.Receiver.ID = req.ReceiverID\n\t\trequests = append(requests, req)\n\t}\n\treturn requests, nil\n}\n\nfunc (r *postgresFriendRepository) GetFriendsByUserID(ctx context.Context, userID string) ([]*domain.User, error) {\n\tquery := `\n        SELECT u.id, u.username, u.profile_pic_url, u.created_at\n        FROM friendships f\n        JOIN users u ON u.id = CASE WHEN f.user_id1 = $1 THEN f.user_id2 ELSE f.user_id1 END\n        WHERE f.user_id1 = $1 OR f.user_id2 = $1\n        ORDER BY u.username\n    `\n\trows, err := r.db.Query(ctx, query, userID)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to get friends by user id: %w\", err)\n\t}\n\tdefer rows.Close()\n\n\tvar friends []*domain.User\n\tfor rows.Next() {\n\t\tfriend := \u0026domain.User{}\n\t\tvar createdAt sql.NullTime\n\t\terr := rows.Scan(\u0026friend.ID, \u0026friend.Username, \u0026friend.ProfilePicURL, \u0026createdAt)\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"failed to scan friend: %w\", err)\n\t\t}\n\t\tif createdAt.Valid {\n\t\t\tfriend.CreatedAt = createdAt.Time\n\t\t}\n\t\tfriends = append(friends, friend)\n\t}\n\treturn friends, nil\n}\n\nfunc (r *postgresFriendRepository) HasPendingRequest(ctx context.Context, userID1, userID2 string) (bool, error) {\n\tquery := `\n        SELECT EXISTS (\n            SELECT 1 FROM friend_requests\n            WHERE ((sender_id = $1 AND receiver_id = $2) OR (sender_id = $2 AND receiver_id = $1))\n            AND status = 'pending'\n        )\n    `\n\tvar exists bool\n\terr := r.db.QueryRow(ctx, query, userID1, userID2).Scan(\u0026exists)\n\tif err != nil {\n\t\treturn false, fmt.Errorf(\"failed to check for pending request: %w\", err)\n\t}\n\treturn exists, nil\n}\n",
  "backend/internal/adapter/postgres/group_repository.go": "package postgres\n\nimport (\n\t\"chat-app/internal/domain\"\n\t\"chat-app/internal/repository\"\n\t\"context\"\n\t\"errors\"\n\t\"fmt\"\n\n\t\"github.com/jackc/pgx/v5\"\n\t\"github.com/jackc/pgx/v5/pgconn\"\n\t\"github.com/jackc/pgx/v5/pgxpool\"\n)\n\ntype postgresGroupRepository struct {\n\tdb *pgxpool.Pool\n}\n\nfunc NewPostgresGroupRepository(db *pgxpool.Pool) repository.GroupRepository {\n\treturn \u0026postgresGroupRepository{db: db}\n}\n\nfunc (r *postgresGroupRepository) Create(ctx context.Context, group *domain.Group) error {\n\tquery := `INSERT INTO groups (id, handle, name, owner_id, profile_pic_url)\n              VALUES ($1, $2, $3, $4, $5)`\n\t_, err := r.db.Exec(ctx, query, group.ID, group.Handle, group.Name, group.OwnerID, group.ProfilePicURL)\n\tif err != nil {\n\t\tvar pgErr *pgconn.PgError\n\t\tif errors.As(err, \u0026pgErr) \u0026\u0026 pgErr.Code == \"23505\" { // unique_violation\n\t\t\treturn repository.ErrGroupHandleExists\n\t\t}\n\t\treturn fmt.Errorf(\"failed to create group: %w\", err)\n\t}\n\treturn nil\n}\n\nfunc (r *postgresGroupRepository) CreateMember(ctx context.Context, member *domain.GroupMember) error {\n\tquery := `INSERT INTO group_members (group_id, user_id, role) VALUES ($1, $2, $3)`\n\t_, err := r.db.Exec(ctx, query, member.GroupID, member.UserID, member.Role)\n\tif err != nil {\n\t\tvar pgErr *pgconn.PgError\n\t\tif errors.As(err, \u0026pgErr) \u0026\u0026 pgErr.Code == \"23505\" { // unique_violation\n\t\t\treturn repository.ErrGroupMemberExists\n\t\t}\n\t\treturn fmt.Errorf(\"failed to create group member: %w\", err)\n\t}\n\treturn nil\n}\n\nfunc (r *postgresGroupRepository) GetByID(ctx context.Context, id string) (*domain.Group, error) {\n\tquery := `SELECT id, handle, name, owner_id, profile_pic_url, created_at, updated_at\n              FROM groups WHERE id = $1`\n\tvar group domain.Group\n\terr := r.db.QueryRow(ctx, query, id).Scan(\n\t\t\u0026group.ID, \u0026group.Handle, \u0026group.Name, \u0026group.OwnerID,\n\t\t\u0026group.ProfilePicURL, \u0026group.CreatedAt, \u0026group.UpdatedAt,\n\t)\n\tif err != nil {\n\t\tif errors.Is(err, pgx.ErrNoRows) {\n\t\t\treturn nil, repository.ErrNotFound\n\t\t}\n\t\treturn nil, fmt.Errorf(\"failed to get group by id: %w\", err)\n\t}\n\treturn \u0026group, nil\n}\n\nfunc (r *postgresGroupRepository) GetByHandle(ctx context.Context, handle string) (*domain.Group, error) {\n\tquery := `SELECT id, handle, name, owner_id, profile_pic_url, created_at, updated_at\n              FROM groups WHERE handle = $1`\n\tvar group domain.Group\n\terr := r.db.QueryRow(ctx, query, handle).Scan(\n\t\t\u0026group.ID, \u0026group.Handle, \u0026group.Name, \u0026group.OwnerID,\n\t\t\u0026group.ProfilePicURL, \u0026group.CreatedAt, \u0026group.UpdatedAt,\n\t)\n\tif err != nil {\n\t\tif errors.Is(err, pgx.ErrNoRows) {\n\t\t\treturn nil, repository.ErrNotFound\n\t\t}\n\t\treturn nil, fmt.Errorf(\"failed to get group by handle: %w\", err)\n\t}\n\treturn \u0026group, nil\n}\n\nfunc (r *postgresGroupRepository) Update(ctx context.Context, group *domain.Group) error {\n\tquery := `UPDATE groups SET name = $1, owner_id = $2, profile_pic_url = $3, updated_at = NOW()\n              WHERE id = $4`\n\t_, err := r.db.Exec(ctx, query, group.Name, group.OwnerID, group.ProfilePicURL, group.ID)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to update group: %w\", err)\n\t}\n\treturn nil\n}\n\nfunc (r *postgresGroupRepository) FindMember(ctx context.Context, groupID, userID string) (*domain.GroupMember, error) {\n\tquery := `SELECT group_id, user_id, role, created_at FROM group_members\n              WHERE group_id = $1 AND user_id = $2`\n\tvar member domain.GroupMember\n\terr := r.db.QueryRow(ctx, query, groupID, userID).Scan(\n\t\t\u0026member.GroupID, \u0026member.UserID, \u0026member.Role, \u0026member.CreatedAt,\n\t)\n\tif err != nil {\n\t\tif errors.Is(err, pgx.ErrNoRows) {\n\t\t\treturn nil, repository.ErrNotFound\n\t\t}\n\t\treturn nil, fmt.Errorf(\"failed to find group member: %w\", err)\n\t}\n\treturn \u0026member, nil\n}\n\nfunc (r *postgresGroupRepository) RemoveMember(ctx context.Context, groupID, userID string) error {\n\tquery := `DELETE FROM group_members WHERE group_id = $1 AND user_id = $2`\n\tcmdTag, err := r.db.Exec(ctx, query, groupID, userID)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to remove group member: %w\", err)\n\t}\n\tif cmdTag.RowsAffected() == 0 {\n\t\treturn repository.ErrNotFound\n\t}\n\treturn nil\n}\n\nfunc (r *postgresGroupRepository) GetMembersWithUserDetails(ctx context.Context, groupID string) ([]*domain.GroupMember, error) {\n\tquery := `SELECT gm.group_id, gm.user_id, gm.role, gm.created_at,\n                     u.username, u.profile_pic_url\n              FROM group_members gm\n              JOIN users u ON gm.user_id = u.id\n              WHERE gm.group_id = $1\n              ORDER BY gm.created_at`\n\trows, err := r.db.Query(ctx, query, groupID)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to get group members: %w\", err)\n\t}\n\tdefer rows.Close()\n\n\tvar members []*domain.GroupMember\n\tfor rows.Next() {\n\t\tvar member domain.GroupMember\n\t\tmember.User = \u0026domain.User{}\n\t\terr := rows.Scan(\n\t\t\t\u0026member.GroupID, \u0026member.UserID, \u0026member.Role, \u0026member.CreatedAt,\n\t\t\t\u0026member.User.Username, \u0026member.User.ProfilePicURL,\n\t\t)\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"failed to scan group member: %w\", err)\n\t\t}\n\t\tmember.User.ID = member.UserID\n\t\tmembers = append(members, \u0026member)\n\t}\n\treturn members, nil\n}\n\nfunc (r *postgresGroupRepository) GetGroupsByUserID(ctx context.Context, userID string) ([]*domain.Group, error) {\n\tquery := `SELECT g.id, g.handle, g.name, g.owner_id, g.profile_pic_url, g.created_at, g.updated_at\n              FROM groups g\n              JOIN group_members gm ON g.id = gm.group_id\n              WHERE gm.user_id = $1\n              ORDER BY g.name`\n\trows, err := r.db.Query(ctx, query, userID)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to get groups by user id: %w\", err)\n\t}\n\tdefer rows.Close()\n\n\tvar groups []*domain.Group\n\tfor rows.Next() {\n\t\tvar group domain.Group\n\t\terr := rows.Scan(\n\t\t\t\u0026group.ID, \u0026group.Handle, \u0026group.Name, \u0026group.OwnerID,\n\t\t\t\u0026group.ProfilePicURL, \u0026group.CreatedAt, \u0026group.UpdatedAt,\n\t\t)\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"failed to scan group: %w\", err)\n\t\t}\n\t\tgroups = append(groups, \u0026group)\n\t}\n\treturn groups, nil\n}\n\nfunc (r *postgresGroupRepository) SearchByHandle(ctx context.Context, query string) ([]*domain.Group, error) {\n\tsqlQuery := `SELECT id, handle, name, owner_id, profile_pic_url, created_at, updated_at\n                 FROM groups WHERE handle ILIKE $1 LIMIT 20`\n\trows, err := r.db.Query(ctx, sqlQuery, \"%\"+query+\"%\")\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to search groups: %w\", err)\n\t}\n\tdefer rows.Close()\n\n\tvar groups []*domain.Group\n\tfor rows.Next() {\n\t\tvar group domain.Group\n\t\terr := rows.Scan(\n\t\t\t\u0026group.ID, \u0026group.Handle, \u0026group.Name, \u0026group.OwnerID,\n\t\t\t\u0026group.ProfilePicURL, \u0026group.CreatedAt, \u0026group.UpdatedAt,\n\t\t)\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"failed to scan group during search: %w\", err)\n\t\t}\n\t\tgroups = append(groups, \u0026group)\n\t}\n\treturn groups, nil\n}\n\nfunc (r *postgresGroupRepository) GetOldestMember(ctx context.Context, groupID, excludeUserID string) (*domain.GroupMember, error) {\n\tquery := `SELECT group_id, user_id, role, created_at FROM group_members\n              WHERE group_id = $1 AND user_id != $2\n              ORDER BY created_at ASC LIMIT 1`\n\tvar member domain.GroupMember\n\terr := r.db.QueryRow(ctx, query, groupID, excludeUserID).Scan(\n\t\t\u0026member.GroupID, \u0026member.UserID, \u0026member.Role, \u0026member.CreatedAt,\n\t)\n\tif err != nil {\n\t\tif errors.Is(err, pgx.ErrNoRows) {\n\t\t\treturn nil, repository.ErrNotFound\n\t\t}\n\t\treturn nil, fmt.Errorf(\"failed to get oldest group member: %w\", err)\n\t}\n\treturn \u0026member, nil\n}\n",
  "backend/internal/adapter/postgres/postgres.go": "package postgres\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"log\"\n\n\t\"github.com/jackc/pgx/v5/pgxpool\"\n)\n\nfunc NewDB(databaseURL string) *pgxpool.Pool {\n\tdbpool, err := pgxpool.New(context.Background(), databaseURL)\n\tif err != nil {\n\t\tlog.Fatalf(\"Unable to create connection pool: %v\\n\", err)\n\t}\n\n\terr = dbpool.Ping(context.Background())\n\tif err != nil {\n\t\tlog.Fatalf(\"Unable to ping database: %v\\n\", err)\n\t}\n\n\tfmt.Println(\"Successfully connected to PostgreSQL!\")\n\treturn dbpool\n}\n",
  "backend/internal/adapter/postgres/session_repository.go": "package postgres\n\nimport (\n\t\"context\"\n\t\"errors\"\n\n\t\"chat-app/internal/domain\"\n\t\"chat-app/internal/repository\"\n\n\t\"github.com/jackc/pgx/v5\"\n\t\"github.com/jackc/pgx/v5/pgxpool\"\n)\n\ntype postgresSessionRepository struct {\n\tdb *pgxpool.Pool\n}\n\nfunc NewPostgresSessionRepository(db *pgxpool.Pool) repository.SessionRepository {\n\treturn \u0026postgresSessionRepository{db: db}\n}\n\nfunc (r *postgresSessionRepository) Store(ctx context.Context, session *domain.Session) error {\n\tquery := `INSERT INTO sessions (id, user_id, expires_at) VALUES ($1, $2, $3)`\n\t_, err := r.db.Exec(ctx, query, session.ID, session.UserID, session.ExpiresAt)\n\treturn err\n}\n\nfunc (r *postgresSessionRepository) GetByID(ctx context.Context, id string) (*domain.Session, error) {\n\tquery := `SELECT id, user_id, expires_at, created_at FROM sessions WHERE id = $1`\n\n\tsession := \u0026domain.Session{}\n\terr := r.db.QueryRow(ctx, query, id).Scan(\n\t\t\u0026session.ID,\n\t\t\u0026session.UserID,\n\t\t\u0026session.ExpiresAt,\n\t\t\u0026session.CreatedAt,\n\t)\n\tif err != nil {\n\t\tif errors.Is(err, pgx.ErrNoRows) {\n\t\t\treturn nil, nil // Not found\n\t\t}\n\t\treturn nil, err\n\t}\n\treturn session, nil\n}\n\nfunc (r *postgresSessionRepository) Delete(ctx context.Context, id string) error {\n\tquery := `DELETE FROM sessions WHERE id = $1`\n\t_, err := r.db.Exec(ctx, query, id)\n\treturn err\n}\n\nfunc (r *postgresSessionRepository) DeleteAllForUser(ctx context.Context, userID string) error {\n\tquery := `DELETE FROM sessions WHERE user_id = $1`\n\t_, err := r.db.Exec(ctx, query, userID)\n\treturn err\n}\n",
  "backend/internal/adapter/postgres/user_repository.go": "package postgres\n\nimport (\n\t\"context\"\n\t\"errors\"\n\n\t\"chat-app/internal/domain\"\n\t\"chat-app/internal/repository\"\n\n\t\"github.com/jackc/pgx/v5\"\n\t\"github.com/jackc/pgx/v5/pgxpool\"\n)\n\ntype postgresUserRepository struct {\n\tdb *pgxpool.Pool\n}\n\nfunc NewPostgresUserRepository(db *pgxpool.Pool) repository.UserRepository {\n\treturn \u0026postgresUserRepository{db: db}\n}\n\nfunc (r *postgresUserRepository) Create(ctx context.Context, user *domain.User) error {\n\tquery := `INSERT INTO users (id, username, password_hash) VALUES ($1, $2, $3)`\n\t_, err := r.db.Exec(ctx, query, user.ID, user.Username, user.PasswordHash)\n\treturn err\n}\n\nfunc (r *postgresUserRepository) GetByUsername(ctx context.Context, username string) (*domain.User, error) {\n\tquery := `SELECT id, username, password_hash, profile_pic_url, created_at, updated_at FROM users WHERE username = $1`\n\tuser := \u0026domain.User{}\n\terr := r.db.QueryRow(ctx, query, username).Scan(\u0026user.ID, \u0026user.Username, \u0026user.PasswordHash, \u0026user.ProfilePicURL, \u0026user.CreatedAt, \u0026user.UpdatedAt)\n\tif err != nil {\n\t\tif errors.Is(err, pgx.ErrNoRows) {\n\t\t\treturn nil, nil\n\t\t}\n\t\treturn nil, err\n\t}\n\treturn user, nil\n}\n\nfunc (r *postgresUserRepository) GetByID(ctx context.Context, id string) (*domain.User, error) {\n\tquery := `SELECT id, username, password_hash, profile_pic_url, created_at, updated_at FROM users WHERE id = $1`\n\tuser := \u0026domain.User{}\n\terr := r.db.QueryRow(ctx, query, id).Scan(\u0026user.ID, \u0026user.Username, \u0026user.PasswordHash, \u0026user.ProfilePicURL, \u0026user.CreatedAt, \u0026user.UpdatedAt)\n\tif err != nil {\n\t\tif errors.Is(err, pgx.ErrNoRows) {\n\t\t\treturn nil, nil\n\t\t}\n\t\treturn nil, err\n\t}\n\treturn user, nil\n}\n\nfunc (r *postgresUserRepository) Update(ctx context.Context, user *domain.User) error {\n\tquery := `UPDATE users SET username = $1, password_hash = $2, profile_pic_url = $3, updated_at = NOW() WHERE id = $4`\n\t_, err := r.db.Exec(ctx, query, user.Username, user.PasswordHash, user.ProfilePicURL, user.ID)\n\treturn err\n}\n",
  "backend/internal/adapter/redis/event_repository.go": "package redis\n\nimport (\n\t\"chat-app/internal/domain\"\n\t\"chat-app/internal/repository\"\n\t\"context\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"github.com/redis/go-redis/v9\"\n\t\"time\"\n)\n\nconst (\n\tuserEventBufferKeyPrefix = \"events:\"\n\tbufferTTL                = 48 * time.Hour\n)\n\ntype redisEventRepository struct {\n\tclient *redis.Client\n}\n\nfunc NewRedisEventRepository(client *redis.Client) repository.EventRepository {\n\treturn \u0026redisEventRepository{client: client}\n}\n\nfunc (r *redisEventRepository) userBufferKey(userID string) string {\n\treturn fmt.Sprintf(\"%s%s\", userEventBufferKeyPrefix, userID)\n}\n\nfunc (r *redisEventRepository) BufferEvent(ctx context.Context, event *domain.Event) error {\n\tkey := r.userBufferKey(event.RecipientID)\n\n\teventJSON, err := json.Marshal(event)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to marshal event: %w\", err)\n\t}\n\n\tpipe := r.client.Pipeline()\n\tpipe.LPush(ctx, key, eventJSON)\n\tpipe.Expire(ctx, key, bufferTTL)\n\n\t_, err = pipe.Exec(ctx)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to execute redis pipeline for buffering event: %w\", err)\n\t}\n\treturn nil\n}\n\nfunc (r *redisEventRepository) GetBufferedEventsForUser(ctx context.Context, userID string) ([]*domain.Event, error) {\n\tkey := r.userBufferKey(userID)\n\teventStrings, err := r.client.LRange(ctx, key, 0, -1).Result()\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to get buffered events from redis: %w\", err)\n\t}\n\n\tevents := make([]*domain.Event, 0, len(eventStrings))\n\tfor _, eventStr := range eventStrings {\n\t\tvar event domain.Event\n\t\tif err := json.Unmarshal([]byte(eventStr), \u0026event); err != nil {\n\t\t\t// Log error but continue processing other events\n\t\t\tfmt.Printf(\"Error unmarshalling event from redis: %v\\n\", err)\n\t\t\tcontinue\n\t\t}\n\t\tevents = append(events, \u0026event)\n\t}\n\treturn events, nil\n}\n\nfunc (r *redisEventRepository) ClearUserBuffer(ctx context.Context, userID string) error {\n\tkey := r.userBufferKey(userID)\n\tif err := r.client.Del(ctx, key).Err(); err != nil {\n\t\treturn fmt.Errorf(\"failed to clear user event buffer in redis: %w\", err)\n\t}\n\treturn nil\n}\n\n// These methods are for the Postgres implementation, so they are no-ops here.\nfunc (r *redisEventRepository) StoreEvents(ctx context.Context, events []*domain.Event) error {\n\treturn nil\n}\nfunc (r *redisEventRepository) GetUndeliveredEvents(ctx context.Context, userID string) ([]*domain.Event, error) {\n\treturn nil, nil\n}\nfunc (r *redisEventRepository) MarkEventsAsDelivered(ctx context.Context, eventIDs []string) error {\n\treturn nil\n}\n",
  "backend/internal/adapter/redis/redis.go": "package redis\n\nimport (\n\t\"context\"\n\t\"github.com/redis/go-redis/v9\"\n\t\"log\"\n)\n\nfunc NewClient(redisURL string) *redis.Client {\n\topts, err := redis.ParseURL(redisURL)\n\tif err != nil {\n\t\tlog.Fatalf(\"Could not parse Redis URL: %v\", err)\n\t}\n\n\tclient := redis.NewClient(opts)\n\n\tif err := client.Ping(context.Background()).Err(); err != nil {\n\t\tlog.Fatalf(\"Could not connect to Redis: %v\", err)\n\t}\n\n\tlog.Println(\"Successfully connected to Redis\")\n\treturn client\n}\n",
  "backend/internal/delivery/http/handler/auth_handler.go": "package handler\n\nimport (\n\t\"encoding/json\"\n\t\"errors\"\n\t\"net/http\"\n\n\t\"chat-app/internal/service\"\n\t\"chat-app/internal/usecase\"\n)\n\ntype AuthHandler struct {\n\tauthUsecase usecase.AuthUsecase\n}\n\nfunc NewAuthHandler(authUsecase usecase.AuthUsecase) *AuthHandler {\n\treturn \u0026AuthHandler{authUsecase: authUsecase}\n}\n\nfunc (h *AuthHandler) SignUp(w http.ResponseWriter, r *http.Request) {\n\tvar input usecase.SignUpInput\n\tif err := json.NewDecoder(r.Body).Decode(\u0026input); err != nil {\n\t\thttp.Error(w, \"Invalid request body\", http.StatusBadRequest)\n\t\treturn\n\t}\n\n\tuser, err := h.authUsecase.SignUp(r.Context(), input)\n\tif err != nil {\n\t\thandleAuthError(w, err)\n\t\treturn\n\t}\n\n\t// Don't return password hash\n\tuser.PasswordHash = \"\"\n\n\tw.Header().Set(\"Content-Type\", \"application/json\")\n\tw.WriteHeader(http.StatusCreated)\n\tjson.NewEncoder(w).Encode(user)\n}\n\nfunc (h *AuthHandler) Login(w http.ResponseWriter, r *http.Request) {\n\tvar input usecase.LoginInput\n\tif err := json.NewDecoder(r.Body).Decode(\u0026input); err != nil {\n\t\thttp.Error(w, \"Invalid request body\", http.StatusBadRequest)\n\t\treturn\n\t}\n\n\ttokens, err := h.authUsecase.Login(r.Context(), input)\n\tif err != nil {\n\t\thandleAuthError(w, err)\n\t\treturn\n\t}\n\n\tw.Header().Set(\"Content-Type\", \"application/json\")\n\tjson.NewEncoder(w).Encode(tokens)\n}\n\nfunc (h *AuthHandler) Refresh(w http.ResponseWriter, r *http.Request) {\n\tvar body struct {\n\t\tRefreshToken string `json:\"refresh_token\"`\n\t}\n\tif err := json.NewDecoder(r.Body).Decode(\u0026body); err != nil {\n\t\thttp.Error(w, \"Invalid request body\", http.StatusBadRequest)\n\t\treturn\n\t}\n\n\ttokens, err := h.authUsecase.Refresh(r.Context(), body.RefreshToken)\n\tif err != nil {\n\t\thandleAuthError(w, err)\n\t\treturn\n\t}\n\n\tw.Header().Set(\"Content-Type\", \"application/json\")\n\tjson.NewEncoder(w).Encode(tokens)\n}\n\nfunc (h *AuthHandler) Logout(w http.ResponseWriter, r *http.Request) {\n\tvar body struct {\n\t\tRefreshToken string `json:\"refresh_token\"`\n\t}\n\tif err := json.NewDecoder(r.Body).Decode(\u0026body); err != nil {\n\t\thttp.Error(w, \"Invalid request body\", http.StatusBadRequest)\n\t\treturn\n\t}\n\n\terr := h.authUsecase.Logout(r.Context(), body.RefreshToken)\n\tif err != nil {\n\t\thandleAuthError(w, err)\n\t\treturn\n\t}\n\n\tw.WriteHeader(http.StatusNoContent)\n}\n\nfunc handleAuthError(w http.ResponseWriter, err error) {\n\tswitch {\n\tcase errors.Is(err, service.ErrUserExists),\n\t\terrors.Is(err, service.ErrInvalidUsername),\n\t\terrors.Is(err, service.ErrInvalidPassword):\n\t\thttp.Error(w, err.Error(), http.StatusBadRequest)\n\tcase errors.Is(err, service.ErrInvalidCredentials),\n\t\terrors.Is(err, service.ErrSessionNotFound),\n\t\terrors.Is(err, service.ErrSessionExpired):\n\t\thttp.Error(w, err.Error(), http.StatusUnauthorized)\n\tdefault:\n\t\thttp.Error(w, \"Internal server error\", http.StatusInternalServerError)\n\t}\n}\n",
  "backend/internal/delivery/http/handler/friend_handler.go": "package handler\n\nimport (\n\t\"encoding/json\"\n\t\"errors\"\n\t\"net/http\"\n\n\t\"chat-app/internal/delivery/http/middleware\"\n\t\"chat-app/internal/service\"\n\t\"chat-app/internal/usecase\"\n\n\t\"github.com/go-chi/chi/v5\"\n)\n\ntype FriendHandler struct {\n\tfriendUsecase usecase.FriendUsecase\n}\n\nfunc NewFriendHandler(uc usecase.FriendUsecase) *FriendHandler {\n\treturn \u0026FriendHandler{friendUsecase: uc}\n}\n\nfunc (h *FriendHandler) SendRequest(w http.ResponseWriter, r *http.Request) {\n\tuserID, ok := r.Context().Value(middleware.UserIDContextKey).(string)\n\tif !ok {\n\t\thttp.Error(w, \"Unauthorized\", http.StatusUnauthorized)\n\t\treturn\n\t}\n\n\tvar req struct {\n\t\tUsername string `json:\"username\"`\n\t}\n\tif err := json.NewDecoder(r.Body).Decode(\u0026req); err != nil {\n\t\thttp.Error(w, \"Invalid request body\", http.StatusBadRequest)\n\t\treturn\n\t}\n\n\tfriendRequest, err := h.friendUsecase.SendFriendRequest(r.Context(), userID, req.Username)\n\tif err != nil {\n\t\thandleFriendError(w, err)\n\t\treturn\n\t}\n\n\tw.Header().Set(\"Content-Type\", \"application/json\")\n\tw.WriteHeader(http.StatusCreated)\n\tjson.NewEncoder(w).Encode(friendRequest)\n}\n\nfunc (h *FriendHandler) GetPendingRequests(w http.ResponseWriter, r *http.Request) {\n\tuserID, ok := r.Context().Value(middleware.UserIDContextKey).(string)\n\tif !ok {\n\t\thttp.Error(w, \"Unauthorized\", http.StatusUnauthorized)\n\t\treturn\n\t}\n\n\trequests, err := h.friendUsecase.GetPendingRequests(r.Context(), userID)\n\tif err != nil {\n\t\thandleFriendError(w, err)\n\t\treturn\n\t}\n\n\tw.Header().Set(\"Content-Type\", \"application/json\")\n\tjson.NewEncoder(w).Encode(requests)\n}\n\nfunc (h *FriendHandler) AcceptRequest(w http.ResponseWriter, r *http.Request) {\n\tuserID, ok := r.Context().Value(middleware.UserIDContextKey).(string)\n\tif !ok {\n\t\thttp.Error(w, \"Unauthorized\", http.StatusUnauthorized)\n\t\treturn\n\t}\n\trequestID := chi.URLParam(r, \"requestID\")\n\n\tif err := h.friendUsecase.AcceptFriendRequest(r.Context(), userID, requestID); err != nil {\n\t\thandleFriendError(w, err)\n\t\treturn\n\t}\n\n\tw.WriteHeader(http.StatusNoContent)\n}\n\nfunc (h *FriendHandler) RejectRequest(w http.ResponseWriter, r *http.Request) {\n\tuserID, ok := r.Context().Value(middleware.UserIDContextKey).(string)\n\tif !ok {\n\t\thttp.Error(w, \"Unauthorized\", http.StatusUnauthorized)\n\t\treturn\n\t}\n\trequestID := chi.URLParam(r, \"requestID\")\n\n\tif err := h.friendUsecase.RejectFriendRequest(r.Context(), userID, requestID); err != nil {\n\t\thandleFriendError(w, err)\n\t\treturn\n\t}\n\n\tw.WriteHeader(http.StatusNoContent)\n}\n\nfunc (h *FriendHandler) Unfriend(w http.ResponseWriter, r *http.Request) {\n\tuserID, ok := r.Context().Value(middleware.UserIDContextKey).(string)\n\tif !ok {\n\t\thttp.Error(w, \"Unauthorized\", http.StatusUnauthorized)\n\t\treturn\n\t}\n\tfriendID := chi.URLParam(r, \"userID\")\n\n\tif err := h.friendUsecase.Unfriend(r.Context(), userID, friendID); err != nil {\n\t\thandleFriendError(w, err)\n\t\treturn\n\t}\n\n\tw.WriteHeader(http.StatusNoContent)\n}\n\nfunc (h *FriendHandler) ListFriends(w http.ResponseWriter, r *http.Request) {\n\tuserID, ok := r.Context().Value(middleware.UserIDContextKey).(string)\n\tif !ok {\n\t\thttp.Error(w, \"Unauthorized\", http.StatusUnauthorized)\n\t\treturn\n\t}\n\n\tfriends, err := h.friendUsecase.ListFriends(r.Context(), userID)\n\tif err != nil {\n\t\thandleFriendError(w, err)\n\t\treturn\n\t}\n\n\tw.Header().Set(\"Content-Type\", \"application/json\")\n\tjson.NewEncoder(w).Encode(friends)\n}\n\nfunc handleFriendError(w http.ResponseWriter, err error) {\n\tswitch {\n\tcase errors.Is(err, service.ErrFriendRequestInvalid),\n\t\terrors.Is(err, service.ErrFriendRequestYourself):\n\t\thttp.Error(w, err.Error(), http.StatusBadRequest)\n\tcase errors.Is(err, service.ErrUserNotFound):\n\t\thttp.Error(w, err.Error(), http.StatusNotFound)\n\tcase errors.Is(err, service.ErrFriendRequestExists),\n\t\terrors.Is(err, service.ErrAlreadyFriends):\n\t\thttp.Error(w, err.Error(), http.StatusConflict)\n\tcase errors.Is(err, service.ErrFriendRequestNotReceiver):\n\t\thttp.Error(w, err.Error(), http.StatusForbidden)\n\tdefault:\n\t\thttp.Error(w, \"Internal server error\", http.StatusInternalServerError)\n\t}\n}\n",
  "backend/internal/delivery/http/handler/group_handler.go": "package handler\n\nimport (\n\t\"chat-app/internal/delivery/http/middleware\"\n\t\"chat-app/internal/service\"\n\t\"chat-app/internal/usecase\"\n\t\"encoding/json\"\n\t\"errors\"\n\t\"net/http\"\n\n\t\"github.com/go-chi/chi/v5\"\n)\n\ntype GroupHandler struct {\n\tuc usecase.GroupUsecase\n}\n\nfunc NewGroupHandler(uc usecase.GroupUsecase) *GroupHandler {\n\treturn \u0026GroupHandler{uc: uc}\n}\n\nfunc (h *GroupHandler) CreateGroup(w http.ResponseWriter, r *http.Request) {\n\tuserID := r.Context().Value(middleware.UserIDContextKey).(string)\n\n\tif err := r.ParseMultipartForm(32 \u003c\u003c 20); err != nil { // 32MB max memory\n\t\thttp.Error(w, \"Failed to parse multipart form\", http.StatusBadRequest)\n\t\treturn\n\t}\n\n\tvar input usecase.CreateGroupInput\n\tinput.Handle = r.FormValue(\"handle\")\n\tinput.Name = r.FormValue(\"name\")\n\n\tfile, header, err := r.FormFile(\"photo\")\n\tif err != nil \u0026\u0026 !errors.Is(err, http.ErrMissingFile) {\n\t\thttp.Error(w, \"Failed to get photo from form\", http.StatusBadRequest)\n\t\treturn\n\t}\n\tif file != nil {\n\t\tdefer file.Close()\n\t}\n\n\tgroup, err := h.uc.CreateGroup(r.Context(), userID, input, file, header)\n\tif err != nil {\n\t\thandleGroupError(w, err)\n\t\treturn\n\t}\n\n\trespondWithJSON(w, http.StatusCreated, group)\n}\n\nfunc (h *GroupHandler) SearchGroups(w http.ResponseWriter, r *http.Request) {\n\tquery := r.URL.Query().Get(\"q\")\n\tif query == \"\" {\n\t\trespondWithJSON(w, http.StatusOK, []interface{}{})\n\t\treturn\n\t}\n\n\tgroups, err := h.uc.SearchGroups(r.Context(), query)\n\tif err != nil {\n\t\thandleGroupError(w, err)\n\t\treturn\n\t}\n\n\trespondWithJSON(w, http.StatusOK, groups)\n}\n\nfunc (h *GroupHandler) JoinGroup(w http.ResponseWriter, r *http.Request) {\n\tuserID := r.Context().Value(middleware.UserIDContextKey).(string)\n\thandle := chi.URLParam(r, \"handle\")\n\n\tgroup, err := h.uc.JoinGroup(r.Context(), userID, \"#\"+handle)\n\tif err != nil {\n\t\thandleGroupError(w, err)\n\t\treturn\n\t}\n\n\trespondWithJSON(w, http.StatusOK, group)\n}\n\nfunc (h *GroupHandler) GetGroupDetails(w http.ResponseWriter, r *http.Request) {\n\tgroupID := chi.URLParam(r, \"group_id\")\n\n\tdetails, err := h.uc.GetGroupDetails(r.Context(), groupID)\n\tif err != nil {\n\t\thandleGroupError(w, err)\n\t\treturn\n\t}\n\n\trespondWithJSON(w, http.StatusOK, details)\n}\n\nfunc (h *GroupHandler) UpdateGroup(w http.ResponseWriter, r *http.Request) {\n\tuserID := r.Context().Value(middleware.UserIDContextKey).(string)\n\tgroupID := chi.URLParam(r, \"group_id\")\n\n\tif err := r.ParseMultipartForm(32 \u003c\u003c 20); err != nil {\n\t\thttp.Error(w, \"Failed to parse multipart form\", http.StatusBadRequest)\n\t\treturn\n\t}\n\n\tvar input usecase.UpdateGroupInput\n\tif name := r.FormValue(\"name\"); name != \"\" {\n\t\tinput.Name = \u0026name\n\t}\n\n\tfile, header, err := r.FormFile(\"photo\")\n\tif err != nil \u0026\u0026 !errors.Is(err, http.ErrMissingFile) {\n\t\thttp.Error(w, \"Failed to get photo from form\", http.StatusBadRequest)\n\t\treturn\n\t}\n\tif file != nil {\n\t\tdefer file.Close()\n\t}\n\n\tgroup, err := h.uc.UpdateGroup(r.Context(), userID, groupID, input, file, header)\n\tif err != nil {\n\t\thandleGroupError(w, err)\n\t\treturn\n\t}\n\n\trespondWithJSON(w, http.StatusOK, group)\n}\n\nfunc (h *GroupHandler) TransferOwnership(w http.ResponseWriter, r *http.Request) {\n\tuserID := r.Context().Value(middleware.UserIDContextKey).(string)\n\tgroupID := chi.URLParam(r, \"group_id\")\n\n\tvar input struct {\n\t\tNewOwnerID string `json:\"new_owner_id\"`\n\t}\n\tif err := json.NewDecoder(r.Body).Decode(\u0026input); err != nil {\n\t\thttp.Error(w, \"Invalid request body\", http.StatusBadRequest)\n\t\treturn\n\t}\n\n\terr := h.uc.TransferOwnership(r.Context(), userID, groupID, input.NewOwnerID)\n\tif err != nil {\n\t\thandleGroupError(w, err)\n\t\treturn\n\t}\n\n\tw.WriteHeader(http.StatusNoContent)\n}\n\nfunc (h *GroupHandler) AddMember(w http.ResponseWriter, r *http.Request) {\n\tuserID := r.Context().Value(middleware.UserIDContextKey).(string)\n\tgroupID := chi.URLParam(r, \"group_id\")\n\n\tvar input struct {\n\t\tFriendID string `json:\"friend_id\"`\n\t}\n\tif err := json.NewDecoder(r.Body).Decode(\u0026input); err != nil {\n\t\thttp.Error(w, \"Invalid request body\", http.StatusBadRequest)\n\t\treturn\n\t}\n\n\terr := h.uc.AddMember(r.Context(), userID, groupID, input.FriendID)\n\tif err != nil {\n\t\thandleGroupError(w, err)\n\t\treturn\n\t}\n\n\tw.WriteHeader(http.StatusNoContent)\n}\n\nfunc (h *GroupHandler) RemoveMember(w http.ResponseWriter, r *http.Request) {\n\tuserID := r.Context().Value(middleware.UserIDContextKey).(string)\n\tgroupID := chi.URLParam(r, \"group_id\")\n\tmemberID := chi.URLParam(r, \"member_id\")\n\n\terr := h.uc.RemoveMember(r.Context(), userID, groupID, memberID)\n\tif err != nil {\n\t\thandleGroupError(w, err)\n\t\treturn\n\t}\n\n\tw.WriteHeader(http.StatusNoContent)\n}\n\nfunc (h *GroupHandler) LeaveGroup(w http.ResponseWriter, r *http.Request) {\n\tuserID := r.Context().Value(middleware.UserIDContextKey).(string)\n\tgroupID := chi.URLParam(r, \"group_id\")\n\n\terr := h.uc.LeaveGroup(r.Context(), userID, groupID)\n\tif err != nil {\n\t\thandleGroupError(w, err)\n\t\treturn\n\t}\n\n\tw.WriteHeader(http.StatusNoContent)\n}\n\nfunc (h *GroupHandler) ListMyGroups(w http.ResponseWriter, r *http.Request) {\n\tuserID := r.Context().Value(middleware.UserIDContextKey).(string)\n\n\tgroups, err := h.uc.ListUserGroups(r.Context(), userID)\n\tif err != nil {\n\t\thandleGroupError(w, err)\n\t\treturn\n\t}\n\n\trespondWithJSON(w, http.StatusOK, groups)\n}\n\nfunc handleGroupError(w http.ResponseWriter, err error) {\n\tswitch {\n\tcase errors.Is(err, service.ErrInvalidGroupHandle), errors.Is(err, service.ErrAddNotFriend), errors.Is(err, service.ErrTransferToNonMember), errors.Is(err, service.ErrTransferToSelf), errors.Is(err, service.ErrRemoveSelf):\n\t\thttp.Error(w, err.Error(), http.StatusBadRequest)\n\tcase errors.Is(err, service.ErrNotGroupOwner), errors.Is(err, service.ErrNotGroupMember):\n\t\thttp.Error(w, err.Error(), http.StatusForbidden)\n\tcase errors.Is(err, repository.ErrNotFound):\n\t\thttp.Error(w, \"Group not found\", http.StatusNotFound)\n\tcase errors.Is(err, repository.ErrGroupHandleExists), errors.Is(err, repository.ErrGroupMemberExists):\n\t\thttp.Error(w, err.Error(), http.StatusConflict)\n\tdefault:\n\t\thttp.Error(w, \"An internal error occurred\", http.StatusInternalServerError)\n\t}\n}\n",
  "backend/internal/delivery/http/handler/user_handler.go": "package handler\n\nimport (\n\t\"chat-app/internal/delivery/http/middleware\"\n\t\"chat-app/internal/service\"\n\t\"chat-app/internal/usecase\"\n\t\"encoding/json\"\n\t\"net/http\"\n\n\t\"github.com/go-chi/chi/v5\"\n)\n\ntype UserHandler struct {\n\tuserUsecase usecase.UserUsecase\n}\n\nfunc NewUserHandler(uc usecase.UserUsecase) *UserHandler {\n\treturn \u0026UserHandler{userUsecase: uc}\n}\n\nfunc (h *UserHandler) GetMyProfile(w http.ResponseWriter, r *http.Request) {\n\tuserID, ok := r.Context().Value(middleware.UserIDContextKey).(string)\n\tif !ok {\n\t\thttp.Error(w, \"Unauthorized\", http.StatusUnauthorized)\n\t\treturn\n\t}\n\n\tuser, err := h.userUsecase.GetProfile(r.Context(), userID)\n\tif err != nil {\n\t\thttp.Error(w, \"Internal server error\", http.StatusInternalServerError)\n\t\treturn\n\t}\n\tif user == nil {\n\t\thttp.Error(w, \"User not found\", http.StatusNotFound)\n\t\treturn\n\t}\n\n\tw.Header().Set(\"Content-Type\", \"application/json\")\n\tjson.NewEncoder(w).Encode(user)\n}\n\nfunc (h *UserHandler) GetUserProfile(w http.ResponseWriter, r *http.Request) {\n\tusername := chi.URLParam(r, \"username\")\n\tuser, err := h.userUsecase.GetUserByUsername(r.Context(), username)\n\tif err != nil {\n\t\thttp.Error(w, \"Internal server error\", http.StatusInternalServerError)\n\t\treturn\n\t}\n\tif user == nil {\n\t\thttp.Error(w, \"User not found\", http.StatusNotFound)\n\t\treturn\n\t}\n\n\tw.Header().Set(\"Content-Type\", \"application/json\")\n\tjson.NewEncoder(w).Encode(user)\n}\n\nfunc (h *UserHandler) UpdateMyProfile(w http.ResponseWriter, r *http.Request) {\n\tuserID, ok := r.Context().Value(middleware.UserIDContextKey).(string)\n\tif !ok {\n\t\thttp.Error(w, \"Unauthorized\", http.StatusUnauthorized)\n\t\treturn\n\t}\n\n\tif err := r.ParseMultipartForm(10 \u003c\u003c 20); err != nil { // 10 MB max memory\n\t\thttp.Error(w, \"Invalid request body: \"+err.Error(), http.StatusBadRequest)\n\t\treturn\n\t}\n\n\tvar updateInput usecase.UpdateUserInput\n\tusername := r.FormValue(\"username\")\n\tpassword := r.FormValue(\"password\")\n\n\tif username != \"\" {\n\t\tupdateInput.Username = \u0026username\n\t}\n\tif password != \"\" {\n\t\tupdateInput.Password = \u0026password\n\t}\n\n\tif updateInput.Username != nil || updateInput.Password != nil {\n\t\tif _, err := h.userUsecase.UpdateProfile(r.Context(), userID, updateInput); err != nil {\n\t\t\tswitch err {\n\t\t\tcase service.ErrUserExists, service.ErrInvalidUsername, service.ErrInvalidPassword:\n\t\t\t\thttp.Error(w, err.Error(), http.StatusBadRequest)\n\t\t\tdefault:\n\t\t\t\thttp.Error(w, \"Failed to update profile\", http.StatusInternalServerError)\n\t\t\t}\n\t\t\treturn\n\t\t}\n\t}\n\n\tfile, header, err := r.FormFile(\"profile_pic\")\n\tif err == nil {\n\t\tdefer file.Close()\n\t\tif _, err := h.userUsecase.UpdateProfilePicture(r.Context(), userID, file, header); err != nil {\n\t\t\tswitch err {\n\t\t\tcase service.ErrFileSizeExceeded, service.ErrInvalidFileType:\n\t\t\t\thttp.Error(w, err.Error(), http.StatusBadRequest)\n\t\t\tdefault:\n\t\t\t\thttp.Error(w, \"Failed to update profile picture\", http.StatusInternalServerError)\n\t\t\t}\n\t\t\treturn\n\t\t}\n\t} else if err != http.ErrMissingFile {\n\t\thttp.Error(w, \"Could not process file: \"+err.Error(), http.StatusBadRequest)\n\t\treturn\n\t}\n\n\tupdatedUser, err := h.userUsecase.GetProfile(r.Context(), userID)\n\tif err != nil {\n\t\thttp.Error(w, \"Internal server error\", http.StatusInternalServerError)\n\t\treturn\n\t}\n\n\tw.Header().Set(\"Content-Type\", \"application/json\")\n\tw.WriteHeader(http.StatusOK)\n\tjson.NewEncoder(w).Encode(updatedUser)\n}\n",
  "backend/internal/delivery/http/handler/websocket_handler.go": "package handler\n\nimport (\n\t\"chat-app/internal/delivery/http/middleware\"\n\tws \"chat-app/internal/delivery/websocket\"\n\t\"log\"\n\t\"net/http\"\n\n\t\"github.com/gorilla/websocket\"\n)\n\nvar upgrader = websocket.Upgrader{\n\tReadBufferSize:  1024,\n\tWriteBufferSize: 1024,\n\tCheckOrigin: func(r *http.Request) bool {\n\t\t// Allow all connections for development\n\t\treturn true\n\t},\n}\n\ntype WebSocketHandler struct {\n\thub *ws.Hub\n}\n\nfunc NewWebSocketHandler(hub *ws.Hub) *WebSocketHandler {\n\treturn \u0026WebSocketHandler{hub: hub}\n}\n\nfunc (h *WebSocketHandler) ServeWS(w http.ResponseWriter, r *http.Request) {\n\tuserID, ok := r.Context().Value(middleware.UserIDContextKey).(string)\n\tif !ok {\n\t\thttp.Error(w, \"Unauthorized\", http.StatusUnauthorized)\n\t\treturn\n\t}\n\n\tconn, err := upgrader.Upgrade(w, r, nil)\n\tif err != nil {\n\t\tlog.Println(err)\n\t\treturn\n\t}\n\n\tclient := \u0026ws.Client{\n\t\thub:    h.hub,\n\t\tconn:   conn,\n\t\tsend:   make(chan []byte, 256),\n\t\tuserID: userID,\n\t}\n\tclient.hub.register \u003c- client\n\n\t// Allow collection of memory referenced by the caller by doing all work in\n\t// new goroutines.\n\tgo client.writePump()\n\tgo client.readPump()\n}\n",
  "backend/internal/delivery/http/middleware/auth_middleware.go": "package middleware\n\nimport (\n\t\"context\"\n\t\"net/http\"\n\t\"strings\"\n\n\t\"chat-app/pkg/config\"\n\t\"chat-app/pkg/util\"\n)\n\ntype contextKey string\n\nconst UserIDContextKey = contextKey(\"userID\")\n\nfunc AuthMiddleware(cfg *config.Config) func(next http.Handler) http.Handler {\n\treturn func(next http.Handler) http.Handler {\n\t\treturn http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\t\tauthHeader := r.Header.Get(\"Authorization\")\n\t\t\tif authHeader == \"\" {\n\t\t\t\thttp.Error(w, \"Authorization header required\", http.StatusUnauthorized)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tparts := strings.Split(authHeader, \" \")\n\t\t\tif len(parts) != 2 || parts[0] != \"Bearer\" {\n\t\t\t\thttp.Error(w, \"Invalid authorization header format\", http.StatusUnauthorized)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\ttokenString := parts[1]\n\t\t\tclaims, err := util.ValidateToken(tokenString, cfg.JWTSecret)\n\t\t\tif err != nil {\n\t\t\t\thttp.Error(w, \"Invalid token\", http.StatusUnauthorized)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tctx := context.WithValue(r.Context(), UserIDContextKey, claims.UserID)\n\t\t\tnext.ServeHTTP(w, r.WithContext(ctx))\n\t\t})\n\t}\n}\n",
  "backend/internal/delivery/http/router.go": "package http\n\nimport (\n\t\"net/http\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"strings\"\n\n\t\"chat-app/internal/delivery/http/handler\"\n\t\"chat-app/internal/delivery/http/middleware\"\n\t\"chat-app/internal/delivery/websocket\"\n\t\"chat-app/internal/usecase\"\n\t\"chat-app/pkg/config\"\n\n\t\"github.com/go-chi/chi/v5\"\n\tchimiddleware \"github.com/go-chi/chi/v5/middleware\"\n)\n\nfunc NewRouter(\n\tcfg *config.Config,\n\tauthUsecase usecase.AuthUsecase,\n\tuserUsecase usecase.UserUsecase,\n\tfriendUsecase usecase.FriendUsecase,\n\tgroupUsecase usecase.GroupUsecase,\n\thub *websocket.Hub,\n) http.Handler {\n\tr := chi.NewRouter()\n\n\tr.Use(chimiddleware.Logger)\n\tr.Use(chimiddleware.Recoverer)\n\tr.Use(chimiddleware.Heartbeat(\"/healthz\"))\n\n\tauthHandler := handler.NewAuthHandler(authUsecase)\n\tuserHandler := handler.NewUserHandler(userUsecase)\n\twsHandler := handler.NewWebSocketHandler(hub)\n\tfriendHandler := handler.NewFriendHandler(friendUsecase)\n\tgroupHandler := handler.NewGroupHandler(groupUsecase)\n\n\t// Public API routes\n\tr.Route(\"/api/v1\", func(r chi.Router) {\n\t\tr.Post(\"/auth/signup\", authHandler.SignUp)\n\t\tr.Post(\"/auth/login\", authHandler.Login)\n\t\tr.Post(\"/auth/refresh\", authHandler.Refresh)\n\t})\n\n\t// Protected API routes\n\tr.Route(\"/api/v1\", func(r chi.Router) {\n\t\tr.Use(middleware.AuthMiddleware(cfg))\n\n\t\tr.Get(\"/ws\", wsHandler.ServeWS)\n\t\tr.Post(\"/auth/logout\", authHandler.Logout)\n\n\t\t// User routes\n\t\tr.Get(\"/users/me\", userHandler.GetMyProfile)\n\t\tr.Put(\"/users/me\", userHandler.UpdateMyProfile)\n\t\tr.Get(\"/users/{username}\", userHandler.GetUserProfile)\n\n\t\t// Friend routes\n\t\tr.Post(\"/friends/requests\", friendHandler.SendRequest)\n\t\tr.Get(\"/friends/requests/pending\", friendHandler.GetPendingRequests)\n\t\tr.Put(\"/friends/requests/{request_id}/accept\", friendHandler.AcceptRequest)\n\t\tr.Put(\"/friends/requests/{request_id}/reject\", friendHandler.RejectRequest)\n\t\tr.Delete(\"/friends/{user_id}\", friendHandler.Unfriend)\n\t\tr.Get(\"/friends\", friendHandler.ListFriends)\n\n\t\t// Group routes\n\t\tr.Post(\"/groups\", groupHandler.CreateGroup)\n\t\tr.Get(\"/groups/search\", groupHandler.SearchGroups)\n\t\tr.Post(\"/groups/{handle}/join\", groupHandler.JoinGroup)\n\t\tr.Get(\"/groups/{group_id}\", groupHandler.GetGroupDetails)\n\t\tr.Put(\"/groups/{group_id}\", groupHandler.UpdateGroup)\n\t\tr.Put(\"/groups/{group_id}/transfer-ownership\", groupHandler.TransferOwnership)\n\t\tr.Post(\"/groups/{group_id}/members\", groupHandler.AddMember)\n\t\tr.Delete(\"/groups/{group_id}/members/{member_id}\", groupHandler.RemoveMember)\n\t\tr.Post(\"/groups/{group_id}/leave\", groupHandler.LeaveGroup)\n\t\tr.Get(\"/groups/me\", groupHandler.ListMyGroups)\n\t})\n\n\t// Serve frontend files\n\tworkDir, _ := os.Getwd()\n\tfilesDir := http.Dir(filepath.Join(workDir, \"web\"))\n\tFileServer(r, \"/\", filesDir)\n\n\treturn r\n}\n\nfunc FileServer(r chi.Router, path string, root http.FileSystem) {\n\tif strings.ContainsAny(path, \"{}*\") {\n\t\tpanic(\"FileServer does not permit URL parameters.\")\n\t}\n\n\tfs := http.StripPrefix(path, http.FileServer(root))\n\n\tif path != \"/\" \u0026\u0026 path[len(path)-1] != '/' {\n\t\tr.Get(path, http.RedirectHandler(path+\"/\", http.StatusMovedPermanently).ServeHTTP)\n\t\tpath += \"/\"\n\t}\n\tpath += \"*\"\n\n\tr.Get(path, func(w http.ResponseWriter, r *http.Request) {\n\t\t// Check if the file exists\n\t\tf, err := root.Open(r.URL.Path)\n\t\tif os.IsNotExist(err) {\n\t\t\t// If not, serve the main chat.html for SPA routing\n\t\t\thttp.ServeFile(w, r, filepath.Join(\"web\", \"templates\", \"chat.html\"))\n\t\t\treturn\n\t\t}\n\t\tif err != nil {\n\t\t\thttp.Error(w, http.StatusText(http.StatusInternalServerError), http.StatusInternalServerError)\n\t\t\treturn\n\t\t}\n\t\tf.Close()\n\n\t\t// Otherwise, serve the file\n\t\tfs.ServeHTTP(w, r)\n\t})\n}\n",
  "backend/internal/delivery/websocket/client.go": "package websocket\n\nimport (\n\t\"bytes\"\n\t\"encoding/json\"\n\t\"log\"\n\t\"time\"\n\n\t\"github.com/gorilla/websocket\"\n)\n\nconst (\n\twriteWait      = 10 * time.Second\n\tpongWait       = 60 * time.Second\n\tpingPeriod     = (pongWait * 9) / 10\n\tmaxMessageSize = 512\n)\n\nvar (\n\tnewline = []byte{'\\n'}\n\tspace   = []byte{' '}\n)\n\n// Client is a middleman between the websocket connection and the hub.\ntype Client struct {\n\thub *Hub\n\n\t// The websocket connection.\n\tconn *websocket.Conn\n\n\t// Buffered channel of outbound messages.\n\tsend chan []byte\n\n\t// Authenticated user ID.\n\tuserID string\n}\n\n// readPump pumps messages from the websocket connection to the hub.\nfunc (c *Client) readPump() {\n\tdefer func() {\n\t\tc.hub.unregister \u003c- c\n\t\tc.conn.Close()\n\t}()\n\tc.conn.SetReadLimit(maxMessageSize)\n\tc.conn.SetReadDeadline(time.Now().Add(pongWait))\n\tc.conn.SetPongHandler(func(string) error { c.conn.SetReadDeadline(time.Now().Add(pongWait)); return nil })\n\tfor {\n\t\t_, message, err := c.conn.ReadMessage()\n\t\tif err != nil {\n\t\t\tif websocket.IsUnexpectedCloseError(err, websocket.CloseGoingAway, websocket.CloseAbnormalClosure) {\n\t\t\t\tlog.Printf(\"error: %v\", err)\n\t\t\t}\n\t\t\tbreak\n\t\t}\n\t\tmessage = bytes.TrimSpace(bytes.Replace(message, newline, space, -1))\n\t\t// For now, we just log incoming messages. In a full app, this would be parsed and handled.\n\t\tlog.Printf(\"Received message from %s: %s\", c.userID, message)\n\t}\n}\n\n// writePump pumps messages from the hub to the websocket connection.\nfunc (c *Client) writePump() {\n\tticker := time.NewTicker(pingPeriod)\n\tdefer func() {\n\t\tticker.Stop()\n\t\tc.conn.Close()\n\t}()\n\tfor {\n\t\tselect {\n\t\tcase message, ok := \u003c-c.send:\n\t\t\tc.conn.SetWriteDeadline(time.Now().Add(writeWait))\n\t\t\tif !ok {\n\t\t\t\t// The hub closed the channel.\n\t\t\t\tc.conn.WriteMessage(websocket.CloseMessage, []byte{})\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tw, err := c.conn.NextWriter(websocket.TextMessage)\n\t\t\tif err != nil {\n\t\t\t\treturn\n\t\t\t}\n\t\t\tw.Write(message)\n\n\t\t\t// Add queued chat messages to the current websocket message.\n\t\t\tn := len(c.send)\n\t\t\tfor i := 0; i \u003c n; i++ {\n\t\t\t\tw.Write(newline)\n\t\t\t\tw.Write(\u003c-c.send)\n\t\t\t}\n\n\t\t\tif err := w.Close(); err != nil {\n\t\t\t\treturn\n\t\t\t}\n\t\tcase \u003c-ticker.C:\n\t\t\tc.conn.SetWriteDeadline(time.Now().Add(writeWait))\n\t\t\tif err := c.conn.WriteMessage(websocket.PingMessage, nil); err != nil {\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t}\n}\n\n// SendEvent sends a domain event to the client.\nfunc (c *Client) SendEvent(event interface{}) {\n\teventBytes, err := json.Marshal(event)\n\tif err != nil {\n\t\tlog.Printf(\"Error marshalling event for client %s: %v\", c.userID, err)\n\t\treturn\n\t}\n\tc.send \u003c- eventBytes\n}\n",
  "backend/internal/delivery/websocket/hub.go": "package websocket\n\nimport (\n\t\"chat-app/internal/usecase\"\n\t\"context\"\n\t\"log\"\n)\n\n// Hub maintains the set of active clients and broadcasts messages to the\n// clients.\ntype Hub struct {\n\t// Registered clients.\n\tclients map[string]*Client\n\n\t// Inbound messages from the clients.\n\tbroadcast chan []byte\n\n\t// Register requests from the clients.\n\tregister chan *Client\n\n\t// Unregister requests from clients.\n\tunregister chan *Client\n\n\teventUsecase usecase.EventUsecase\n}\n\nfunc NewHub(eventUsecase usecase.EventUsecase) *Hub {\n\treturn \u0026Hub{\n\t\tbroadcast:  make(chan []byte),\n\t\tregister:   make(chan *Client),\n\t\tunregister: make(chan *Client),\n\t\tclients:    make(map[string]*Client),\n\t\teventUsecase: eventUsecase,\n\t}\n}\n\nfunc (h *Hub) Run() {\n\tfor {\n\t\tselect {\n\t\tcase client := \u003c-h.register:\n\t\t\th.clients[client.userID] = client\n\t\t\tlog.Printf(\"Client connected: %s. Total clients: %d\", client.userID, len(h.clients))\n\t\t\t// TODO: Fetch and send undelivered events\n\t\tcase client := \u003c-h.unregister:\n\t\t\tif _, ok := h.clients[client.userID]; ok {\n\t\t\t\tdelete(h.clients, client.userID)\n\t\t\t\tclose(client.send)\n\t\t\t\tlog.Printf(\"Client disconnected: %s. Total clients: %d\", client.userID, len(h.clients))\n\t\t\t}\n\t\tcase message := \u003c-h.broadcast:\n\t\t\t// This is a simple broadcast. A real app would target specific users.\n\t\t\tfor _, client := range h.clients {\n\t\t\t\tselect {\n\t\t\t\tcase client.send \u003c- message:\n\t\t\t\tdefault:\n\t\t\t\t\tclose(client.send)\n\t\t\t\t\tdelete(h.clients, client.userID)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n// BroadcastEvent sends an event to a specific user if they are online,\n// otherwise it buffers the event.\nfunc (h *Hub) BroadcastEvent(ctx context.Context, eventType string, payload interface{}, recipientID string) {\n\tif client, ok := h.clients[recipientID]; ok {\n\t\t// User is online, send directly\n\t\tclient.SendEvent(map[string]interface{}{\"type\": eventType, \"payload\": payload})\n\t} else {\n\t\t// User is offline, buffer the event\n\t\terr := h.eventUsecase.CreateAndBufferEvent(ctx, eventType, payload, recipientID)\n\t\tif err != nil {\n\t\t\tlog.Printf(\"Error buffering event for offline user %s: %v\", recipientID, err)\n\t\t}\n\t}\n}\n",
  "backend/internal/domain/event.go": "package domain\n\nimport (\n\t\"encoding/json\"\n\t\"time\"\n)\n\ntype Event struct {\n\tID          string          `json:\"id\"`\n\tType        string          `json:\"type\"`\n\tPayload     json.RawMessage `json:\"payload\"`\n\tRecipientID string          `json:\"recipient_id\"`\n\tIsDelivered bool            `json:\"is_delivered\"`\n\tCreatedAt   time.Time       `json:\"created_at\"`\n}\n",
  "backend/internal/domain/friend_request.go": "package domain\n\nimport \"time\"\n\ntype FriendRequest struct {\n\tID         string    `json:\"id\"`\n\tSenderID   string    `json:\"sender_id\"`\n\tReceiverID string    `json:\"receiver_id\"`\n\tStatus     string    `json:\"status\"` // e.g., \"pending\", \"accepted\", \"rejected\"\n\tCreatedAt  time.Time `json:\"created_at\"`\n\tUpdatedAt  time.Time `json:\"updated_at\"`\n\n\t// Fields for joining with users table\n\tSender   *User `json:\"sender,omitempty\"`\n\tReceiver *User `json:\"receiver,omitempty\"`\n}\n\nconst (\n\tFriendRequestStatusPending  = \"pending\"\n\tFriendRequestStatusAccepted = \"accepted\"\n\tFriendRequestStatusRejected = \"rejected\"\n)\n",
  "backend/internal/domain/group.go": "package domain\n\nimport \"time\"\n\nconst (\n\tGroupRoleOwner  = \"owner\"\n\tGroupRoleMember = \"member\"\n)\n\ntype Group struct {\n\tID            string    `json:\"id\"`\n\tHandle        string    `json:\"handle\"`\n\tName          string    `json:\"name\"`\n\tOwnerID       string    `json:\"owner_id\"`\n\tProfilePicURL string    `json:\"profile_pic_url\"`\n\tCreatedAt     time.Time `json:\"created_at\"`\n\tUpdatedAt     time.Time `json:\"updated_at\"`\n}\n\ntype GroupMember struct {\n\tGroupID   string    `json:\"group_id\"`\n\tUserID    string    `json:\"user_id\"`\n\tRole      string    `json:\"role\"`\n\tCreatedAt time.Time `json:\"created_at\"`\n\tUser      *User     `json:\"user,omitempty\"` // For joining\n}\n",
  "backend/internal/domain/session.go": "package domain\n\nimport \"time\"\n\ntype Session struct {\n\tID        string    `json:\"id\"` // This is the Refresh Token\n\tUserID    string    `json:\"user_id\"`\n\tExpiresAt time.Time `json:\"expires_at\"`\n\tCreatedAt time.Time `json:\"created_at\"`\n}\n",
  "backend/internal/domain/user.go": "package domain\n\nimport \"time\"\n\ntype User struct {\n\tID            string    `json:\"id\"`\n\tUsername      string    `json:\"username\"`\n\tPasswordHash  string    `json:\"-\"` // Do not expose password hash\n\tProfilePicURL string    `json:\"profile_pic_url\"`\n\tCreatedAt     time.Time `json:\"created_at\"`\n\tUpdatedAt     time.Time `json:\"updated_at\"`\n}\n",
  "backend/internal/repository/event_repo.go": "package repository\n\nimport (\n\t\"context\"\n\t\"chat-app/internal/domain\"\n)\n\ntype EventRepository interface {\n\t// Redis operations\n\tBufferEvent(ctx context.Context, event *domain.Event) error\n\tGetBufferedEventsForUser(ctx context.Context, userID string) ([]*domain.Event, error)\n\tClearUserBuffer(ctx context.Context, userID string) error\n\n\t// Postgres operations\n\tStoreEvents(ctx context.Context, events []*domain.Event) error\n\tGetUndeliveredEvents(ctx context.Context, userID string) ([]*domain.Event, error)\n\tMarkEventsAsDelivered(ctx context.Context, eventIDs []string) error\n}\n",
  "backend/internal/repository/file_repo.go": "package repository\n\nimport (\n\t\"context\"\n)\n\ntype FileRepository interface {\n\tSaveProfilePicture(ctx context.Context, fileData []byte, fileType string) (filename string, err error)\n}\n",
  "backend/internal/repository/friend_repo.go": "package repository\n\nimport (\n\t\"context\"\n\t\"errors\"\n\n\t\"chat-app/internal/domain\"\n)\n\nvar (\n\tErrFriendRequestExists = errors.New(\"friend request already exists\")\n\tErrNotFound            = errors.New(\"resource not found\")\n)\n\ntype FriendRepository interface {\n\tCreateRequest(ctx context.Context, req *domain.FriendRequest) error\n\tGetRequestByID(ctx context.Context, id string) (*domain.FriendRequest, error)\n\tUpdateRequestStatus(ctx context.Context, id, status string) error\n\tAreFriends(ctx context.Context, userID1, userID2 string) (bool, error)\n\tAddFriendship(ctx context.Context, userID1, userID2 string) error\n\tRemoveFriendship(ctx context.Context, userID1, userID2 string) error\n\tGetPendingRequests(ctx context.Context, userID string) ([]*domain.FriendRequest, error)\n\tGetFriendsByUserID(ctx context.Context, userID string) ([]*domain.User, error)\n\tHasPendingRequest(ctx context.Context, userID1, userID2 string) (bool, error)\n}\n",
  "backend/internal/repository/group_repo.go": "package repository\n\nimport (\n\t\"chat-app/internal/domain\"\n\t\"context\"\n)\n\nvar (\n\tErrGroupHandleExists = NewRepositoryError(\"group handle already exists\")\n\tErrGroupMemberExists = NewRepositoryError(\"user is already a member of this group\")\n)\n\ntype GroupRepository interface {\n\tCreate(ctx context.Context, group *domain.Group) error\n\tCreateMember(ctx context.Context, member *domain.GroupMember) error\n\tGetByID(ctx context.Context, id string) (*domain.Group, error)\n\tGetByHandle(ctx context.Context, handle string) (*domain.Group, error)\n\tUpdate(ctx context.Context, group *domain.Group) error\n\tFindMember(ctx context.Context, groupID, userID string) (*domain.GroupMember, error)\n\tRemoveMember(ctx context.Context, groupID, userID string) error\n\tGetMembersWithUserDetails(ctx context.Context, groupID string) ([]*domain.GroupMember, error)\n\tGetGroupsByUserID(ctx context.Context, userID string) ([]*domain.Group, error)\n\tSearchByHandle(ctx context.Context, query string) ([]*domain.Group, error)\n\tGetOldestMember(ctx context.Context, groupID, excludeUserID string) (*domain.GroupMember, error)\n}\n",
  "backend/internal/repository/session_repo.go": "package repository\n\nimport (\n\t\"context\"\n\t\"chat-app/internal/domain\"\n)\n\ntype SessionRepository interface {\n\tStore(ctx context.Context, session *domain.Session) error\n\tGetByID(ctx context.Context, id string) (*domain.Session, error)\n\tDelete(ctx context.Context, id string) error\n\tDeleteAllForUser(ctx context.Context, userID string) error\n}\n",
  "backend/internal/repository/user_repo.go": "package repository\n\nimport (\n\t\"chat-app/internal/domain\"\n\t\"context\"\n)\n\ntype UserRepository interface {\n\tCreate(ctx context.Context, user *domain.User) error\n\tGetByUsername(ctx context.Context, username string) (*domain.User, error)\n\tGetByID(ctx context.Context, id string) (*domain.User, error)\n\tUpdate(ctx context.Context, user *domain.User) error\n}\n",
  "backend/internal/service/auth_service.go": "package service\n\nimport (\n\t\"context\"\n\t\"errors\"\n\t\"regexp\"\n\t\"strings\"\n\t\"time\"\n\n\t\"chat-app/internal/domain\"\n\t\"chat-app/internal/repository\"\n\t\"chat-app/internal/usecase\"\n\t\"chat-app/pkg/config\"\n\t\"chat-app/pkg/util\"\n)\n\nvar (\n\tErrUserExists         = errors.New(\"user with this username already exists\")\n\tErrUserNotFound       = errors.New(\"user not found\")\n\tErrInvalidCredentials = errors.New(\"invalid username or password\")\n\tErrInvalidUsername    = errors.New(\"username format is invalid\")\n\tErrInvalidPassword    = errors.New(\"password is too short\")\n\tErrSessionNotFound    = errors.New(\"session not found or expired\")\n\tErrSessionExpired     = errors.New(\"session has expired\")\n)\n\ntype authService struct {\n\tuserRepo    repository.UserRepository\n\tsessionRepo repository.SessionRepository\n\tcfg         *config.Config\n}\n\nfunc NewAuthService(userRepo repository.UserRepository, sessionRepo repository.SessionRepository, cfg *config.Config) usecase.AuthUsecase {\n\treturn \u0026authService{\n\t\tuserRepo:    userRepo,\n\t\tsessionRepo: sessionRepo,\n\t\tcfg:         cfg,\n\t}\n}\n\nfunc (s *authService) SignUp(ctx context.Context, input usecase.SignUpInput) (*domain.User, error) {\n\t// Validate username\n\tif err := validateUsername(input.Username); err != nil {\n\t\treturn nil, err\n\t}\n\t// Validate password\n\tif len(input.Password) \u003c 8 {\n\t\treturn nil, ErrInvalidPassword\n\t}\n\n\t// Check if user exists\n\texistingUser, err := s.userRepo.GetByUsername(ctx, input.Username)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif existingUser != nil {\n\t\treturn nil, ErrUserExists\n\t}\n\n\t// Hash password\n\thashedPassword, err := util.HashPassword(input.Password)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Create user\n\tuser := \u0026domain.User{\n\t\tID:           util.NewUUID(),\n\t\tUsername:     strings.ToLower(input.Username),\n\t\tPasswordHash: hashedPassword,\n\t}\n\n\tif err := s.userRepo.Create(ctx, user); err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn user, nil\n}\n\nfunc (s *authService) Login(ctx context.Context, input usecase.LoginInput) (*usecase.AuthTokens, error) {\n\tuser, err := s.userRepo.GetByUsername(ctx, input.Username)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif user == nil {\n\t\treturn nil, ErrInvalidCredentials\n\t}\n\n\tif !util.CheckPasswordHash(input.Password, user.PasswordHash) {\n\t\treturn nil, ErrInvalidCredentials\n\t}\n\n\t// Single device policy: remove all old sessions\n\tif err := s.sessionRepo.DeleteAllForUser(ctx, user.ID); err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn s.createSession(ctx, user.ID)\n}\n\nfunc (s *authService) Refresh(ctx context.Context, refreshToken string) (*usecase.AuthTokens, error) {\n\tsession, err := s.sessionRepo.GetByID(ctx, refreshToken)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif session == nil {\n\t\treturn nil, ErrSessionNotFound\n\t}\n\n\tif session.ExpiresAt.Before(time.Now()) {\n\t\t// Clean up expired session\n\t\t_ = s.sessionRepo.Delete(ctx, session.ID)\n\t\treturn nil, ErrSessionExpired\n\t}\n\n\t// Sliding window: delete old session and create a new one\n\tif err := s.sessionRepo.Delete(ctx, session.ID); err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn s.createSession(ctx, session.UserID)\n}\n\nfunc (s *authService) Logout(ctx context.Context, refreshToken string) error {\n\treturn s.sessionRepo.Delete(ctx, refreshToken)\n}\n\nfunc (s *authService) createSession(ctx context.Context, userID string) (*usecase.AuthTokens, error) {\n\taccessToken, err := util.GenerateAccessToken(userID, s.cfg.JWTSecret, s.cfg.AccessTokenTTL)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tsession := \u0026domain.Session{\n\t\tID:        util.NewUUID(), // This is the refresh token\n\t\tUserID:    userID,\n\t\tExpiresAt: time.Now().Add(s.cfg.RefreshTokenTTL),\n\t}\n\n\tif err := s.sessionRepo.Store(ctx, session); err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn \u0026usecase.AuthTokens{\n\t\tAccessToken:  accessToken,\n\t\tRefreshToken: session.ID,\n\t}, nil\n}\n\nfunc validateUsername(username string) error {\n\tif len(username) \u003c 4 || len(username) \u003e 50 {\n\t\treturn ErrInvalidUsername\n\t}\n\t// Allowed characters: lowercase letters (a-z), digits (0-9), and underscore (_)\n\tmatch, _ := regexp.MatchString(\"^[a-z0-9_]+$\", username)\n\tif !match {\n\t\treturn ErrInvalidUsername\n\t}\n\treturn nil\n}\n",
  "backend/internal/service/event_service.go": "package service\n\nimport (\n\t\"chat-app/internal/domain\"\n\t\"chat-app/internal/repository\"\n\t\"chat-app/internal/usecase\"\n\t\"chat-app/pkg/util\"\n\t\"context\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"log\"\n\t\"time\"\n)\n\ntype eventService struct {\n\tredisEventRepo repository.EventRepository\n\tpgEventRepo    repository.EventRepository\n\tuserRepo       repository.UserRepository\n}\n\nfunc NewEventService(redisEventRepo, pgEventRepo repository.EventRepository, userRepo repository.UserRepository) usecase.EventUsecase {\n\treturn \u0026eventService{\n\t\tredisEventRepo: redisEventRepo,\n\t\tpgEventRepo:    pgEventRepo,\n\t\tuserRepo:       userRepo,\n\t}\n}\n\nfunc (s *eventService) CreateAndBufferEvent(ctx context.Context, eventType string, payload interface{}, recipientID string) error {\n\tpayloadJSON, err := json.Marshal(payload)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to marshal event payload: %w\", err)\n\t}\n\n\tevent := \u0026domain.Event{\n\t\tID:          util.NewUUID(),\n\t\tType:        eventType,\n\t\tPayload:     payloadJSON,\n\t\tRecipientID: recipientID,\n\t\tCreatedAt:   time.Now(),\n\t}\n\n\treturn s.redisEventRepo.BufferEvent(ctx, event)\n}\n\n// PersistBufferedEvents is intended to be run as a background job.\n// It's a simplified implementation. A real-world scenario would need more robust handling\n// of user lists, locking, and error recovery.\nfunc (s *eventService) PersistBufferedEvents(ctx context.Context) {\n\t// In a real app, you'd get a list of active users with buffered events.\n\t// For this project, we'll assume we can iterate through all users, which is not scalable.\n\t// This is a placeholder for a more complex logic.\n\tlog.Println(\"Background worker: Persisting buffered events from Redis to Postgres is not fully implemented for scalability. This is a conceptual placeholder.\")\n\t// A proper implementation would:\n\t// 1. Get a list of all user IDs that have buffered events (e.g., from a Redis SET).\n\t// 2. For each user:\n\t//    a. Get all buffered events.\n\t//    b. Store them in Postgres.\n\t//    c. Clear the Redis buffer for that user.\n\t// This needs careful implementation to avoid race conditions and data loss.\n}\n",
  "backend/internal/service/friend_service.go": "package service\n\nimport (\n\t\"context\"\n\t\"errors\"\n\t\"fmt\"\n\t\"time\"\n\n\t\"chat-app/internal/domain\"\n\t\"chat-app/internal/repository\"\n\t\"chat-app/internal/usecase\"\n\t\"chat-app/pkg/util\"\n)\n\nvar (\n\tErrFriendRequestYourself    = errors.New(\"cannot send friend request to yourself\")\n\tErrAlreadyFriends           = errors.New(\"users are already friends\")\n\tErrFriendRequestExists      = errors.New(\"a pending friend request already exists\")\n\tErrFriendRequestInvalid     = errors.New(\"invalid friend request\")\n\tErrFriendRequestNotReceiver = errors.New(\"only the receiver can accept or reject a friend request\")\n)\n\ntype friendService struct {\n\tfriendRepo repository.FriendRepository\n\tuserRepo   repository.UserRepository\n\teventUcase usecase.EventUsecase\n}\n\nfunc NewFriendService(friendRepo repository.FriendRepository, userRepo repository.UserRepository, eventUsecase usecase.EventUsecase) usecase.FriendUsecase {\n\treturn \u0026friendService{\n\t\tfriendRepo: friendRepo,\n\t\tuserRepo:   userRepo,\n\t\teventUcase: eventUsecase,\n\t}\n}\n\nfunc (s *friendService) SendFriendRequest(ctx context.Context, senderID, receiverUsername string) (*domain.FriendRequest, error) {\n\tsender, err := s.userRepo.GetByID(ctx, senderID)\n\tif err != nil || sender == nil {\n\t\treturn nil, fmt.Errorf(\"sender not found: %w\", err)\n\t}\n\n\treceiver, err := s.userRepo.GetByUsername(ctx, receiverUsername)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"error fetching receiver: %w\", err)\n\t}\n\tif receiver == nil {\n\t\treturn nil, ErrUserNotFound\n\t}\n\n\tif senderID == receiver.ID {\n\t\treturn nil, ErrFriendRequestYourself\n\t}\n\n\tareFriends, err := s.friendRepo.AreFriends(ctx, senderID, receiver.ID)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif areFriends {\n\t\treturn nil, ErrAlreadyFriends\n\t}\n\n\thasPending, err := s.friendRepo.HasPendingRequest(ctx, senderID, receiver.ID)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif hasPending {\n\t\treturn nil, ErrFriendRequestExists\n\t}\n\n\treq := \u0026domain.FriendRequest{\n\t\tID:         util.NewUUID(),\n\t\tSenderID:   senderID,\n\t\tReceiverID: receiver.ID,\n\t\tStatus:     domain.FriendRequestStatusPending,\n\t\tCreatedAt:  time.Now().UTC(),\n\t\tUpdatedAt:  time.Now().UTC(),\n\t}\n\n\tif err := s.friendRepo.CreateRequest(ctx, req); err != nil {\n\t\tif errors.Is(err, repository.ErrFriendRequestExists) {\n\t\t\treturn nil, ErrFriendRequestExists\n\t\t}\n\t\treturn nil, err\n\t}\n\n\t// Create event for receiver\n\teventPayload := map[string]interface{}{\n\t\t\"request_id\": req.ID,\n\t\t\"sender\": map[string]string{\n\t\t\t\"id\":              sender.ID,\n\t\t\t\"username\":        sender.Username,\n\t\t\t\"profile_pic_url\": sender.ProfilePicURL,\n\t\t},\n\t}\n\ts.eventUcase.CreateAndBufferEvent(ctx, \"friend_request_received\", eventPayload, receiver.ID)\n\n\treq.Sender = sender\n\treq.Receiver = receiver\n\treturn req, nil\n}\n\nfunc (s *friendService) AcceptFriendRequest(ctx context.Context, userID, requestID string) error {\n\treq, err := s.friendRepo.GetRequestByID(ctx, requestID)\n\tif err != nil {\n\t\tif errors.Is(err, repository.ErrNotFound) {\n\t\t\treturn ErrFriendRequestInvalid\n\t\t}\n\t\treturn err\n\t}\n\n\tif req.ReceiverID != userID {\n\t\treturn ErrFriendRequestNotReceiver\n\t}\n\n\tif req.Status != domain.FriendRequestStatusPending {\n\t\treturn ErrFriendRequestInvalid\n\t}\n\n\tif err := s.friendRepo.AddFriendship(ctx, req.SenderID, req.ReceiverID); err != nil {\n\t\treturn err\n\t}\n\n\tif err := s.friendRepo.UpdateRequestStatus(ctx, requestID, domain.FriendRequestStatusAccepted); err != nil {\n\t\t// Attempt to rollback friendship, but don't fail the whole operation if this fails\n\t\t_ = s.friendRepo.RemoveFriendship(ctx, req.SenderID, req.ReceiverID)\n\t\treturn err\n\t}\n\n\t// Create event for sender\n\treceiver, err := s.userRepo.GetByID(ctx, userID)\n\tif err != nil {\n\t\t// Log error but continue\n\t\tfmt.Printf(\"Error fetching receiver user for event: %v\\n\", err)\n\t} else {\n\t\teventPayload := map[string]interface{}{\n\t\t\t\"request_id\": requestID,\n\t\t\t\"receiver\": map[string]string{\n\t\t\t\t\"id\":              receiver.ID,\n\t\t\t\t\"username\":        receiver.Username,\n\t\t\t\t\"profile_pic_url\": receiver.ProfilePicURL,\n\t\t\t},\n\t\t}\n\t\ts.eventUcase.CreateAndBufferEvent(ctx, \"friend_request_accepted\", eventPayload, req.SenderID)\n\t}\n\n\treturn nil\n}\n\nfunc (s *friendService) RejectFriendRequest(ctx context.Context, userID, requestID string) error {\n\treq, err := s.friendRepo.GetRequestByID(ctx, requestID)\n\tif err != nil {\n\t\tif errors.Is(err, repository.ErrNotFound) {\n\t\t\treturn ErrFriendRequestInvalid\n\t\t}\n\t\treturn err\n\t}\n\n\tif req.ReceiverID != userID \u0026\u0026 req.SenderID != userID {\n\t\treturn ErrFriendRequestNotReceiver // Or a more generic \"not authorized\"\n\t}\n\n\tif req.Status != domain.FriendRequestStatusPending {\n\t\treturn ErrFriendRequestInvalid\n\t}\n\n\tif err := s.friendRepo.UpdateRequestStatus(ctx, requestID, domain.FriendRequestStatusRejected); err != nil {\n\t\treturn err\n\t}\n\n\t// Create event for the other user\n\tvar otherUserID string\n\tif userID == req.SenderID {\n\t\totherUserID = req.ReceiverID\n\t} else {\n\t\totherUserID = req.SenderID\n\t}\n\n\trejecter, err := s.userRepo.GetByID(ctx, userID)\n\tif err != nil {\n\t\tfmt.Printf(\"Error fetching rejecting user for event: %v\\n\", err)\n\t} else {\n\t\teventPayload := map[string]interface{}{\n\t\t\t\"request_id\": requestID,\n\t\t\t\"user\": map[string]string{\n\t\t\t\t\"id\":       rejecter.ID,\n\t\t\t\t\"username\": rejecter.Username,\n\t\t\t},\n\t\t}\n\t\ts.eventUcase.CreateAndBufferEvent(ctx, \"friend_request_rejected\", eventPayload, otherUserID)\n\t}\n\n\treturn nil\n}\n\nfunc (s *friendService) Unfriend(ctx context.Context, userID, friendID string) error {\n\tareFriends, err := s.friendRepo.AreFriends(ctx, userID, friendID)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif !areFriends {\n\t\treturn nil // Idempotent\n\t}\n\n\tif err := s.friendRepo.RemoveFriendship(ctx, userID, friendID); err != nil {\n\t\treturn err\n\t}\n\n\t// Create event for the unfriended user\n\tunfriender, err := s.userRepo.GetByID(ctx, userID)\n\tif err != nil {\n\t\tfmt.Printf(\"Error fetching unfriender user for event: %v\\n\", err)\n\t} else {\n\t\teventPayload := map[string]interface{}{\n\t\t\t\"user\": map[string]string{\n\t\t\t\t\"id\":       unfriender.ID,\n\t\t\t\t\"username\": unfriender.Username,\n\t\t\t},\n\t\t}\n\t\ts.eventUcase.CreateAndBufferEvent(ctx, \"unfriended\", eventPayload, friendID)\n\t}\n\n\treturn nil\n}\n\nfunc (s *friendService) GetPendingRequests(ctx context.Context, userID string) ([]*domain.FriendRequest, error) {\n\treturn s.friendRepo.GetPendingRequests(ctx, userID)\n}\n\nfunc (s *friendService) ListFriends(ctx context.Context, userID string) ([]*domain.User, error) {\n\treturn s.friendRepo.GetFriendsByUserID(ctx, userID)\n}\n",
  "backend/internal/service/group_service.go": "package service\n\nimport (\n\t\"chat-app/internal/domain\"\n\t\"chat-app/internal/repository\"\n\t\"chat-app/internal/usecase\"\n\t\"chat-app/pkg/util\"\n\t\"context\"\n\t\"errors\"\n\t\"fmt\"\n\t\"mime/multipart\"\n\t\"regexp\"\n\t\"strings\"\n)\n\nvar (\n\tErrInvalidGroupHandle   = errors.New(\"invalid group handle format\")\n\tErrNotGroupOwner        = errors.New(\"only the group owner can perform this action\")\n\tErrNotGroupMember       = errors.New(\"user is not a member of this group\")\n\tErrCannotRemoveOwner    = errors.New(\"group owner cannot be removed\")\n\tErrCannotLeaveAsOwner   = errors.New(\"owner must transfer ownership before leaving\")\n\tErrAddNotFriend         = errors.New(\"you can only add your friends to a group\")\n\tErrTransferToNonMember  = errors.New(\"can only transfer ownership to a group member\")\n\tErrTransferToSelf       = errors.New(\"cannot transfer ownership to yourself\")\n\tErrRemoveSelf           = errors.New(\"cannot remove yourself from a group, use leave group instead\")\n\tErrLastMemberCannotLeave = errors.New(\"last member cannot leave the group, it will be deleted\")\n)\n\nvar groupHandleRegex = regexp.MustCompile(`^[a-z0-9_]{4,50}$`)\n\ntype groupService struct {\n\tgroupRepo  repository.GroupRepository\n\tuserRepo   repository.UserRepository\n\tfriendRepo repository.FriendRepository\n\tfileRepo   repository.FileRepository\n\teventUsecase usecase.EventUsecase\n}\n\nfunc NewGroupService(\n\tgroupRepo repository.GroupRepository,\n\tuserRepo repository.UserRepository,\n\tfriendRepo repository.FriendRepository,\n\tfileRepo repository.FileRepository,\n\teventUsecase usecase.EventUsecase,\n) usecase.GroupUsecase {\n\treturn \u0026groupService{\n\t\tgroupRepo:  groupRepo,\n\t\tuserRepo:   userRepo,\n\t\tfriendRepo: friendRepo,\n\t\tfileRepo:   fileRepo,\n\t\teventUsecase: eventUsecase,\n\t}\n}\n\nfunc (s *groupService) validateGroupHandle(handle string) error {\n\tif !strings.HasPrefix(handle, \"#\") {\n\t\treturn ErrInvalidGroupHandle\n\t}\n\tcleanHandle := strings.TrimPrefix(handle, \"#\")\n\tif !groupHandleRegex.MatchString(cleanHandle) {\n\t\treturn ErrInvalidGroupHandle\n\t}\n\treturn nil\n}\n\nfunc (s *groupService) CreateGroup(ctx context.Context, userID string, input usecase.CreateGroupInput, file multipart.File, fileHeader *multipart.FileHeader) (*domain.Group, error) {\n\tif err := s.validateGroupHandle(input.Handle); err != nil {\n\t\treturn nil, err\n\t}\n\n\tvar picURL string\n\tif file != nil {\n\t\t// Re-use user profile picture logic for group pictures\n\t\turl, err := NewUserService(s.userRepo, s.fileRepo).UpdateProfilePicture(ctx, \"\", file, fileHeader)\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"failed to save group picture: %w\", err)\n\t\t}\n\t\tpicURL = url\n\t}\n\n\tgroup := \u0026domain.Group{\n\t\tID:            util.NewUUID(),\n\t\tHandle:        input.Handle,\n\t\tName:          input.Name,\n\t\tOwnerID:       userID,\n\t\tProfilePicURL: picURL,\n\t}\n\n\tif err := s.groupRepo.Create(ctx, group); err != nil {\n\t\treturn nil, err\n\t}\n\n\townerMember := \u0026domain.GroupMember{\n\t\tGroupID: group.ID,\n\t\tUserID:  userID,\n\t\tRole:    domain.GroupRoleOwner,\n\t}\n\tif err := s.groupRepo.CreateMember(ctx, ownerMember); err != nil {\n\t\t// TODO: Add transaction to rollback group creation\n\t\treturn nil, err\n\t}\n\n\treturn group, nil\n}\n\nfunc (s *groupService) GetGroupDetails(ctx context.Context, groupID string) (*usecase.GroupDetails, error) {\n\tgroup, err := s.groupRepo.GetByID(ctx, groupID)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tmembers, err := s.groupRepo.GetMembersWithUserDetails(ctx, groupID)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn \u0026usecase.GroupDetails{\n\t\tGroup:   group,\n\t\tMembers: members,\n\t}, nil\n}\n\nfunc (s *groupService) UpdateGroup(ctx context.Context, userID, groupID string, input usecase.UpdateGroupInput, file multipart.File, fileHeader *multipart.FileHeader) (*domain.Group, error) {\n\tgroup, err := s.groupRepo.GetByID(ctx, groupID)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tif group.OwnerID != userID {\n\t\treturn nil, ErrNotGroupOwner\n\t}\n\n\tif input.Name != nil {\n\t\tgroup.Name = *input.Name\n\t}\n\n\tif file != nil {\n\t\turl, err := NewUserService(s.userRepo, s.fileRepo).UpdateProfilePicture(ctx, \"\", file, fileHeader)\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"failed to update group picture: %w\", err)\n\t\t}\n\t\tgroup.ProfilePicURL = url\n\t}\n\n\tif err := s.groupRepo.Update(ctx, group); err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn group, nil\n}\n\nfunc (s *groupService) SearchGroups(ctx context.Context, query string) ([]*domain.Group, error) {\n\treturn s.groupRepo.SearchByHandle(ctx, query)\n}\n\nfunc (s *groupService) JoinGroup(ctx context.Context, userID, groupHandle string) (*domain.Group, error) {\n\tgroup, err := s.groupRepo.GetByHandle(ctx, groupHandle)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tmember := \u0026domain.GroupMember{\n\t\tGroupID: group.ID,\n\t\tUserID:  userID,\n\t\tRole:    domain.GroupRoleMember,\n\t}\n\n\tif err := s.groupRepo.CreateMember(ctx, member); err != nil {\n\t\tif errors.Is(err, repository.ErrGroupMemberExists) {\n\t\t\treturn group, nil // Idempotent: already a member, return success\n\t\t}\n\t\treturn nil, err\n\t}\n\n\treturn group, nil\n}\n\nfunc (s *groupService) LeaveGroup(ctx context.Context, userID, groupID string) error {\n\tgroup, err := s.groupRepo.GetByID(ctx, groupID)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif group.OwnerID == userID {\n\t\t// Check for other members\n\t\toldestMember, err := s.groupRepo.GetOldestMember(ctx, groupID, userID)\n\t\tif err != nil {\n\t\t\tif errors.Is(err, repository.ErrNotFound) {\n\t\t\t\t// This is the last member, they can't leave.\n\t\t\t\t// In a real app, this might trigger group deletion.\n\t\t\t\treturn ErrLastMemberCannotLeave\n\t\t\t}\n\t\t\treturn err\n\t\t}\n\t\t// Auto-transfer ownership\n\t\tif err := s.TransferOwnership(ctx, userID, groupID, oldestMember.UserID); err != nil {\n\t\t\treturn fmt.Errorf(\"failed to auto-transfer ownership: %w\", err)\n\t\t}\n\t}\n\n\treturn s.groupRepo.RemoveMember(ctx, groupID, userID)\n}\n\nfunc (s *groupService) AddMember(ctx context.Context, currentUserID, groupID, friendID string) error {\n\t// 1. Check if current user is a member of the group\n\t_, err := s.groupRepo.FindMember(ctx, groupID, currentUserID)\n\tif err != nil {\n\t\tif errors.Is(err, repository.ErrNotFound) {\n\t\t\treturn ErrNotGroupMember\n\t\t}\n\t\treturn err\n\t}\n\n\t// 2. Check if the user to be added is a friend of the current user\n\tareFriends, err := s.friendRepo.AreFriends(ctx, currentUserID, friendID)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif !areFriends {\n\t\treturn ErrAddNotFriend\n\t}\n\n\t// 3. Add the friend to the group\n\tnewMember := \u0026domain.GroupMember{\n\t\tGroupID: groupID,\n\t\tUserID:  friendID,\n\t\tRole:    domain.GroupRoleMember,\n\t}\n\tif err := s.groupRepo.CreateMember(ctx, newMember); err != nil {\n\t\tif errors.Is(err, repository.ErrGroupMemberExists) {\n\t\t\treturn nil // Idempotent\n\t\t}\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\nfunc (s *groupService) RemoveMember(ctx context.Context, ownerID, groupID, memberID string) error {\n\tif ownerID == memberID {\n\t\treturn ErrRemoveSelf\n\t}\n\n\tgroup, err := s.groupRepo.GetByID(ctx, groupID)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif group.OwnerID != ownerID {\n\t\treturn ErrNotGroupOwner\n\t}\n\n\tif group.OwnerID == memberID {\n\t\treturn ErrCannotRemoveOwner\n\t}\n\n\treturn s.groupRepo.RemoveMember(ctx, groupID, memberID)\n}\n\nfunc (s *groupService) TransferOwnership(ctx context.Context, currentOwnerID, groupID, newOwnerID string) error {\n\tif currentOwnerID == newOwnerID {\n\t\treturn ErrTransferToSelf\n\t}\n\n\tgroup, err := s.groupRepo.GetByID(ctx, groupID)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif group.OwnerID != currentOwnerID {\n\t\treturn ErrNotGroupOwner\n\t}\n\n\t// Check if new owner is a member\n\t_, err = s.groupRepo.FindMember(ctx, groupID, newOwnerID)\n\tif err != nil {\n\t\tif errors.Is(err, repository.ErrNotFound) {\n\t\t\treturn ErrTransferToNonMember\n\t\t}\n\t\treturn err\n\t}\n\n\t// Perform transfer in a transaction (conceptual)\n\t// 1. Update group owner_id\n\tgroup.OwnerID = newOwnerID\n\tif err := s.groupRepo.Update(ctx, group); err != nil {\n\t\treturn err\n\t}\n\n\t// 2. Update roles in group_members table\n\t// This would require a new repo method, e.g., UpdateMemberRole\n\t// For simplicity, we'll assume this is handled or not strictly required by the current schema\n\t// A more robust implementation would have a transaction and update both tables.\n\n\treturn nil\n}\n\nfunc (s *groupService) ListUserGroups(ctx context.Context, userID string) ([]*domain.Group, error) {\n\treturn s.groupRepo.GetGroupsByUserID(ctx, userID)\n}\n",
  "backend/internal/service/user_service.go": "package service\n\nimport (\n\t\"chat-app/internal/domain\"\n\t\"chat-app/internal/repository\"\n\t\"chat-app/internal/usecase\"\n\t\"chat-app/pkg/util\"\n\t\"context\"\n\t\"errors\"\n\t\"io\"\n\t\"mime/multipart\"\n\t\"regexp\"\n)\n\nvar (\n\tErrProfileUpdateFailed = errors.New(\"profile update failed\")\n\tErrInvalidFileType     = errors.New(\"invalid file type for profile picture, allowed: png, jpg, jpeg, webp\")\n\tErrFileSizeExceeded    = errors.New(\"file size exceeds the 200KB limit\")\n)\n\ntype userService struct {\n\tuserRepo repository.UserRepository\n\tfileRepo repository.FileRepository\n}\n\nfunc NewUserService(userRepo repository.UserRepository, fileRepo repository.FileRepository) usecase.UserUsecase {\n\treturn \u0026userService{\n\t\tuserRepo: userRepo,\n\t\tfileRepo: fileRepo,\n\t}\n}\n\nfunc (s *userService) GetProfile(ctx context.Context, userID string) (*domain.User, error) {\n\treturn s.userRepo.GetByID(ctx, userID)\n}\n\nfunc (s *userService) GetUserByUsername(ctx context.Context, username string) (*domain.User, error) {\n\treturn s.userRepo.GetByUsername(ctx, username)\n}\n\nfunc (s *userService) UpdateProfile(ctx context.Context, userID string, input usecase.UpdateUserInput) (*domain.User, error) {\n\tuser, err := s.userRepo.GetByID(ctx, userID)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif user == nil {\n\t\treturn nil, ErrUserNotFound\n\t}\n\n\tif input.Username != nil {\n\t\tif err := validateUsername(*input.Username); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\texistingUser, err := s.userRepo.GetByUsername(ctx, *input.Username)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tif existingUser != nil \u0026\u0026 existingUser.ID != userID {\n\t\t\treturn nil, ErrUserExists\n\t\t}\n\t\tuser.Username = *input.Username\n\t}\n\n\tif input.Password != nil {\n\t\tif len(*input.Password) \u003c 8 {\n\t\t\treturn nil, ErrInvalidPassword\n\t\t}\n\t\thashedPassword, err := util.HashPassword(*input.Password)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tuser.PasswordHash = hashedPassword\n\t}\n\n\tif err := s.userRepo.Update(ctx, user); err != nil {\n\t\treturn nil, ErrProfileUpdateFailed\n\t}\n\n\treturn user, nil\n}\n\nfunc (s *userService) UpdateProfilePicture(ctx context.Context, userID string, file multipart.File, fileHeader *multipart.FileHeader) (string, error) {\n\tif fileHeader.Size \u003e 200*1024 { // 200 KB\n\t\treturn \"\", ErrFileSizeExceeded\n\t}\n\n\tcontentType := fileHeader.Header.Get(\"Content-Type\")\n\tallowedTypes := []string{\"image/png\", \"image/jpeg\", \"image/jpg\", \"image/webp\"}\n\tisValidType := false\n\tfor _, t := range allowedTypes {\n\t\tif contentType == t {\n\t\t\tisValidType = true\n\t\t\tbreak\n\t\t}\n\t}\n\tif !isValidType {\n\t\treturn \"\", ErrInvalidFileType\n\t}\n\n\tfileBytes, err := io.ReadAll(file)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\tfilename, err := s.fileRepo.SaveProfilePicture(ctx, fileBytes, contentType)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\tuser, err := s.userRepo.GetByID(ctx, userID)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\tif user == nil {\n\t\treturn \"\", ErrUserNotFound\n\t}\n\n\tuser.ProfilePicURL = \"/uploads/\" + filename\n\tif err := s.userRepo.Update(ctx, user); err != nil {\n\t\treturn \"\", ErrProfileUpdateFailed\n\t}\n\n\treturn user.ProfilePicURL, nil\n}\n\nfunc validateUsername(username string) error {\n\tif len(username) \u003c 4 || len(username) \u003e 50 {\n\t\treturn ErrInvalidUsername\n\t}\n\tmatch, _ := regexp.MatchString(\"^[a-z0-9_]+$\")\n\tif !match {\n\t\treturn ErrInvalidUsername\n\t}\n\treturn nil\n}\n",
  "backend/internal/usecase/auth_ucase.go": "package usecase\n\nimport (\n\t\"context\"\n\t\"chat-app/internal/domain\"\n)\n\ntype SignUpInput struct {\n\tUsername string `json:\"username\"`\n\tPassword string `json:\"password\"`\n}\n\ntype LoginInput struct {\n\tUsername string `json:\"username\"`\n\tPassword string `json:\"password\"`\n}\n\ntype AuthTokens struct {\n\tAccessToken  string `json:\"access_token\"`\n\tRefreshToken string `json:\"refresh_token\"`\n}\n\ntype AuthUsecase interface {\n\tSignUp(ctx context.Context, input SignUpInput) (*domain.User, error)\n\tLogin(ctx context.Context, input LoginInput) (*AuthTokens, error)\n\tRefresh(ctx context.Context, refreshToken string) (*AuthTokens, error)\n\tLogout(ctx context.Context, refreshToken string) error\n}\n",
  "backend/internal/usecase/event_ucase.go": "package usecase\n\nimport (\n\t\"chat-app/internal/domain\"\n\t\"context\"\n)\n\ntype EventUsecase interface {\n\tCreateAndBufferEvent(ctx context.Context, eventType string, payload interface{}, recipientID string) error\n\tPersistBufferedEvents(ctx context.Context)\n}\n",
  "backend/internal/usecase/friend_ucase.go": "package usecase\n\nimport (\n\t\"context\"\n\n\t\"chat-app/internal/domain\"\n)\n\ntype FriendUsecase interface {\n\tSendFriendRequest(ctx context.Context, senderID, receiverUsername string) (*domain.FriendRequest, error)\n\tAcceptFriendRequest(ctx context.Context, userID, requestID string) error\n\tRejectFriendRequest(ctx context.Context, userID, requestID string) error\n\tUnfriend(ctx context.Context, userID, friendID string) error\n\tGetPendingRequests(ctx context.Context, userID string) ([]*domain.FriendRequest, error)\n\tListFriends(ctx context.Context, userID string) ([]*domain.User, error)\n}\n",
  "backend/internal/usecase/group_ucase.go": "package usecase\n\nimport (\n\t\"chat-app/internal/domain\"\n\t\"context\"\n\t\"mime/multipart\"\n)\n\ntype CreateGroupInput struct {\n\tHandle string `json:\"handle\"`\n\tName   string `json:\"name\"`\n}\n\ntype UpdateGroupInput struct {\n\tName *string `json:\"name\"`\n}\n\ntype AddGroupMemberInput struct {\n\tUserID string `json:\"user_id\"`\n}\n\ntype TransferOwnershipInput struct {\n\tNewOwnerID string `json:\"new_owner_id\"`\n}\n\ntype GroupDetails struct {\n\t*domain.Group\n\tMembers []*domain.GroupMember `json:\"members\"`\n}\n\ntype GroupUsecase interface {\n\tCreateGroup(ctx context.Context, userID string, input CreateGroupInput, file multipart.File, fileHeader *multipart.FileHeader) (*domain.Group, error)\n\tGetGroupDetails(ctx context.Context, groupID string) (*GroupDetails, error)\n\tUpdateGroup(ctx context.Context, userID, groupID string, input UpdateGroupInput, file multipart.File, fileHeader *multipart.FileHeader) (*domain.Group, error)\n\tSearchGroups(ctx context.Context, query string) ([]*domain.Group, error)\n\tJoinGroup(ctx context.Context, userID, groupHandle string) (*domain.Group, error)\n\tLeaveGroup(ctx context.Context, userID, groupID string) error\n\tAddMember(ctx context.Context, currentUserID, groupID, friendID string) error\n\tRemoveMember(ctx context.Context, ownerID, groupID, memberID string) error\n\tTransferOwnership(ctx context.Context, currentOwnerID, groupID, newOwnerID string) error\n\tListUserGroups(ctx context.Context, userID string) ([]*domain.Group, error)\n}\n",
  "backend/internal/usecase/user_ucase.go": "package usecase\n\nimport (\n\t\"chat-app/internal/domain\"\n\t\"context\"\n\t\"mime/multipart\"\n)\n\ntype UpdateUserInput struct {\n\tUsername *string\n\tPassword *string\n}\n\ntype UserUsecase interface {\n\tGetProfile(ctx context.Context, userID string) (*domain.User, error)\n\tGetUserByUsername(ctx context.Context, username string) (*domain.User, error)\n\tUpdateProfile(ctx context.Context, userID string, input UpdateUserInput) (*domain.User, error)\n\tUpdateProfilePicture(ctx context.Context, userID string, file multipart.File, fileHeader *multipart.FileHeader) (string, error)\n}\n",
  "backend/migrations/000001_create_users_table.up.sql": "CREATE EXTENSION IF NOT EXISTS \"uuid-ossp\";\nCREATE EXTENSION IF NOT EXISTS \"citext\";\n\nCREATE TABLE IF NOT EXISTS users (\n    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),\n    username CITEXT NOT NULL UNIQUE,\n    password_hash VARCHAR(255) NOT NULL,\n    profile_pic_url VARCHAR(255) DEFAULT '',\n    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),\n    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()\n);\n\nCREATE INDEX IF NOT EXISTS users_username_idx ON users(username);\n",
  "backend/migrations/000002_create_sessions_table.up.sql": "CREATE TABLE IF NOT EXISTS sessions (\n    id UUID PRIMARY KEY,\n    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,\n    expires_at TIMESTAMPTZ NOT NULL,\n    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()\n);\n\nCREATE INDEX IF NOT EXISTS sessions_user_id_idx ON sessions(user_id);\n",
  "backend/migrations/000003_create_events_table.up.sql": "CREATE TABLE IF NOT EXISTS events (\n    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),\n    type VARCHAR(50) NOT NULL,\n    payload JSONB NOT NULL,\n    recipient_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,\n    is_delivered BOOLEAN NOT NULL DEFAULT FALSE,\n    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()\n);\n\nCREATE INDEX IF NOT EXISTS events_recipient_id_is_delivered_idx ON events (recipient_id, is_delivered);\n",
  "backend/migrations/000004_create_friends_tables.up.sql": "CREATE TABLE IF NOT EXISTS friend_requests (\n    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),\n    sender_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,\n    receiver_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,\n    status VARCHAR(20) NOT NULL CHECK (status IN ('pending', 'accepted', 'rejected')),\n    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),\n    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),\n    UNIQUE(sender_id, receiver_id)\n);\n\nCREATE TABLE IF NOT EXISTS friendships (\n    user_id1 UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,\n    user_id2 UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,\n    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),\n    PRIMARY KEY (user_id1, user_id2),\n    CHECK (user_id1 \u003c user_id2)\n);\n\nCREATE INDEX ON friend_requests (sender_id);\nCREATE INDEX ON friend_requests (receiver_id);\nCREATE INDEX ON friendships (user_id1);\nCREATE INDEX ON friendships (user_id2);\n",
  "backend/migrations/000005_create_groups_tables.up.sql": "CREATE TABLE groups (\n    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),\n    handle VARCHAR(100) UNIQUE NOT NULL,\n    name VARCHAR(100) NOT NULL,\n    owner_id UUID NOT NULL REFERENCES users(id) ON DELETE RESTRICT,\n    profile_pic_url VARCHAR(255) DEFAULT '',\n    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),\n    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()\n);\n\nCREATE INDEX groups_handle_idx ON groups(handle);\n\nCREATE TABLE group_members (\n    group_id UUID NOT NULL REFERENCES groups(id) ON DELETE CASCADE,\n    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,\n    role VARCHAR(20) NOT NULL CHECK (role IN ('owner', 'member')),\n    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),\n    PRIMARY KEY (group_id, user_id)\n);\n\nCREATE INDEX group_members_user_id_idx ON group_members(user_id);\nCREATE INDEX group_members_created_at_idx ON group_members(created_at);\n",
  "backend/pkg/config/config.go": "package config\n\nimport (\n\t\"log\"\n\t\"os\"\n\t\"time\"\n\n\t\"github.com/joho/godotenv\"\n)\n\ntype Config struct {\n\tPort            string\n\tDatabaseURL     string\n\tRedisURL        string\n\tJWTSecret       string\n\tAccessTokenTTL  time.Duration\n\tRefreshTokenTTL time.Duration\n\tUploadDir       string\n}\n\nfunc Load() *Config {\n\tif err := godotenv.Load(); err != nil {\n\t\tlog.Println(\"No .env file found, using environment variables\")\n\t}\n\n\treturn \u0026Config{\n\t\tPort:            getEnv(\"PORT\", \"8080\"),\n\t\tDatabaseURL:     getEnv(\"DATABASE_URL\", \"postgres://user:password@localhost:5432/chatdb?sslmode=disable\"),\n\t\tRedisURL:        getEnv(\"REDIS_URL\", \"redis://localhost:6379/0\"),\n\t\tJWTSecret:       getEnv(\"JWT_SECRET\", \"a-very-secret-key\"),\n\t\tAccessTokenTTL:  10 * time.Minute,\n\t\tRefreshTokenTTL: 8 * time.Hour,\n\t\tUploadDir:       getEnv(\"UPLOAD_DIR\", \"uploads\"),\n\t}\n}\n\nfunc getEnv(key, fallback string) string {\n\tif value, ok := os.LookupEnv(key); ok {\n\t\treturn value\n\t}\n\treturn fallback\n}",
  "backend/pkg/util/hash.go": "package util\n\nimport \"golang.org/x/crypto/bcrypt\"\n\nfunc HashPassword(password string) (string, error) {\n\tbytes, err := bcrypt.GenerateFromPassword([]byte(password), bcrypt.DefaultCost)\n\treturn string(bytes), err\n}\n\nfunc CheckPasswordHash(password, hash string) bool {\n\terr := bcrypt.CompareHashAndPassword([]byte(hash), []byte(password))\n\treturn err == nil\n}\n",
  "backend/pkg/util/jwt.go": "package util\n\nimport (\n\t\"fmt\"\n\t\"time\"\n\n\t\"github.com/golang-jwt/jwt/v5\"\n)\n\ntype Claims struct {\n\tUserID string `json:\"user_id\"`\n\tjwt.RegisteredClaims\n}\n\nfunc GenerateAccessToken(userID, secret string, ttl time.Duration) (string, error) {\n\tclaims := \u0026Claims{\n\t\tUserID: userID,\n\t\tRegisteredClaims: jwt.RegisteredClaims{\n\t\t\tExpiresAt: jwt.NewNumericDate(time.Now().Add(ttl)),\n\t\t\tIssuedAt:  jwt.NewNumericDate(time.Now()),\n\t\t},\n\t}\n\n\ttoken := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)\n\treturn token.SignedString([]byte(secret))\n}\n\nfunc ValidateToken(tokenString, secret string) (*Claims, error) {\n\ttoken, err := jwt.ParseWithClaims(tokenString, \u0026Claims{}, func(token *jwt.Token) (interface{}, error) {\n\t\tif _, ok := token.Method.(*jwt.SigningMethodHMAC); !ok {\n\t\t\treturn nil, fmt.Errorf(\"unexpected signing method: %v\", token.Header[\"alg\"])\n\t\t}\n\t\treturn []byte(secret), nil\n\t})\n\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tif claims, ok := token.Claims.(*Claims); ok \u0026\u0026 token.Valid {\n\t\treturn claims, nil\n\t}\n\n\treturn nil, fmt.Errorf(\"invalid token\")\n}\n",
  "backend/pkg/util/uuid.go": "package util\n\nimport \"github.com/google/uuid\"\n\nfunc NewUUID() string {\n\treturn uuid.New().String()\n}\n\nfunc ParseUUID(s string) (uuid.UUID, error) {\n\treturn uuid.Parse(s)\n}\n```",
  "backend/web/static/css/style.css": "/* Placeholder for compiled Tailwind CSS */\n",
  "backend/web/static/js/api.js": "/**\n * @typedef {object} User\n * @property {string} id\n * @property {string} username\n * @property {string} profile_pic_url\n * @property {string} created_at\n * @property {string} updated_at\n */\n\n/**\n * @typedef {object} AuthTokens\n * @property {string} access_token\n * @property {string} refresh_token\n */\n\n/**\n * @typedef {object} Group\n * @property {string} id\n * @property {string} handle\n * @property {string} name\n * @property {string} photo_url\n * @property {string} owner_id\n * @property {string} created_at\n * @property {string} updated_at\n */\n\nimport { getAccessToken, clearTokens } from './store.js';\n\nconst API_BASE = '/api/v1';\n\n/**\n * Generic request handler\n * @param {string} endpoint\n * @param {RequestInit} options\n * @returns {Promise\u003cany\u003e}\n */\nasync function request(endpoint, options = {}) {\n    const url = `${API_BASE}${endpoint}`;\n    const headers = {\n        ...options.headers,\n    };\n\n    const token = getAccessToken();\n    if (token) { // Only add Authorization header if token exists\n        headers['Authorization'] = `Bearer ${token}`;\n    }\n\n    if (!(options.body instanceof FormData)) {\n        headers['Content-Type'] = 'application/json';\n    }\n\n    const config = {\n        ...options,\n        headers,\n    };\n\n    try {\n        const response = await fetch(url, config);\n\n        if (response.status === 401) {\n            clearTokens();\n            window.location.href = '/';\n            throw new Error('Unauthorized');\n        }\n\n        if (!response.ok) {\n            const errorText = await response.text();\n            let errorMessage = errorText || `HTTP error! status: ${response.status}`;\n            try {\n                const errorData = JSON.parse(errorText);\n                errorMessage = errorData.message || errorMessage;\n            } catch (e) {\n                // Not a JSON error, use plain text\n            }\n            throw new Error(errorMessage);\n        }\n\n        if (response.status === 204) {\n            return null; // Return null for no content\n        }\n\n        return response.json();\n    } catch (error) {\n        console.error('API request failed:', error);\n        throw error;\n    }\n}\n\n// --- Auth ---\n/** @returns {Promise\u003cUser\u003e} */\nexport const signup = (username, password) =\u003e request('/auth/signup', {\n    method: 'POST',\n    body: JSON.stringify({ username, password }),\n});\n\n/** @returns {Promise\u003cAuthTokens\u003e} */\nexport const login = (username, password) =\u003e request('/auth/login', {\n    method: 'POST',\n    body: JSON.stringify({ username, password }),\n});\n\nexport const logout = () =\u003e {\n    clearTokens();\n};\n\n// --- Users ---\n/** @returns {Promise\u003cUser\u003e} */\nexport const getMe = () =\u003e request('/users/me');\n\n/** @returns {Promise\u003cUser\u003e} */\nexport const updateProfile = (formData) =\u003e request('/users/me', {\n    method: 'PUT',\n    body: formData,\n});\n\n/** @returns {Promise\u003cUser\u003e} */\nexport const getUserByUsername = (username) =\u003e request(`/users/${username}`);\n\n\n// --- Friends ---\nexport const sendFriendRequest = (username) =\u003e request('/friends/requests', {\n    method: 'POST',\n    body: JSON.stringify({ username }),\n});\n\nexport const getPendingFriendRequests = () =\u003e request('/friends/requests/pending');\n\nexport const acceptFriendRequest = (requestID) =\u003e request(`/friends/requests/${requestID}/accept`, {\n    method: 'PUT',\n});\n\nexport const rejectFriendRequest = (requestID) =\u003e request(`/friends/requests/${requestID}/reject`, {\n    method: 'PUT',\n});\n\nexport const unfriendUser = (userID) =\u003e request(`/friends/${userID}`, {\n    method: 'DELETE',\n});\n\nexport const listFriends = () =\u003e request('/friends');\n\n// --- Groups ---\n/** @returns {Promise\u003cGroup\u003e} */\nexport const createGroup = (formData) =\u003e request('/groups', {\n    method: 'POST',\n    body: formData,\n});\n\n/** @returns {Promise\u003cGroup[]\u003e} */\nexport const searchGroups = (query) =\u003e request(`/groups/search?q=${encodeURIComponent(query)}`);\n\n/** @returns {Promise\u003cvoid\u003e} */\nexport const joinGroup = (handle) =\u003e request(`/groups/${handle}/join`, { method: 'POST' });\n\n/** @returns {Promise\u003cGroup\u003e} */\nexport const getGroupDetails = (groupId) =\u003e request(`/groups/${groupId}`);\n\n/** @returns {Promise\u003cGroup\u003e} */\nexport const updateGroup = (groupId, formData) =\u003e request(`/groups/${groupId}`, {\n    method: 'PUT',\n    body: formData,\n});\n\n/** @returns {Promise\u003cvoid\u003e} */\nexport const addGroupMember = (groupId, friendId) =\u003e request(`/groups/${groupId}/members`, {\n    method: 'POST',\n    body: JSON.stringify({ friend_id: friendId }),\n});\n\n/** @returns {Promise\u003cvoid\u003e} */\nexport const removeGroupMember = (groupId, memberId) =\u003e request(`/groups/${groupId}/members/${memberId}`, { method: 'DELETE' });\n\n/** @returns {Promise\u003cvoid\u003e} */\nexport const leaveGroup = (groupId) =\u003e request(`/groups/${groupId}/leave`, { method: 'POST' });\n\n/** @returns {Promise\u003cvoid\u003e} */\nexport const transferGroupOwnership = (groupId, newOwnerId) =\u003e request(`/groups/${groupId}/transfer-ownership`, {\n    method: 'PUT',\n    body: JSON.stringify({ new_owner_id: newOwnerId }),\n});\n\n/** @returns {Promise\u003cGroup[]\u003e} */\nexport const listMyGroups = () =\u003e request('/groups/me');\n",
  "backend/web/static/js/main.js": "import * as api from './api.js';\nimport * as store from './store.js';\nimport * as ui from './ui.js';\nimport * as ws from './ws.js';\n\n// --- Event Handlers ---\n\nasync function handleAuthFormSubmit(event) {\n    event.preventDefault();\n    const form = event.target;\n    const isSignUp = form.id === 'signup-form';\n    const username = form.username.value;\n    const password = form.password.value;\n    const errorEl = form.querySelector('.error-message');\n    if (errorEl) errorEl.classList.add('hidden'); // Hide previous errors\n\n    try {\n        let data;\n        if (isSignUp) {\n            await api.signup(username, password);\n            // After successful signup, automatically log in\n            data = await api.login(username, password);\n        } else {\n            data = await api.login(username, password);\n        }\n        store.setTokens(data.access_token, data.refresh_token);\n        window.location.href = '/chat';\n    } catch (error) {\n        ui.showError(form.id, error.message);\n    }\n}\n\nasync function handleProfileUpdateFormSubmit(event) {\n    event.preventDefault();\n    const form = event.target;\n    const formData = new FormData(form);\n\n    // Don't send empty values\n    if (!formData.get('username').trim()) formData.delete('username');\n    if (!formData.get('password').trim()) formData.delete('password');\n    if (formData.get('profile_pic') \u0026\u0026 formData.get('profile_pic').size === 0) formData.delete('profile_pic');\n\n    try {\n        const updatedUser = await api.updateProfile(formData);\n        store.setCurrentUser(updatedUser);\n        ui.renderProfile(updatedUser);\n        ui.showNotification('Profile updated successfully!', 'success');\n        form.reset(); // Clear form fields after successful update\n    } catch (error) {\n        ui.showNotification(`Profile update failed: ${error.message}`, 'error');\n    }\n}\n\nfunction handleLogout() {\n    api.logout(); // Clears tokens from store and local storage\n    window.location.href = '/';\n}\n\nasync function handleAddFriendSubmit(event) {\n    event.preventDefault();\n    const usernameInput = document.getElementById('add-friend-username');\n    const username = usernameInput.value.trim();\n    if (!username) return;\n\n    try {\n        await api.sendFriendRequest(username);\n        ui.showNotification(`Friend request sent to ${username}`, 'success');\n        ui.closeModal('add-friend-modal');\n        usernameInput.value = ''; // Clear input field\n        refreshPendingRequests();\n    } catch (error) {\n        ui.showNotification(`Error: ${error.message}`, 'error');\n    }\n}\n\nasync function handleFriendAction(event) {\n    const button = event.target;\n    try {\n        if (button.classList.contains('accept-request-button')) {\n            const requestId = button.dataset.requestId;\n            await api.acceptFriendRequest(requestId);\n            ui.showNotification('Friend request accepted!', 'success');\n        } else if (button.classList.contains('reject-request-button')) {\n            const requestId = button.dataset.requestId;\n            await api.rejectFriendRequest(requestId);\n            ui.showNotification('Friend request rejected.', 'info');\n        } else if (button.classList.contains('unfriend-button')) {\n            const friendId = button.dataset.friendId;\n            if (confirm('Are you sure you want to unfriend this user?')) {\n                await api.unfriendUser(friendId);\n                ui.showNotification('User unfriended.', 'info');\n            } else {\n                return; // Do not proceed with refresh if cancelled\n            }\n        } else {\n            return; // Not a recognized action button\n        }\n        refreshFriendsList();\n        refreshPendingRequests();\n    } catch (error) {\n        ui.showNotification(`Error: ${error.message}`, 'error');\n    }\n}\n\nasync function handleCreateGroupSubmit(event) {\n    event.preventDefault();\n    const form = event.target;\n    const formData = new FormData(form);\n    // Ensure handle starts with '#'\n    const handleInput = form.querySelector('#create-group-handle');\n    formData.set('handle', `#${handleInput.value.replace(/^#/, '')}`);\n\n    try {\n        const group = await api.createGroup(formData);\n        ui.showNotification(`Group \"${group.name}\" created!`, 'success');\n        ui.closeModal('create-group-modal');\n        form.reset();\n        refreshGroupsList();\n    } catch (error) {\n        ui.showNotification(`Error creating group: ${error.message}`, 'error');\n    }\n}\n\nasync function handleSearchGroup(event) {\n    const query = event.target.value.trim();\n    if (query.length \u003c 2) {\n        document.getElementById('search-group-results').innerHTML = '';\n        return;\n    }\n    try {\n        const groups = await api.searchGroups(query);\n        ui.renderGroupSearchResults(groups, handleJoinGroupClick);\n    } catch (error) {\n        ui.showNotification(`Error searching groups: ${error.message}`, 'error');\n    }\n}\n\nasync function handleJoinGroupClick(event) {\n    const handle = event.target.dataset.handle;\n    try {\n        await api.joinGroup(handle);\n        ui.showNotification(`Successfully joined group #${handle}`, 'success');\n        refreshGroupsList();\n        ui.closeModal('search-group-modal');\n    } catch (error) {\n        ui.showNotification(`Error joining group: ${error.message}`, 'error');\n    }\n}\n\n// --- Data Refresh Functions ---\n\nexport async function refreshFriendsList() {\n    try {\n        const friends = await api.listFriends();\n        store.setFriends(friends);\n        ui.renderFriendList(friends);\n    } catch (error) {\n        console.error('Failed to refresh friends list:', error);\n        ui.showNotification('Failed to load friends.', 'error');\n    }\n}\n\nexport async function refreshPendingRequests() {\n    try {\n        const requests = await api.getPendingFriendRequests();\n        store.setPendingRequests(requests);\n        const currentUser = store.getCurrentUser();\n        if (currentUser) {\n            ui.renderPendingRequests(requests, currentUser.id);\n        }\n    } catch (error) {\n        console.error('Failed to refresh pending requests:', error);\n        ui.showNotification('Failed to load pending requests.', 'error');\n    }\n}\n\nexport async function refreshGroupsList() {\n    try {\n        const groups = await api.listMyGroups();\n        store.setGroups(groups);\n        ui.renderGroupList(groups);\n    } catch (error) {\n        console.error('Failed to refresh groups list:', error);\n        ui.showNotification('Failed to load groups.', 'error');\n    }\n}\n\n// --- Initialization ---\n\nfunction initAuthPage() {\n    document.getElementById('login-form')?.addEventListener('submit', handleAuthFormSubmit);\n    document.getElementById('signup-form')?.addEventListener('submit', handleAuthFormSubmit);\n    document.getElementById('show-signup-form')?.addEventListener('click', ui.toggleAuthForms);\n    document.getElementById('show-login-form')?.addEventListener('click', ui.toggleAuthForms);\n}\n\nasync function initChatPage() {\n    // Bind static event listeners\n    document.getElementById('logout-button').addEventListener('click', handleLogout);\n    document.getElementById('profile-update-form').addEventListener('submit', handleProfileUpdateFormSubmit);\n    document.getElementById('add-friend-button').addEventListener('click', () =\u003e ui.openModal('add-friend-modal'));\n    document.getElementById('add-friend-form').addEventListener('submit', handleAddFriendSubmit);\n    document.getElementById('create-group-button').addEventListener('click', () =\u003e ui.openModal('create-group-modal'));\n    document.getElementById('create-group-form').addEventListener('submit', handleCreateGroupSubmit);\n    document.getElementById('search-group-button').addEventListener('click', () =\u003e ui.openModal('search-group-modal'));\n    document.getElementById('search-group-query').addEventListener('input', handleSearchGroup);\n\n    // Bind dynamic event listeners for friend actions (delegation)\n    document.getElementById('friends-container').addEventListener('click', handleFriendAction);\n    document.getElementById('pending-requests-list').addEventListener('click', handleFriendAction); // Listen for accept/reject on pending requests\n\n    // Initial data fetch\n    try {\n        const user = await api.getMe();\n        store.setCurrentUser(user);\n        ui.renderProfile(user);\n\n        await Promise.all([\n            refreshFriendsList(),\n            refreshPendingRequests(),\n            refreshGroupsList(),\n        ]);\n\n        // Connect to WebSocket\n        ws.connect();\n\n    } catch (error) {\n        console.error('Failed to initialize chat page:', error);\n        ui.showNotification('Failed to load chat data. Please log in again.', 'error');\n        store.clearTokens(); // Clear any invalid tokens\n        window.location.href = '/';\n    }\n}\n\n// --- Main Execution ---\n\ndocument.addEventListener('DOMContentLoaded', () =\u003e {\n    const path = window.location.pathname;\n    if (path === '/' || path === '/index.html') {\n        if (store.getAccessToken()) {\n            // If tokens exist, redirect to chat page\n            window.location.href = '/chat';\n        } else {\n            initAuthPage();\n        }\n    } else if (path.startsWith('/chat')) {\n        if (!store.getAccessToken()) {\n            // If no tokens, redirect to login page\n            window.location.href = '/';\n        } else {\n            initChatPage();\n        }\n    }\n});",
  "backend/web/static/js/store.js": "/**\n * @typedef {object} User\n * @property {string} id\n * @property {string} username\n * @property {string} profile_pic_url\n * @property {string} created_at\n * @property {string} updated_at\n */\n\n/**\n * @typedef {object} FriendRequest\n * @property {string} id\n * @property {string} sender_id\n * @property {string} receiver_id\n * @property {User} Sender // Note: Capitalized 'Sender' as per attempted content's WS event payload\n * @property {User} Receiver // Note: Capitalized 'Receiver' as per attempted content's WS event payload\n */\n\n/**\n * @typedef {object} Group\n * @property {string} id\n * @property {string} handle\n * @property {string} name\n * @property {string} photo_url\n * @property {string} owner_id\n * @property {string} created_at\n * @property {string} updated_at\n */\n\n/**\n * @typedef {object} ActiveChat\n * @property {('friend'|'group'|null)} type\n * @property {string|null} id\n */\n\nconst state = {\n    /** @type {User | null} */\n    currentUser: null,\n    accessToken: localStorage.getItem('accessToken'),\n    refreshToken: localStorage.getItem('refreshToken'),\n    /** @type {User[]} */\n    friends: [],\n    /** @type {FriendRequest[]} */\n    pendingRequests: [],\n    /** @type {Group[]} */\n    groups: [], // Added groups\n    /** @type {ActiveChat} */\n    activeChat: { type: null, id: null }, // Added activeChat\n};\n\n/** @param {User} user */\nexport function setCurrentUser(user) {\n    state.currentUser = user;\n}\n\nexport function getCurrentUser() {\n    return state.currentUser;\n}\n\nexport function setTokens(access, refresh) {\n    state.accessToken = access;\n    state.refreshToken = refresh;\n    localStorage.setItem('accessToken', access);\n    localStorage.setItem('refreshToken', refresh);\n}\n\nexport function getAccessToken() {\n    return state.accessToken;\n}\n\nexport function getRefreshToken() {\n    return state.refreshToken;\n}\n\nexport function clearTokens() {\n    state.currentUser = null;\n    state.accessToken = null;\n    state.refreshToken = null;\n    state.friends = [];\n    state.pendingRequests = [];\n    state.groups = []; // Clear groups on logout\n    state.activeChat = { type: null, id: null }; // Clear active chat on logout\n    localStorage.removeItem('accessToken');\n    localStorage.removeItem('refreshToken');\n}\n\nexport function setFriends(friends) {\n    state.friends = friends;\n}\n\nexport function getFriends() {\n    return state.friends;\n}\n\nexport function setPendingRequests(requests) {\n    state.pendingRequests = requests;\n}\n\nexport function getPendingRequests() {\n    return state.pendingRequests;\n}\n\n/** @param {Group[]} groups */\nexport function setGroups(groups) {\n    state.groups = groups;\n}\n\n/** @returns {Group[]} */\nexport function getGroups() {\n    return state.groups;\n}\n",
  "backend/web/static/js/ui.js": "/**\n * @typedef {import('./api.js').User} User\n */\n/**\n * @typedef {import('./store.js').FriendRequest} FriendRequest\n */\n/**\n * @typedef {import('./api.js').Group} Group\n */\n\nexport function toggleAuthForms() {\n    document.getElementById('login-container').classList.toggle('hidden');\n    document.getElementById('signup-container').classList.toggle('hidden');\n}\n\n/**\n * @param {string} formId\n * @param {string} message\n */\nexport function showError(formId, message) {\n    const errorEl = document.querySelector(`#${formId} .error-message`);\n    if (errorEl) {\n        errorEl.textContent = message;\n        errorEl.classList.remove('hidden');\n    }\n}\n\n/**\n * @param {User} user\n */\nexport function renderProfile(user) {\n    const container = document.getElementById('profile-container');\n    if (!container || !user) return;\n    const profilePic = user.profile_pic_url ? `/uploads/${user.profile_pic_url}` : 'https://via.placeholder.com/40';\n    container.innerHTML = `\n        \u003cdiv class=\"flex items-center\"\u003e\n            \u003cimg src=\"${profilePic}\" alt=\"Profile\" class=\"w-10 h-10 rounded-full mr-3 object-cover\"\u003e\n            \u003cdiv\u003e\n                \u003cp class=\"font-semibold\"\u003e${user.username}\u003c/p\u003e\n                \u003cp class=\"text-sm text-gray-500\"\u003eJoined: ${new Date(user.created_at).toLocaleDateString()}\u003c/p\u003e\n            \u003c/div\u003e\n        \u003c/div\u003e\n    `;\n}\n\n/**\n * @param {string} message\n * @param {'info'|'success'|'error'} type\n */\nexport function showNotification(message, type = 'info') {\n    const container = document.getElementById('notification-container');\n    if (!container) return;\n\n    const colors = {\n        info: 'bg-blue-500',\n        success: 'bg-green-500',\n        error: 'bg-red-500',\n    };\n\n    const notification = document.createElement('div');\n    notification.className = `text-white px-4 py-2 rounded-md shadow-lg mb-2 ${colors[type] || colors.info}`;\n    notification.textContent = message;\n\n    container.appendChild(notification);\n\n    setTimeout(() =\u003e {\n        notification.remove();\n    }, 3000);\n}\n\n/**\n * @param {User[]} friends\n */\nexport function renderFriendList(friends) {\n    const list = document.getElementById('friends-list');\n    if (!list) return;\n    if (friends.length === 0) {\n        list.innerHTML = '\u003cli class=\"text-gray-500 text-sm p-2\"\u003eNo friends yet.\u003c/li\u003e';\n        return;\n    }\n    list.innerHTML = friends.map(friend =\u003e `\n        \u003cli class=\"flex justify-between items-center p-2 hover:bg-gray-100 rounded cursor-pointer\" data-user-id=\"${friend.id}\"\u003e\n            \u003cdiv class=\"flex items-center\"\u003e\n                \u003cimg src=\"${friend.profile_pic_url ? `/uploads/${friend.profile_pic_url}` : 'https://via.placeholder.com/40'}\" class=\"w-8 h-8 rounded-full mr-3 object-cover\"\u003e\n                \u003cspan\u003e${friend.username}\u003c/span\u003e\n            \u003c/div\u003e\n            \u003cbutton class=\"unfriend-button text-red-500 hover:text-red-700 text-xs\" data-friend-id=\"${friend.id}\"\u003eUnfriend\u003c/button\u003e\n        \u003c/li\u003e\n    `).join('');\n}\n\n/**\n * @param {Group[]} groups\n */\nexport function renderGroupList(groups) {\n    const list = document.getElementById('groups-list');\n    if (!list) return;\n    if (groups.length === 0) {\n        list.innerHTML = '\u003cli class=\"text-gray-500 text-sm p-2\"\u003eNo groups yet.\u003c/li\u003e';\n        return;\n    }\n    list.innerHTML = groups.map(group =\u003e `\n        \u003cli class=\"flex justify-between items-center p-2 hover:bg-gray-100 rounded cursor-pointer\" data-group-id=\"${group.id}\"\u003e\n            \u003cdiv class=\"flex items-center\"\u003e\n                \u003cimg src=\"${group.photo_url ? `/uploads/${group.photo_url}` : 'https://via.placeholder.com/40'}\" class=\"w-8 h-8 rounded-full mr-3 object-cover\"\u003e\n                \u003cspan\u003e${group.name} (${group.handle})\u003c/span\u003e\n            \u003c/div\u003e\n        \u003c/li\u003e\n    `).join('');\n}\n\n/**\n * @param {FriendRequest[]} requests\n * @param {string} currentUserID\n */\nexport function renderPendingRequests(requests, currentUserID) {\n    const list = document.getElementById('pending-requests-list');\n    if (!list) return;\n    if (requests.length === 0) {\n        list.innerHTML = '\u003cli class=\"text-gray-500 text-sm p-2\"\u003eNo pending requests.\u003c/li\u003e';\n        return;\n    }\n    list.innerHTML = requests.map(req =\u003e {\n        const isIncoming = req.receiver_id === currentUserID;\n        const user = isIncoming ? req.Sender : req.Receiver; // Use capitalized Sender/Receiver as per WS event\n        const actionButtons = isIncoming ? `\n            \u003cdiv\u003e\n                \u003cbutton class=\"accept-request-button text-green-500 hover:text-green-700 text-xs mr-2\" data-request-id=\"${req.id}\"\u003eAccept\u003c/button\u003e\n                \u003cbutton class=\"reject-request-button text-red-500 hover:text-red-700 text-xs\" data-request-id=\"${req.id}\"\u003eReject\u003c/button\u003e\n            \u003c/div\u003e\n        ` : '\u003cspan class=\"text-xs text-gray-400\"\u003eSent\u003c/span\u003e';\n\n        return `\n            \u003cli class=\"flex justify-between items-center p-2 hover:bg-gray-100 rounded\"\u003e\n                \u003cdiv class=\"flex items-center\"\u003e\n                    \u003cimg src=\"${user.profile_pic_url ? `/uploads/${user.profile_pic_url}` : 'https://via.placeholder.com/40'}\" class=\"w-8 h-8 rounded-full mr-3 object-cover\"\u003e\n                    \u003cspan\u003e${user.username}\u003c/span\u003e\n                \u003c/div\u003e\n                ${actionButtons}\n            \u003c/li\u003e\n        `;\n    }).join('');\n}\n\n/**\n * @param {Group[]} groups\n * @param {(event: Event) =\u003e void} joinHandler\n */\nexport function renderGroupSearchResults(groups, joinHandler) {\n    const resultsContainer = document.getElementById('search-group-results');\n    if (!resultsContainer) return;\n    if (groups.length === 0) {\n        resultsContainer.innerHTML = '\u003cp class=\"text-gray-500 p-2\"\u003eNo groups found.\u003c/p\u003e';\n        return;\n    }\n    resultsContainer.innerHTML = groups.map(group =\u003e `\n        \u003cdiv class=\"flex justify-between items-center p-2 border-b border-gray-200 last:border-b-0\"\u003e\n            \u003cdiv class=\"flex items-center\"\u003e\n                \u003cimg src=\"${group.photo_url ? `/uploads/${group.photo_url}` : 'https://via.placeholder.com/40'}\" class=\"w-8 h-8 rounded-full mr-3 object-cover\"\u003e\n                \u003cdiv\u003e\n                    \u003cp class=\"font-semibold\"\u003e${group.name}\u003c/p\u003e\n                    \u003cp class=\"text-sm text-gray-600\"\u003e${group.handle}\u003c/p\u003e\n                \u003c/div\u003e\n            \u003c/div\u003e\n            \u003cbutton class=\"join-group-button px-3 py-1 bg-blue-500 text-white text-sm rounded hover:bg-blue-600\" data-handle=\"${group.handle.substring(1)}\"\u003eJoin\u003c/button\u003e\n        \u003c/div\u003e\n    `).join('');\n\n    document.querySelectorAll('.join-group-button').forEach(button =\u003e {\n        button.addEventListener('click', joinHandler);\n    });\n}\n\n/**\n * @param {string} modalId\n */\nexport function openModal(modalId) {\n    const modal = document.getElementById(modalId);\n    if (modal) {\n        modal.classList.remove('hidden');\n        modal.classList.add('flex'); // Use flex to center content\n\n        // Focus on the first input\n        const firstInput = modal.querySelector('input[type=\"text\"]');\n        if (firstInput) {\n            firstInput.focus();\n        }\n\n        // Define handlers to be able to remove them later\n        const closeModalHandler = () =\u003e {\n            closeModal(modalId);\n            modal.removeEventListener('click', overlayClickHandler);\n            document.removeEventListener('keydown', escapeKeyHandler);\n        };\n\n        const overlayClickHandler = (event) =\u003e {\n            if (event.target === modal) {\n                closeModalHandler();\n            }\n        };\n\n        const escapeKeyHandler = (event) =\u003e {\n            if (event.key === 'Escape') {\n                closeModalHandler();\n            }\n        };\n\n        modal.querySelectorAll('.modal-close-button').forEach(btn =\u003e {\n            btn.onclick = closeModalHandler;\n        });\n        modal.addEventListener('click', overlayClickHandler);\n        document.addEventListener('keydown', escapeKeyHandler);\n    }\n}\n\n/**\n * @param {string} modalId\n */\nexport function closeModal(modalId) {\n    const modal = document.getElementById(modalId);\n    if (modal) {\n        modal.classList.add('hidden');\n        modal.classList.remove('flex');\n    }\n}\n",
  "backend/web/static/js/ws.js": "import { getAccessToken } from './store.js';\nimport { showNotification } from './ui.js';\nimport { refreshFriendsList, refreshPendingRequests, refreshGroupsList } from './main.js';\n\nlet socket = null;\nlet reconnectInterval = 1000; // Initial reconnect interval in ms\n\n/**\n * Handles incoming WebSocket events and dispatches actions.\n * @param {object} event - The parsed WebSocket event.\n * @param {string} event.type - The type of the event.\n * @param {object} event.payload - The payload of the event.\n */\nfunction handleIncomingEvent(event) {\n    console.log('WebSocket event received:', event);\n    switch (event.type) {\n        case 'new_message':\n            // TODO: Handle new message\n            showNotification(`New message from ${event.payload.sender_id}`);\n            break;\n        case 'friend_request_received':\n            showNotification(`New friend request from ${event.payload.Sender.username}`);\n            refreshPendingRequests();\n            break;\n        case 'friend_request_accepted':\n            showNotification(`Your friend request to ${event.payload.Sender.username} was accepted.`);\n            refreshFriendsList();\n            refreshPendingRequests();\n            break;\n        case 'friend_request_rejected':\n            showNotification(`Your friend request to ${event.payload.Sender.username} was rejected.`);\n            refreshPendingRequests();\n            break;\n        case 'unfriended':\n            showNotification(`You were unfriended by a user.`);\n            refreshFriendsList();\n            break;\n        case 'group_joined':\n            showNotification(`You joined the group: ${event.payload.name}`);\n            refreshGroupsList();\n            break;\n        case 'group_created':\n            showNotification(`Group \"${event.payload.name}\" created!`);\n            refreshGroupsList();\n            break;\n        case 'group_left':\n            showNotification(`You left a group.`);\n            refreshGroupsList();\n            break;\n        case 'group_member_added':\n            showNotification(`${event.payload.member.username} was added to group ${event.payload.group.name}.`);\n            // Potentially refresh group details if active, or just groups list\n            refreshGroupsList();\n            break;\n        case 'group_member_removed':\n            showNotification(`${event.payload.member.username} was removed from group ${event.payload.group.name}.`);\n            refreshGroupsList();\n            break;\n        case 'group_ownership_transferred':\n            showNotification(`Ownership of group ${event.payload.group.name} transferred to ${event.payload.new_owner.username}.`);\n            refreshGroupsList();\n            break;\n        case 'group_updated':\n            showNotification(`Group ${event.payload.name} was updated.`);\n            refreshGroupsList();\n            break;\n        default:\n            console.warn('Unhandled event type:', event.type);\n    }\n}\n\nexport function connect() {\n    const token = getAccessToken();\n    if (!token) {\n        console.error('No access token found for WebSocket connection.');\n        return;\n    }\n\n    // Prevent multiple connections\n    if (socket \u0026\u0026 (socket.readyState === WebSocket.OPEN || socket.readyState === WebSocket.CONNECTING)) {\n        console.log('WebSocket is already connected or connecting.');\n        return;\n    }\n\n    const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';\n    const host = window.location.host;\n    const wsUrl = `${protocol}//${host}/ws`;\n\n    socket = new WebSocket(wsUrl);\n\n    socket.onopen = () =\u003e {\n        console.log('WebSocket connected');\n        reconnectInterval = 1000; // Reset reconnect interval on successful connection\n        // Send auth token\n        socket.send(JSON.stringify({ type: 'auth', payload: { token } }));\n        showNotification('Connected to real-time service.', 'success');\n    };\n\n    socket.onmessage = (event) =\u003e {\n        try {\n            const data = JSON.parse(event.data);\n            handleIncomingEvent(data);\n        } catch (error) {\n            console.error('Error parsing WebSocket message:', error);\n        }\n    };\n\n    socket.onclose = (event) =\u003e {\n        console.log('WebSocket disconnected:', event.reason);\n        showNotification('Real-time connection lost. Attempting to reconnect...', 'error');\n        setTimeout(connect, reconnectInterval);\n        reconnectInterval = Math.min(reconnectInterval * 2, 30000); // Exponential backoff, max 30 seconds\n    };\n\n    socket.onerror = (error) =\u003e {\n        console.error('WebSocket error:', error);\n        showNotification('A real-time connection error occurred.', 'error');\n        socket.close(); // Close to trigger onclose and reconnect logic\n    };\n}\n\n/**\n * Sends a message over the WebSocket connection.\n * @param {string} messageType - The type of the message.\n * @param {object} payload - The payload of the message.\n */\nexport function send(messageType, payload) {\n    if (socket \u0026\u0026 socket.readyState === WebSocket.OPEN) {\n        socket.send(JSON.stringify({ type: messageType, payload }));\n    } else {\n        console.error('WebSocket is not connected.');\n        showNotification('Cannot send message: Not connected to real-time service.', 'error');\n    }\n}\n",
  "backend/web/templates/chat.html": "\u003c!DOCTYPE html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n    \u003cmeta charset=\"UTF-8\"\u003e\n    \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"\u003e\n    \u003ctitle\u003eQuikChat\u003c/title\u003e\n    \u003cscript src=\"https://cdn.tailwindcss.com\"\u003e\u003c/script\u003e\n\u003c/head\u003e\n\u003cbody class=\"bg-gray-100 font-sans\"\u003e\n    \u003cdiv id=\"notification-container\" class=\"fixed bottom-5 right-5 z-50 space-y-2\"\u003e\u003c/div\u003e\n\n    \u003cdiv class=\"flex h-screen\"\u003e\n        \u003c!-- Sidebar --\u003e\n        \u003cdiv class=\"w-1/4 bg-white p-4 border-r border-gray-200 flex flex-col\"\u003e\n            \u003c!-- Profile Section --\u003e\n            \u003cdiv id=\"profile-container\" class=\"mb-4 border-b pb-4\"\u003e\n                \u003c!-- Profile will be rendered here by JS --\u003e\n            \u003c/div\u003e\n\n            \u003c!-- Friends \u0026 Groups Container --\u003e\n            \u003cdiv class=\"flex-grow overflow-y-auto\"\u003e\n                \u003c!-- Friends Section --\u003e\n                \u003cdiv id=\"friends-container\" class=\"mb-4\"\u003e\n                    \u003cdiv class=\"flex justify-between items-center mb-2\"\u003e\n                        \u003ch2 class=\"text-lg font-semibold text-gray-700\"\u003eFriends\u003c/h2\u003e\n                        \u003cbutton id=\"add-friend-button\" class=\"text-blue-500 hover:text-blue-700 text-xl font-bold\"\u003e+\u003c/button\u003e\n                    \u003c/div\u003e\n                    \u003cul id=\"friends-list\" class=\"space-y-2\"\u003e\n                        \u003c!-- Friends list will be rendered here --\u003e\n                    \u003c/ul\u003e\n                \u003c/div\u003e\n\n                \u003c!-- Groups Section --\u003e\n                \u003cdiv id=\"groups-container\" class=\"mb-4\"\u003e\n                    \u003cdiv class=\"flex justify-between items-center mb-2\"\u003e\n                        \u003ch2 class=\"text-lg font-semibold text-gray-700\"\u003eGroups\u003c/h2\u003e\n                        \u003cdiv\u003e\n                            \u003cbutton id=\"search-group-button\" class=\"text-blue-500 hover:text-blue-700 text-sm mr-2\"\u003eFind\u003c/button\u003e\n                            \u003cbutton id=\"create-group-button\" class=\"text-blue-500 hover:text-blue-700 text-xl font-bold\"\u003e+\u003c/button\u003e\n                        \u003c/div\u003e\n                    \u003c/div\u003e\n                    \u003cul id=\"groups-list\" class=\"space-y-2\"\u003e\n                        \u003c!-- Groups list will be rendered here --\u003e\n                    \u003c/ul\u003e\n                \u003c/div\u003e\n\n                \u003c!-- Pending Requests Section --\u003e\n                \u003cdiv id=\"pending-requests-container\" class=\"mb-4\"\u003e\n                    \u003ch2 class=\"text-lg font-semibold text-gray-700 mb-2\"\u003ePending Requests\u003c/h2\u003e\n                    \u003cul id=\"pending-requests-list\" class=\"space-y-2\"\u003e\n                        \u003c!-- Pending requests will be rendered here --\u003e\n                    \u003c/ul\u003e\n                \u003c/div\u003e\n            \u003c/div\u003e\n\n            \u003c!-- Logout Button --\u003e\n            \u003cbutton id=\"logout-button\" class=\"w-full bg-red-500 text-white py-2 rounded hover:bg-red-600\"\u003eLogout\u003c/button\u003e\n        \u003c/div\u003e\n\n        \u003c!-- Main Chat Area --\u003e\n        \u003cdiv class=\"w-3/4 flex flex-col\"\u003e\n            \u003c!-- Chat Header --\u003e\n            \u003cdiv class=\"bg-white p-4 border-b border-gray-200\"\u003e\n                \u003ch2 class=\"text-xl font-bold\"\u003eChat Room\u003c/h2\u003e\n            \u003c/div\u003e\n\n            \u003c!-- Messages --\u003e\n            \u003cdiv class=\"flex-grow p-4 overflow-y-auto bg-gray-50\"\u003e\n                \u003c!-- Profile Update Form --\u003e\n                \u003cdiv class=\"max-w-md mx-auto bg-white p-6 rounded-lg shadow-md\"\u003e\n                    \u003ch3 class=\"text-2xl font-bold mb-4 text-center\"\u003eUpdate Profile\u003c/h3\u003e\n                    \u003cform id=\"profile-update-form\" class=\"space-y-4\"\u003e\n                        \u003cdiv\u003e\n                            \u003clabel for=\"update-username\" class=\"block text-sm font-medium text-gray-700\"\u003eUsername\u003c/label\u003e\n                            \u003cinput type=\"text\" id=\"update-username\" name=\"username\" class=\"mt-1 block w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm\"\u003e\n                        \u003c/div\u003e\n                        \u003cdiv\u003e\n                            \u003clabel for=\"update-password\" class=\"block text-sm font-medium text-gray-700\"\u003eNew Password\u003c/label\u003e\n                            \u003cinput type=\"password\" id=\"update-password\" name=\"password\" class=\"mt-1 block w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm\"\u003e\n                        \u003c/div\u003e\n                        \u003cdiv\u003e\n                            \u003clabel for=\"update-profile-pic\" class=\"block text-sm font-medium text-gray-700\"\u003eProfile Picture\u003c/label\u003e\n                            \u003cinput type=\"file\" id=\"update-profile-pic\" name=\"profile_pic\" class=\"mt-1 block w-full text-sm text-gray-500 file:mr-4 file:py-2 file:px-4 file:rounded-full file:border-0 file:text-sm file:font-semibold file:bg-indigo-50 file:text-indigo-600 hover:file:bg-indigo-100\"\u003e\n                        \u003c/div\u003e\n                        \u003cbutton type=\"submit\" class=\"w-full flex justify-center py-2 px-4 border border-transparent rounded-md shadow-sm text-sm font-medium text-white bg-indigo-600 hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500\"\u003eUpdate\u003c/button\u003e\n                    \u003c/form\u003e\n                \u003c/div\u003e\n            \u003c/div\u003e\n\n            \u003c!-- Message Input --\u003e\n            \u003cdiv class=\"bg-white p-4 border-t border-gray-200\"\u003e\n                \u003cinput type=\"text\" placeholder=\"Type a message...\" class=\"w-full p-2 border border-gray-300 rounded\"\u003e\n            \u003c/div\u003e\n        \u003c/div\u003e\n    \u003c/div\u003e\n\n    \u003c!-- Add Friend Modal --\u003e\n    \u003cdiv id=\"add-friend-modal\" class=\"fixed inset-0 bg-black bg-opacity-50 hidden items-center justify-center z-40\"\u003e\n        \u003cdiv class=\"bg-white p-6 rounded-lg shadow-xl w-96\"\u003e\n            \u003ch3 class=\"text-xl font-bold mb-4\"\u003eAdd Friend\u003c/h3\u003e\n            \u003cform id=\"add-friend-form\"\u003e\n                \u003cinput type=\"text\" id=\"add-friend-username\" placeholder=\"Enter username\" class=\"w-full p-2 border border-gray-300 rounded mb-4\"\u003e\n                \u003cdiv class=\"flex justify-end space-x-2\"\u003e\n                    \u003cbutton type=\"button\" class=\"modal-close-button px-4 py-2 bg-gray-200 rounded hover:bg-gray-300\"\u003eCancel\u003c/button\u003e\n                    \u003cbutton type=\"submit\" class=\"px-4 py-2 bg-blue-500 text-white rounded hover:bg-blue-600\"\u003eSend Request\u003c/button\u003e\n                \u003c/div\u003e\n            \u003c/form\u003e\n        \u003c/div\u003e\n    \u003c/div\u003e\n\n    \u003c!-- Create Group Modal --\u003e\n    \u003cdiv id=\"create-group-modal\" class=\"fixed inset-0 bg-black bg-opacity-50 hidden items-center justify-center z-40\"\u003e\n        \u003cdiv class=\"bg-white p-6 rounded-lg shadow-xl w-96\"\u003e\n            \u003ch3 class=\"text-xl font-bold mb-4\"\u003eCreate Group\u003c/h3\u003e\n            \u003cform id=\"create-group-form\"\u003e\n                \u003cinput type=\"text\" id=\"create-group-handle\" name=\"handle\" placeholder=\"Group Handle (e.g., #cooldevs)\" class=\"w-full p-2 border border-gray-300 rounded mb-2\"\u003e\n                \u003cinput type=\"text\" id=\"create-group-name\" name=\"name\" placeholder=\"Group Name\" class=\"w-full p-2 border border-gray-300 rounded mb-2\"\u003e\n                \u003cinput type=\"file\" id=\"create-group-photo\" name=\"photo\" class=\"w-full text-sm text-gray-500 file:mr-4 file:py-2 file:px-4 file:rounded-full file:border-0 file:text-sm file:font-semibold file:bg-indigo-50 file:text-indigo-600 hover:file:bg-indigo-100 mb-4\"\u003e\n                \u003cdiv class=\"flex justify-end space-x-2\"\u003e\n                    \u003cbutton type=\"button\" class=\"modal-close-button px-4 py-2 bg-gray-200 rounded hover:bg-gray-300\"\u003eCancel\u003c/button\u003e\n                    \u003cbutton type=\"submit\" class=\"px-4 py-2 bg-blue-500 text-white rounded hover:bg-blue-600\"\u003eCreate\u003c/button\u003e\n                \u003c/div\u003e\n            \u003c/form\u003e\n        \u003c/div\u003e\n    \u003c/div\u003e\n\n    \u003c!-- Search Group Modal --\u003e\n    \u003cdiv id=\"search-group-modal\" class=\"fixed inset-0 bg-black bg-opacity-50 hidden items-center justify-center z-40\"\u003e\n        \u003cdiv class=\"bg-white p-6 rounded-lg shadow-xl w-96\"\u003e\n            \u003ch3 class=\"text-xl font-bold mb-4\"\u003eFind \u0026 Join a Group\u003c/h3\u003e\n            \u003cform id=\"search-group-form\"\u003e\n                \u003cinput type=\"text\" id=\"search-group-query\" placeholder=\"Search by handle...\" class=\"w-full p-2 border border-gray-300 rounded mb-4\"\u003e\n            \u003c/form\u003e\n            \u003cdiv id=\"search-group-results\" class=\"max-h-60 overflow-y-auto\"\u003e\u003c/div\u003e\n            \u003cdiv class=\"flex justify-end mt-4\"\u003e\n                \u003cbutton type=\"button\" class=\"modal-close-button px-4 py-2 bg-gray-200 rounded hover:bg-gray-300\"\u003eClose\u003c/button\u003e\n            \u003c/div\u003e\n        \u003c/div\u003e\n    \u003c/div\u003e\n\n    \u003cscript type=\"module\" src=\"/static/js/main.js\"\u003e\u003c/script\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n",
  "backend/web/templates/index.html": "\u003c!DOCTYPE html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n    \u003cmeta charset=\"UTF-8\"\u003e\n    \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"\u003e\n    \u003ctitle\u003eWelcome to QuikChat\u003c/title\u003e\n    \u003cscript src=\"https://cdn.tailwindcss.com\"\u003e\u003c/script\u003e\n\u003c/head\u003e\n\u003cbody class=\"bg-gray-100 flex items-center justify-center h-screen\"\u003e\n    \u003cdiv class=\"w-full max-w-md\"\u003e\n        \u003c!-- Login Form --\u003e\n        \u003cdiv id=\"login-container\"\u003e\n            \u003cform id=\"login-form\" class=\"bg-white shadow-md rounded px-8 pt-6 pb-8 mb-4\"\u003e\n                \u003ch1 class=\"text-2xl font-bold text-center mb-6\"\u003eLogin to QuikChat\u003c/h1\u003e\n                \u003cdiv class=\"mb-4\"\u003e\n                    \u003clabel class=\"block text-gray-700 text-sm font-bold mb-2\" for=\"login-username\"\u003e\n                        Username\n                    \u003c/label\u003e\n                    \u003cinput class=\"shadow appearance-none border rounded w-full py-2 px-3 text-gray-700 leading-tight focus:outline-none focus:shadow-outline\" id=\"login-username\" name=\"username\" type=\"text\" placeholder=\"Username\" required\u003e\n                \u003c/div\u003e\n                \u003cdiv class=\"mb-6\"\u003e\n                    \u003clabel class=\"block text-gray-700 text-sm font-bold mb-2\" for=\"login-password\"\u003e\n                        Password\n                    \u003c/label\u003e\n                    \u003cinput class=\"shadow appearance-none border rounded w-full py-2 px-3 text-gray-700 mb-3 leading-tight focus:outline-none focus:shadow-outline\" id=\"login-password\" name=\"password\" type=\"password\" placeholder=\"******************\" required\u003e\n                \u003c/div\u003e\n                \u003cp class=\"error-message text-red-500 text-xs italic mb-4 hidden\"\u003e\u003c/p\u003e\n                \u003cdiv class=\"flex items-center justify-between\"\u003e\n                    \u003cbutton class=\"bg-blue-500 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded focus:outline-none focus:shadow-outline\" type=\"submit\"\u003e\n                        Sign In\n                    \u003c/button\u003e\n                    \u003ca id=\"show-signup-form\" class=\"inline-block align-baseline font-bold text-sm text-blue-500 hover:text-blue-800\" href=\"#\"\u003e\n                        Create an Account\n                    \u003c/a\u003e\n                \u003c/div\u003e\n            \u003c/form\u003e\n        \u003c/div\u003e\n\n        \u003c!-- Signup Form --\u003e\n        \u003cdiv id=\"signup-container\" class=\"hidden\"\u003e\n            \u003cform id=\"signup-form\" class=\"bg-white shadow-md rounded px-8 pt-6 pb-8 mb-4\"\u003e\n                \u003ch1 class=\"text-2xl font-bold text-center mb-6\"\u003eCreate Account\u003c/h1\u003e\n                \u003cdiv class=\"mb-4\"\u003e\n                    \u003clabel class=\"block text-gray-700 text-sm font-bold mb-2\" for=\"signup-username\"\u003e\n                        Username\n                    \u003c/label\u003e\n                    \u003cinput class=\"shadow appearance-none border rounded w-full py-2 px-3 text-gray-700 leading-tight focus:outline-none focus:shadow-outline\" id=\"signup-username\" name=\"username\" type=\"text\" placeholder=\"lowercase, 0-9, _\" required minlength=\"4\" maxlength=\"50\"\u003e\n                \u003c/div\u003e\n                \u003cdiv class=\"mb-6\"\u003e\n                    \u003clabel class=\"block text-gray-700 text-sm font-bold mb-2\" for=\"signup-password\"\u003e\n                        Password\n                    \u003c/label\u003e\n                    \u003cinput class=\"shadow appearance-none border rounded w-full py-2 px-3 text-gray-700 mb-3 leading-tight focus:outline-none focus:shadow-outline\" id=\"signup-password\" name=\"password\" type=\"password\" placeholder=\"******************\" required minlength=\"8\"\u003e\n                \u003c/div\u003e\n                \u003cp class=\"error-message text-red-500 text-xs italic mb-4 hidden\"\u003e\u003c/p\u003e\n                \u003cdiv class=\"flex items-center justify-between\"\u003e\n                    \u003cbutton class=\"bg-green-500 hover:bg-green-700 text-white font-bold py-2 px-4 rounded focus:outline-none focus:shadow-outline\" type=\"submit\"\u003e\n                        Sign Up\n                    \u003c/button\u003e\n                    \u003ca id=\"show-login-form\" class=\"inline-block align-baseline font-bold text-sm text-blue-500 hover:text-blue-800\" href=\"#\"\u003e\n                        Already have an account?\n                    \u003c/a\u003e\n                \u003c/div\u003e\n            \u003c/form\u003e\n        \u003c/div\u003e\n        \u003cp class=\"text-center text-gray-500 text-xs\"\u003e\n            \u0026copy;2024 QuikChat. All rights reserved.\n        \u003c/p\u003e\n    \u003c/div\u003e\n    \u003cscript type=\"module\" src=\"/static/js/main.js\"\u003e\u003c/script\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n```",
  "docker-compose.yml": "version: '3.8'\n\nservices:\n  postgres:\n    image: postgres:13\n    restart: always\n    environment:\n      POSTGRES_USER: user\n      POSTGRES_PASSWORD: password\n      POSTGRES_DB: chatdb\n    ports:\n      - \"5432:5432\"  # Expose Postgres port to host\n    volumes:\n      - postgres_data:/var/lib/postgresql/data\n\n  redis:\n    image: redis:6-alpine\n    restart: always\n    ports:\n      - \"6379:6379\"  # Expose Redis port to host\n    volumes:\n      - redis_data:/data\n\nvolumes:\n  postgres_data:\n  redis_data:\n"
}