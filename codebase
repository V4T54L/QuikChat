{
  "Makefile": ".PHONY: up down logs psql migrate-up run build\n\n# Docker Compose commands\nup:\n\t@echo \"Starting Docker containers...\"\n\tdocker-compose up -d\n\ndown:\n\t@echo \"Stopping Docker containers...\"\n\tdocker-compose down\n\nlogs:\n\t@echo \"Tailing logs...\"\n\tdocker-compose logs -f\n\n# Database commands\npsql:\n\t@echo \"Connecting to PostgreSQL container...\"\n\tdocker-compose exec postgres psql -U user -d chatdb\n\nmigrate-up:\n\t@echo \"Applying database migrations...\"\n\tdocker-compose exec -T postgres psql -U user -d chatdb \u003c backend/migrations/000001_create_users_table.up.sql\n\tdocker-compose exec -T postgres psql -U user -d chatdb \u003c backend/migrations/000002_create_sessions_table.up.sql\n\n# Go application commands\nrun:\n\t@echo \"Running the Go application...\"\n\tgo run ./backend/cmd/server/main.go\n\nbuild:\n\t@echo \"Building the Go application...\"\n\tgo build -o ./bin/server ./backend/cmd/server/main.go\n",
  "backend/cmd/server/main.go": "package main\n\nimport (\n\t\"fmt\"\n\t\"log\"\n\t\"net/http\"\n\n\t\"chat-app/internal/adapter/postgres\"\n\t\"chat-app/internal/service\"\n\t\"chat-app/pkg/config\"\n\n\tdelivery \"chat-app/internal/delivery/http\"\n)\n\nfunc main() {\n\t// Load configuration\n\tcfg := config.Load()\n\n\t// Initialize database connection\n\tdbPool := postgres.NewDB(cfg.DatabaseURL)\n\tdefer dbPool.Close()\n\n\t// Initialize repositories\n\tuserRepo := postgres.NewPostgresUserRepository(dbPool)\n\tsessionRepo := postgres.NewPostgresSessionRepository(dbPool)\n\n\t// Initialize use cases/services\n\tauthUsecase := service.NewAuthService(userRepo, sessionRepo, cfg)\n\n\t// Initialize router\n\trouter := delivery.NewRouter(authUsecase)\n\n\t// Start server\n\tserverAddr := fmt.Sprintf(\":%s\", cfg.Port)\n\tlog.Printf(\"Starting server on %s\", serverAddr)\n\tif err := http.ListenAndServe(serverAddr, router); err != nil {\n\t\tlog.Fatalf(\"Could not start server: %s\\n\", err)\n\t}\n}\n",
  "backend/go.mod": "module chat-app\n\ngo 1.24.0\n",
  "backend/internal/adapter/postgres/postgres.go": "package postgres\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"log\"\n\n\t\"github.com/jackc/pgx/v5/pgxpool\"\n)\n\nfunc NewDB(databaseURL string) *pgxpool.Pool {\n\tdbpool, err := pgxpool.New(context.Background(), databaseURL)\n\tif err != nil {\n\t\tlog.Fatalf(\"Unable to create connection pool: %v\\n\", err)\n\t}\n\n\terr = dbpool.Ping(context.Background())\n\tif err != nil {\n\t\tlog.Fatalf(\"Unable to ping database: %v\\n\", err)\n\t}\n\n\tfmt.Println(\"Successfully connected to PostgreSQL!\")\n\treturn dbpool\n}\n",
  "backend/internal/adapter/postgres/session_repository.go": "package postgres\n\nimport (\n\t\"context\"\n\t\"errors\"\n\n\t\"chat-app/internal/domain\"\n\t\"chat-app/internal/repository\"\n\n\t\"github.com/jackc/pgx/v5\"\n\t\"github.com/jackc/pgx/v5/pgxpool\"\n)\n\ntype postgresSessionRepository struct {\n\tdb *pgxpool.Pool\n}\n\nfunc NewPostgresSessionRepository(db *pgxpool.Pool) repository.SessionRepository {\n\treturn \u0026postgresSessionRepository{db: db}\n}\n\nfunc (r *postgresSessionRepository) Store(ctx context.Context, session *domain.Session) error {\n\tquery := `INSERT INTO sessions (id, user_id, expires_at) VALUES ($1, $2, $3)`\n\t_, err := r.db.Exec(ctx, query, session.ID, session.UserID, session.ExpiresAt)\n\treturn err\n}\n\nfunc (r *postgresSessionRepository) GetByID(ctx context.Context, id string) (*domain.Session, error) {\n\tquery := `SELECT id, user_id, expires_at, created_at FROM sessions WHERE id = $1`\n\n\tsession := \u0026domain.Session{}\n\terr := r.db.QueryRow(ctx, query, id).Scan(\n\t\t\u0026session.ID,\n\t\t\u0026session.UserID,\n\t\t\u0026session.ExpiresAt,\n\t\t\u0026session.CreatedAt,\n\t)\n\tif err != nil {\n\t\tif errors.Is(err, pgx.ErrNoRows) {\n\t\t\treturn nil, nil // Not found\n\t\t}\n\t\treturn nil, err\n\t}\n\treturn session, nil\n}\n\nfunc (r *postgresSessionRepository) Delete(ctx context.Context, id string) error {\n\tquery := `DELETE FROM sessions WHERE id = $1`\n\t_, err := r.db.Exec(ctx, query, id)\n\treturn err\n}\n\nfunc (r *postgresSessionRepository) DeleteAllForUser(ctx context.Context, userID string) error {\n\tquery := `DELETE FROM sessions WHERE user_id = $1`\n\t_, err := r.db.Exec(ctx, query, userID)\n\treturn err\n}\n",
  "backend/internal/adapter/postgres/user_repository.go": "package postgres\n\nimport (\n\t\"context\"\n\t\"errors\"\n\n\t\"chat-app/internal/domain\"\n\t\"chat-app/internal/repository\"\n\n\t\"github.com/jackc/pgx/v5\"\n\t\"github.com/jackc/pgx/v5/pgxpool\"\n)\n\ntype postgresUserRepository struct {\n\tdb *pgxpool.Pool\n}\n\nfunc NewPostgresUserRepository(db *pgxpool.Pool) repository.UserRepository {\n\treturn \u0026postgresUserRepository{db: db}\n}\n\nfunc (r *postgresUserRepository) Create(ctx context.Context, user *domain.User) error {\n\tquery := `INSERT INTO users (id, username, password_hash, profile_pic_url)\n\t\t\t  VALUES ($1, $2, $3, $4)`\n\t_, err := r.db.Exec(ctx, query, user.ID, user.Username, user.PasswordHash, user.ProfilePicURL)\n\treturn err\n}\n\nfunc (r *postgresUserRepository) GetByUsername(ctx context.Context, username string) (*domain.User, error) {\n\tquery := `SELECT id, username, password_hash, profile_pic_url, created_at, updated_at\n\t\t\t  FROM users WHERE username = $1`\n\n\tuser := \u0026domain.User{}\n\terr := r.db.QueryRow(ctx, query, username).Scan(\n\t\t\u0026user.ID,\n\t\t\u0026user.Username,\n\t\t\u0026user.PasswordHash,\n\t\t\u0026user.ProfilePicURL,\n\t\t\u0026user.CreatedAt,\n\t\t\u0026user.UpdatedAt,\n\t)\n\tif err != nil {\n\t\tif errors.Is(err, pgx.ErrNoRows) {\n\t\t\treturn nil, nil // Not found is not an error here\n\t\t}\n\t\treturn nil, err\n\t}\n\treturn user, nil\n}\n\nfunc (r *postgresUserRepository) GetByID(ctx context.Context, id string) (*domain.User, error) {\n\tquery := `SELECT id, username, password_hash, profile_pic_url, created_at, updated_at\n\t\t\t  FROM users WHERE id = $1`\n\n\tuser := \u0026domain.User{}\n\terr := r.db.QueryRow(ctx, query, id).Scan(\n\t\t\u0026user.ID,\n\t\t\u0026user.Username,\n\t\t\u0026user.PasswordHash,\n\t\t\u0026user.ProfilePicURL,\n\t\t\u0026user.CreatedAt,\n\t\t\u0026user.UpdatedAt,\n\t)\n\tif err != nil {\n\t\tif errors.Is(err, pgx.ErrNoRows) {\n\t\t\treturn nil, nil // Not found is not an error here\n\t\t}\n\t\treturn nil, err\n\t}\n\treturn user, nil\n}\n",
  "backend/internal/delivery/http/handler/auth_handler.go": "package handler\n\nimport (\n\t\"encoding/json\"\n\t\"errors\"\n\t\"net/http\"\n\n\t\"chat-app/internal/service\"\n\t\"chat-app/internal/usecase\"\n)\n\ntype AuthHandler struct {\n\tauthUsecase usecase.AuthUsecase\n}\n\nfunc NewAuthHandler(authUsecase usecase.AuthUsecase) *AuthHandler {\n\treturn \u0026AuthHandler{authUsecase: authUsecase}\n}\n\nfunc (h *AuthHandler) SignUp(w http.ResponseWriter, r *http.Request) {\n\tvar input usecase.SignUpInput\n\tif err := json.NewDecoder(r.Body).Decode(\u0026input); err != nil {\n\t\thttp.Error(w, \"Invalid request body\", http.StatusBadRequest)\n\t\treturn\n\t}\n\n\tuser, err := h.authUsecase.SignUp(r.Context(), input)\n\tif err != nil {\n\t\thandleAuthError(w, err)\n\t\treturn\n\t}\n\n\t// Don't return password hash\n\tuser.PasswordHash = \"\"\n\n\tw.Header().Set(\"Content-Type\", \"application/json\")\n\tw.WriteHeader(http.StatusCreated)\n\tjson.NewEncoder(w).Encode(user)\n}\n\nfunc (h *AuthHandler) Login(w http.ResponseWriter, r *http.Request) {\n\tvar input usecase.LoginInput\n\tif err := json.NewDecoder(r.Body).Decode(\u0026input); err != nil {\n\t\thttp.Error(w, \"Invalid request body\", http.StatusBadRequest)\n\t\treturn\n\t}\n\n\ttokens, err := h.authUsecase.Login(r.Context(), input)\n\tif err != nil {\n\t\thandleAuthError(w, err)\n\t\treturn\n\t}\n\n\tw.Header().Set(\"Content-Type\", \"application/json\")\n\tjson.NewEncoder(w).Encode(tokens)\n}\n\nfunc (h *AuthHandler) Refresh(w http.ResponseWriter, r *http.Request) {\n\tvar body struct {\n\t\tRefreshToken string `json:\"refresh_token\"`\n\t}\n\tif err := json.NewDecoder(r.Body).Decode(\u0026body); err != nil {\n\t\thttp.Error(w, \"Invalid request body\", http.StatusBadRequest)\n\t\treturn\n\t}\n\n\ttokens, err := h.authUsecase.Refresh(r.Context(), body.RefreshToken)\n\tif err != nil {\n\t\thandleAuthError(w, err)\n\t\treturn\n\t}\n\n\tw.Header().Set(\"Content-Type\", \"application/json\")\n\tjson.NewEncoder(w).Encode(tokens)\n}\n\nfunc (h *AuthHandler) Logout(w http.ResponseWriter, r *http.Request) {\n\tvar body struct {\n\t\tRefreshToken string `json:\"refresh_token\"`\n\t}\n\tif err := json.NewDecoder(r.Body).Decode(\u0026body); err != nil {\n\t\thttp.Error(w, \"Invalid request body\", http.StatusBadRequest)\n\t\treturn\n\t}\n\n\terr := h.authUsecase.Logout(r.Context(), body.RefreshToken)\n\tif err != nil {\n\t\thandleAuthError(w, err)\n\t\treturn\n\t}\n\n\tw.WriteHeader(http.StatusNoContent)\n}\n\nfunc handleAuthError(w http.ResponseWriter, err error) {\n\tswitch {\n\tcase errors.Is(err, service.ErrUserExists),\n\t\terrors.Is(err, service.ErrInvalidUsername),\n\t\terrors.Is(err, service.ErrInvalidPassword):\n\t\thttp.Error(w, err.Error(), http.StatusBadRequest)\n\tcase errors.Is(err, service.ErrInvalidCredentials),\n\t\terrors.Is(err, service.ErrSessionNotFound),\n\t\terrors.Is(err, service.ErrSessionExpired):\n\t\thttp.Error(w, err.Error(), http.StatusUnauthorized)\n\tdefault:\n\t\thttp.Error(w, \"Internal server error\", http.StatusInternalServerError)\n\t}\n}\n",
  "backend/internal/delivery/http/middleware/auth_middleware.go": "package middleware\n\nimport (\n\t\"context\"\n\t\"net/http\"\n\t\"strings\"\n\n\t\"chat-app/pkg/config\"\n\t\"chat-app/pkg/util\"\n)\n\ntype contextKey string\n\nconst UserIDContextKey = contextKey(\"userID\")\n\nfunc AuthMiddleware(cfg *config.Config) func(next http.Handler) http.Handler {\n\treturn func(next http.Handler) http.Handler {\n\t\treturn http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\t\tauthHeader := r.Header.Get(\"Authorization\")\n\t\t\tif authHeader == \"\" {\n\t\t\t\thttp.Error(w, \"Authorization header required\", http.StatusUnauthorized)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tparts := strings.Split(authHeader, \" \")\n\t\t\tif len(parts) != 2 || parts[0] != \"Bearer\" {\n\t\t\t\thttp.Error(w, \"Invalid authorization header format\", http.StatusUnauthorized)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\ttokenString := parts[1]\n\t\t\tclaims, err := util.ValidateToken(tokenString, cfg.JWTSecret)\n\t\t\tif err != nil {\n\t\t\t\thttp.Error(w, \"Invalid token\", http.StatusUnauthorized)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tctx := context.WithValue(r.Context(), UserIDContextKey, claims.UserID)\n\t\t\tnext.ServeHTTP(w, r.WithContext(ctx))\n\t\t})\n\t}\n}\n",
  "backend/internal/delivery/http/router.go": "package http\n\nimport (\n\t\"net/http\"\n\n\t\"chat-app/internal/delivery/http/handler\"\n\t\"chat-app/internal/usecase\"\n\n\t\"github.com/go-chi/chi/v5\"\n\t\"github.com/go-chi/chi/v5/middleware\"\n)\n\nfunc NewRouter(authUsecase usecase.AuthUsecase) http.Handler {\n\tr := chi.NewRouter()\n\n\tr.Use(middleware.Logger)\n\tr.Use(middleware.Recoverer)\n\tr.Use(middleware.Heartbeat(\"/healthz\"))\n\n\tauthHandler := handler.NewAuthHandler(authUsecase)\n\n\tr.Route(\"/api/v1/auth\", func(r chi.Router) {\n\t\tr.Post(\"/signup\", authHandler.SignUp)\n\t\tr.Post(\"/login\", authHandler.Login)\n\t\tr.Post(\"/refresh\", authHandler.Refresh)\n\t\tr.Post(\"/logout\", authHandler.Logout)\n\t})\n\n\treturn r\n}\n",
  "backend/internal/domain/session.go": "package domain\n\nimport \"time\"\n\ntype Session struct {\n\tID        string    `json:\"id\"` // This is the Refresh Token\n\tUserID    string    `json:\"user_id\"`\n\tExpiresAt time.Time `json:\"expires_at\"`\n\tCreatedAt time.Time `json:\"created_at\"`\n}\n",
  "backend/internal/domain/user.go": "package domain\n\nimport \"time\"\n\ntype User struct {\n\tID            string    `json:\"id\"`\n\tUsername      string    `json:\"username\"`\n\tPasswordHash  string    `json:\"-\"` // Do not expose password hash\n\tProfilePicURL string    `json:\"profile_pic_url\"`\n\tCreatedAt     time.Time `json:\"created_at\"`\n\tUpdatedAt     time.Time `json:\"updated_at\"`\n}\n",
  "backend/internal/repository/session_repo.go": "package repository\n\nimport (\n\t\"context\"\n\t\"chat-app/internal/domain\"\n)\n\ntype SessionRepository interface {\n\tStore(ctx context.Context, session *domain.Session) error\n\tGetByID(ctx context.Context, id string) (*domain.Session, error)\n\tDelete(ctx context.Context, id string) error\n\tDeleteAllForUser(ctx context.Context, userID string) error\n}\n",
  "backend/internal/repository/user_repo.go": "package repository\n\nimport (\n\t\"context\"\n\t\"chat-app/internal/domain\"\n)\n\ntype UserRepository interface {\n\tCreate(ctx context.Context, user *domain.User) error\n\tGetByUsername(ctx context.Context, username string) (*domain.User, error)\n\tGetByID(ctx context.Context, id string) (*domain.User, error)\n}\n",
  "backend/internal/service/auth_service.go": "package service\n\nimport (\n\t\"context\"\n\t\"errors\"\n\t\"regexp\"\n\t\"strings\"\n\t\"time\"\n\n\t\"chat-app/internal/domain\"\n\t\"chat-app/internal/repository\"\n\t\"chat-app/internal/usecase\"\n\t\"chat-app/pkg/config\"\n\t\"chat-app/pkg/util\"\n)\n\nvar (\n\tErrUserExists         = errors.New(\"user with this username already exists\")\n\tErrUserNotFound       = errors.New(\"user not found\")\n\tErrInvalidCredentials = errors.New(\"invalid username or password\")\n\tErrInvalidUsername    = errors.New(\"username format is invalid\")\n\tErrInvalidPassword    = errors.New(\"password is too short\")\n\tErrSessionNotFound    = errors.New(\"session not found or expired\")\n\tErrSessionExpired     = errors.New(\"session has expired\")\n)\n\ntype authService struct {\n\tuserRepo    repository.UserRepository\n\tsessionRepo repository.SessionRepository\n\tcfg         *config.Config\n}\n\nfunc NewAuthService(userRepo repository.UserRepository, sessionRepo repository.SessionRepository, cfg *config.Config) usecase.AuthUsecase {\n\treturn \u0026authService{\n\t\tuserRepo:    userRepo,\n\t\tsessionRepo: sessionRepo,\n\t\tcfg:         cfg,\n\t}\n}\n\nfunc (s *authService) SignUp(ctx context.Context, input usecase.SignUpInput) (*domain.User, error) {\n\t// Validate username\n\tif err := validateUsername(input.Username); err != nil {\n\t\treturn nil, err\n\t}\n\t// Validate password\n\tif len(input.Password) \u003c 8 {\n\t\treturn nil, ErrInvalidPassword\n\t}\n\n\t// Check if user exists\n\texistingUser, err := s.userRepo.GetByUsername(ctx, input.Username)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif existingUser != nil {\n\t\treturn nil, ErrUserExists\n\t}\n\n\t// Hash password\n\thashedPassword, err := util.HashPassword(input.Password)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Create user\n\tuser := \u0026domain.User{\n\t\tID:           util.NewUUID(),\n\t\tUsername:     strings.ToLower(input.Username),\n\t\tPasswordHash: hashedPassword,\n\t}\n\n\tif err := s.userRepo.Create(ctx, user); err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn user, nil\n}\n\nfunc (s *authService) Login(ctx context.Context, input usecase.LoginInput) (*usecase.AuthTokens, error) {\n\tuser, err := s.userRepo.GetByUsername(ctx, input.Username)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif user == nil {\n\t\treturn nil, ErrInvalidCredentials\n\t}\n\n\tif !util.CheckPasswordHash(input.Password, user.PasswordHash) {\n\t\treturn nil, ErrInvalidCredentials\n\t}\n\n\t// Single device policy: remove all old sessions\n\tif err := s.sessionRepo.DeleteAllForUser(ctx, user.ID); err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn s.createSession(ctx, user.ID)\n}\n\nfunc (s *authService) Refresh(ctx context.Context, refreshToken string) (*usecase.AuthTokens, error) {\n\tsession, err := s.sessionRepo.GetByID(ctx, refreshToken)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif session == nil {\n\t\treturn nil, ErrSessionNotFound\n\t}\n\n\tif session.ExpiresAt.Before(time.Now()) {\n\t\t// Clean up expired session\n\t\t_ = s.sessionRepo.Delete(ctx, session.ID)\n\t\treturn nil, ErrSessionExpired\n\t}\n\n\t// Sliding window: delete old session and create a new one\n\tif err := s.sessionRepo.Delete(ctx, session.ID); err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn s.createSession(ctx, session.UserID)\n}\n\nfunc (s *authService) Logout(ctx context.Context, refreshToken string) error {\n\treturn s.sessionRepo.Delete(ctx, refreshToken)\n}\n\nfunc (s *authService) createSession(ctx context.Context, userID string) (*usecase.AuthTokens, error) {\n\taccessToken, err := util.GenerateAccessToken(userID, s.cfg.JWTSecret, s.cfg.AccessTokenTTL)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tsession := \u0026domain.Session{\n\t\tID:        util.NewUUID(), // This is the refresh token\n\t\tUserID:    userID,\n\t\tExpiresAt: time.Now().Add(s.cfg.RefreshTokenTTL),\n\t}\n\n\tif err := s.sessionRepo.Store(ctx, session); err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn \u0026usecase.AuthTokens{\n\t\tAccessToken:  accessToken,\n\t\tRefreshToken: session.ID,\n\t}, nil\n}\n\nfunc validateUsername(username string) error {\n\tif len(username) \u003c 4 || len(username) \u003e 50 {\n\t\treturn ErrInvalidUsername\n\t}\n\t// Allowed characters: lowercase letters (a-z), digits (0-9), and underscore (_)\n\tmatch, _ := regexp.MatchString(\"^[a-z0-9_]+$\", username)\n\tif !match {\n\t\treturn ErrInvalidUsername\n\t}\n\treturn nil\n}\n",
  "backend/internal/usecase/auth_ucase.go": "package usecase\n\nimport (\n\t\"context\"\n\t\"chat-app/internal/domain\"\n)\n\ntype SignUpInput struct {\n\tUsername string `json:\"username\"`\n\tPassword string `json:\"password\"`\n}\n\ntype LoginInput struct {\n\tUsername string `json:\"username\"`\n\tPassword string `json:\"password\"`\n}\n\ntype AuthTokens struct {\n\tAccessToken  string `json:\"access_token\"`\n\tRefreshToken string `json:\"refresh_token\"`\n}\n\ntype AuthUsecase interface {\n\tSignUp(ctx context.Context, input SignUpInput) (*domain.User, error)\n\tLogin(ctx context.Context, input LoginInput) (*AuthTokens, error)\n\tRefresh(ctx context.Context, refreshToken string) (*AuthTokens, error)\n\tLogout(ctx context.Context, refreshToken string) error\n}\n",
  "backend/migrations/000001_create_users_table.up.sql": "CREATE EXTENSION IF NOT EXISTS \"uuid-ossp\";\nCREATE EXTENSION IF NOT EXISTS \"citext\";\n\nCREATE TABLE IF NOT EXISTS users (\n    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),\n    username CITEXT NOT NULL UNIQUE,\n    password_hash VARCHAR(255) NOT NULL,\n    profile_pic_url VARCHAR(255) DEFAULT '',\n    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),\n    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()\n);\n\nCREATE INDEX IF NOT EXISTS users_username_idx ON users(username);\n",
  "backend/migrations/000002_create_sessions_table.up.sql": "CREATE TABLE IF NOT EXISTS sessions (\n    id UUID PRIMARY KEY,\n    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,\n    expires_at TIMESTAMPTZ NOT NULL,\n    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()\n);\n\nCREATE INDEX IF NOT EXISTS sessions_user_id_idx ON sessions(user_id);\n",
  "backend/pkg/config/config.go": "package config\n\nimport (\n\t\"log\"\n\t\"os\"\n\t\"time\"\n\n\t\"github.com/joho/godotenv\"\n)\n\ntype Config struct {\n\tPort            string\n\tDatabaseURL     string\n\tRedisURL        string\n\tJWTSecret       string\n\tAccessTokenTTL  time.Duration\n\tRefreshTokenTTL time.Duration\n}\n\nfunc Load() *Config {\n\tif err := godotenv.Load(); err != nil {\n\t\tlog.Println(\"No .env file found, using environment variables\")\n\t}\n\n\treturn \u0026Config{\n\t\tPort:            getEnv(\"PORT\", \"8080\"),\n\t\tDatabaseURL:     getEnv(\"DATABASE_URL\", \"postgres://user:password@localhost:5432/chatdb?sslmode=disable\"),\n\t\tRedisURL:        getEnv(\"REDIS_URL\", \"redis://localhost:6379/0\"),\n\t\tJWTSecret:       getEnv(\"JWT_SECRET\", \"a-very-secret-key\"),\n\t\tAccessTokenTTL:  10 * time.Minute,\n\t\tRefreshTokenTTL: 8 * time.Hour,\n\t}\n}\n\nfunc getEnv(key, fallback string) string {\n\tif value, ok := os.LookupEnv(key); ok {\n\t\treturn value\n\t}\n\treturn fallback\n}\n",
  "backend/pkg/util/hash.go": "package util\n\nimport \"golang.org/x/crypto/bcrypt\"\n\nfunc HashPassword(password string) (string, error) {\n\tbytes, err := bcrypt.GenerateFromPassword([]byte(password), bcrypt.DefaultCost)\n\treturn string(bytes), err\n}\n\nfunc CheckPasswordHash(password, hash string) bool {\n\terr := bcrypt.CompareHashAndPassword([]byte(hash), []byte(password))\n\treturn err == nil\n}\n",
  "backend/pkg/util/jwt.go": "package util\n\nimport (\n\t\"fmt\"\n\t\"time\"\n\n\t\"github.com/golang-jwt/jwt/v5\"\n)\n\ntype Claims struct {\n\tUserID string `json:\"user_id\"`\n\tjwt.RegisteredClaims\n}\n\nfunc GenerateAccessToken(userID, secret string, ttl time.Duration) (string, error) {\n\tclaims := \u0026Claims{\n\t\tUserID: userID,\n\t\tRegisteredClaims: jwt.RegisteredClaims{\n\t\t\tExpiresAt: jwt.NewNumericDate(time.Now().Add(ttl)),\n\t\t\tIssuedAt:  jwt.NewNumericDate(time.Now()),\n\t\t},\n\t}\n\n\ttoken := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)\n\treturn token.SignedString([]byte(secret))\n}\n\nfunc ValidateToken(tokenString, secret string) (*Claims, error) {\n\ttoken, err := jwt.ParseWithClaims(tokenString, \u0026Claims{}, func(token *jwt.Token) (interface{}, error) {\n\t\tif _, ok := token.Method.(*jwt.SigningMethodHMAC); !ok {\n\t\t\treturn nil, fmt.Errorf(\"unexpected signing method: %v\", token.Header[\"alg\"])\n\t\t}\n\t\treturn []byte(secret), nil\n\t})\n\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tif claims, ok := token.Claims.(*Claims); ok \u0026\u0026 token.Valid {\n\t\treturn claims, nil\n\t}\n\n\treturn nil, fmt.Errorf(\"invalid token\")\n}\n",
  "backend/pkg/util/uuid.go": "package util\n\nimport \"github.com/google/uuid\"\n\nfunc NewUUID() string {\n\treturn uuid.New().String()\n}\n\nfunc ParseUUID(s string) (uuid.UUID, error) {\n\treturn uuid.Parse(s)\n}\n```",
  "docker-compose.yml": "version: '3.8'\n\nservices:\n  postgres:\n    image: postgres:13\n    restart: always\n    environment:\n      POSTGRES_USER: user\n      POSTGRES_PASSWORD: password\n      POSTGRES_DB: chatdb\n    ports:\n      - \"5432:5432\"  # Expose Postgres port to host\n    volumes:\n      - postgres_data:/var/lib/postgresql/data\n\n  redis:\n    image: redis:6-alpine\n    restart: always\n    ports:\n      - \"6379:6379\"  # Expose Redis port to host\n    volumes:\n      - redis_data:/data\n\nvolumes:\n  postgres_data:\n  redis_data:\n"
}