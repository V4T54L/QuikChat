{
  ".env.example": "# Server\nSERVER_PORT=8080\n\n# Database\nDB_HOST=localhost\nDB_PORT=5432\nDB_USER=user\nDB_PASSWORD=password\nDB_NAME=quikchat\nDB_SSLMODE=disable\n\n# Redis\nREDIS_ADDR=localhost:6379\n\n# JWT\nJWT_SECRET=a_very_secret_key\nJWT_ACCESS_TOKEN_EXP_MIN=10\nJWT_REFRESH_TOKEN_EXP_HOUR=8\n\n# File Storage\nPROFILE_PIC_DIR=./uploads/profile_pics\nSTATIC_FILES_DIR=./web/static\nPROFILE_PIC_ROUTE=/static/profile_pics/\n",
  "Makefile": ".PHONY: run docker-up docker-down\n\nrun:\n\t@echo \"Starting application...\"\n\t@go run ./backend/cmd/server/main.go\n\ndocker-up:\n\t@echo \"Starting Docker containers...\"\n\t@docker-compose up -d\n\ndocker-down:\n\t@echo \"Stopping Docker containers...\"\n\t@docker-compose down\n",
  "backend/adapter/filesystem/local_storage.go": "package filesystem\n\nimport (\n\t\"chat-app/backend/repository\"\n\t\"fmt\"\n\t\"io\"\n\t\"mime/multipart\"\n\t\"os\"\n\t\"path/filepath\"\n\n\t\"github.com/google/uuid\"\n)\n\ntype localStorage struct {\n\tstorageDir string\n\troutePath  string\n}\n\nfunc NewLocalStorage(storageDir, routePath string) repository.FileRepository {\n\treturn \u0026localStorage{\n\t\tstorageDir: storageDir,\n\t\troutePath:  routePath,\n\t}\n}\n\nfunc (l *localStorage) Save(file multipart.File, header *multipart.FileHeader) (string, error) {\n\tdefer file.Close()\n\n\text := filepath.Ext(header.Filename)\n\trandomFilename := fmt.Sprintf(\"%s%s\", uuid.New().String(), ext)\n\tfilePath := filepath.Join(l.storageDir, randomFilename)\n\n\tdst, err := os.Create(filePath)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\tdefer dst.Close()\n\n\tif _, err := io.Copy(dst, file); err != nil {\n\t\treturn \"\", err\n\t}\n\n\tfileURL := filepath.Join(l.routePath, randomFilename)\n\treturn fileURL, nil\n}\n",
  "backend/adapter/handler/http/auth_handler.go": "package http\n\nimport (\n\t\"chat-app/backend/adapter/util\"\n\t\"chat-app/backend/models\"\n\t\"encoding/json\"\n\t\"errors\"\n\t\"net/http\"\n)\n\ntype loginRequest struct {\n\tUsername string `json:\"username\"`\n\tPassword string `json:\"password\"`\n}\n\ntype loginResponse struct {\n\tAccessToken  string `json:\"accessToken\"`\n\tRefreshToken string `json:\"refreshToken\"`\n}\n\nfunc (h *AuthHandler) Login(w http.ResponseWriter, r *http.Request) {\n\tvar req loginRequest\n\tif err := json.NewDecoder(r.Body).Decode(\u0026req); err != nil {\n\t\tutil.RespondWithError(w, http.StatusBadRequest, \"Invalid request payload\")\n\t\treturn\n\t}\n\n\taccessToken, refreshToken, err := h.authUsecase.Login(r.Context(), req.Username, req.Password)\n\tif err != nil {\n\t\tif errors.Is(err, models.ErrInvalidCredentials) {\n\t\t\tutil.RespondWithError(w, http.StatusUnauthorized, err.Error())\n\t\t\treturn\n\t\t}\n\t\tutil.RespondWithError(w, http.StatusInternalServerError, \"Failed to login\")\n\t\treturn\n\t}\n\n\tutil.RespondWithJSON(w, http.StatusOK, loginResponse{\n\t\tAccessToken:  accessToken,\n\t\tRefreshToken: refreshToken,\n\t})\n}\n\ntype refreshRequest struct {\n\tRefreshToken string `json:\"refreshToken\"`\n}\n\ntype refreshResponse struct {\n\tAccessToken string `json:\"accessToken\"`\n}\n\nfunc (h *AuthHandler) Refresh(w http.ResponseWriter, r *http.Request) {\n\tvar req refreshRequest\n\tif err := json.NewDecoder(r.Body).Decode(\u0026req); err != nil {\n\t\tutil.RespondWithError(w, http.StatusBadRequest, \"Invalid request payload\")\n\t\treturn\n\t}\n\n\tnewAccessToken, err := h.authUsecase.Refresh(r.Context(), req.RefreshToken)\n\tif err != nil {\n\t\tif errors.Is(err, models.ErrSessionNotFound) || errors.Is(err, models.ErrInvalidToken) {\n\t\t\tutil.RespondWithError(w, http.StatusUnauthorized, err.Error())\n\t\t\treturn\n\t\t}\n\t\tutil.RespondWithError(w, http.StatusInternalServerError, \"Failed to refresh token\")\n\t\treturn\n\t}\n\n\tutil.RespondWithJSON(w, http.StatusOK, refreshResponse{AccessToken: newAccessToken})\n}\n\ntype logoutRequest struct {\n\tRefreshToken string `json:\"refreshToken\"`\n}\n\nfunc (h *AuthHandler) Logout(w http.ResponseWriter, r *http.Request) {\n\tvar req logoutRequest\n\tif err := json.NewDecoder(r.Body).Decode(\u0026req); err != nil {\n\t\tutil.RespondWithError(w, http.StatusBadRequest, \"Invalid request payload\")\n\t\treturn\n\t}\n\n\tif err := h.authUsecase.Logout(r.Context(), req.RefreshToken); err != nil {\n\t\t// We can choose to not return an error to the client for logout failures\n\t\t// for security reasons, but for simplicity we will.\n\t\tutil.RespondWithError(w, http.StatusInternalServerError, \"Failed to logout\")\n\t\treturn\n\t}\n\n\tutil.RespondWithJSON(w, http.StatusOK, map[string]string{\"message\": \"Logged out successfully\"})\n}\n",
  "backend/adapter/handler/http/handler.go": "package http\n\nimport (\n\t\"chat-app/backend/usecase\"\n)\n\ntype AuthHandler struct {\n\tauthUsecase usecase.AuthUsecase\n}\n\nfunc NewAuthHandler(authUsecase usecase.AuthUsecase) *AuthHandler {\n\treturn \u0026AuthHandler{authUsecase: authUsecase}\n}\n\ntype UserHandler struct {\n\tuserUsecase usecase.UserUsecase\n}\n\nfunc NewUserHandler(userUsecase usecase.UserUsecase) *UserHandler {\n\treturn \u0026UserHandler{userUsecase: userUsecase}\n}\n",
  "backend/adapter/handler/http/user_handler.go": "package http\n\nimport (\n\t\"chat-app/backend/adapter/middleware\"\n\t\"chat-app/backend/adapter/util\"\n\t\"chat-app/backend/models\"\n\t\"encoding/json\"\n\t\"errors\"\n\t\"net/http\"\n\n\t\"github.com/go-chi/chi/v5\"\n\t\"github.com/google/uuid\"\n)\n\ntype registerRequest struct {\n\tUsername string `json:\"username\"`\n\tPassword string `json:\"password\"`\n}\n\nfunc (h *UserHandler) Register(w http.ResponseWriter, r *http.Request) {\n\tvar req registerRequest\n\tif err := json.NewDecoder(r.Body).Decode(\u0026req); err != nil {\n\t\tutil.RespondWithError(w, http.StatusBadRequest, \"Invalid request payload\")\n\t\treturn\n\t}\n\n\tuser, err := h.userUsecase.Register(r.Context(), req.Username, req.Password)\n\tif err != nil {\n\t\tif errors.Is(err, models.ErrUsernameTaken) || err.Error() == \"invalid username format\" || err.Error() == \"password is too short\" {\n\t\t\tutil.RespondWithError(w, http.StatusBadRequest, err.Error())\n\t\t\treturn\n\t\t}\n\t\tutil.RespondWithError(w, http.StatusInternalServerError, \"Failed to register user\")\n\t\treturn\n\t}\n\n\tutil.RespondWithJSON(w, http.StatusCreated, user)\n}\n\nfunc (h *UserHandler) GetUserByUsername(w http.ResponseWriter, r *http.Request) {\n\tusername := chi.URLParam(r, \"username\")\n\tif username == \"\" {\n\t\tutil.RespondWithError(w, http.StatusBadRequest, \"Username is required\")\n\t\treturn\n\t}\n\n\tuser, err := h.userUsecase.GetByUsername(r.Context(), username)\n\tif err != nil {\n\t\tif errors.Is(err, models.ErrUserNotFound) {\n\t\t\tutil.RespondWithError(w, http.StatusNotFound, err.Error())\n\t\t\treturn\n\t\t}\n\t\tutil.RespondWithError(w, http.StatusInternalServerError, \"Failed to get user\")\n\t\treturn\n\t}\n\n\tutil.RespondWithJSON(w, http.StatusOK, user)\n}\n\nfunc (h *UserHandler) UpdateProfile(w http.ResponseWriter, r *http.Request) {\n\tuserID, ok := r.Context().Value(middleware.UserIDKey).(uuid.UUID)\n\tif !ok {\n\t\tutil.RespondWithError(w, http.StatusUnauthorized, \"Unauthorized\")\n\t\treturn\n\t}\n\n\tif err := r.ParseMultipartForm(32 \u003c\u003c 20); err != nil { // 32MB max memory\n\t\tutil.RespondWithError(w, http.StatusBadRequest, \"Failed to parse multipart form\")\n\t\treturn\n\t}\n\n\tvar username, password *string\n\tif val := r.FormValue(\"username\"); val != \"\" {\n\t\tusername = \u0026val\n\t}\n\tif val := r.FormValue(\"password\"); val != \"\" {\n\t\tpassword = \u0026val\n\t}\n\n\tfile, header, err := r.FormFile(\"profilePic\")\n\tif err != nil \u0026\u0026 !errors.Is(err, http.ErrMissingFile) {\n\t\tutil.RespondWithError(w, http.StatusBadRequest, \"Invalid file upload\")\n\t\treturn\n\t}\n\tif file != nil {\n\t\tdefer file.Close()\n\t}\n\n\tuser, err := h.userUsecase.UpdateProfile(r.Context(), userID, username, password, file, header)\n\tif err != nil {\n\t\tif errors.Is(err, models.ErrUserNotFound) {\n\t\t\tutil.RespondWithError(w, http.StatusNotFound, err.Error())\n\t\t\treturn\n\t\t}\n\t\tif errors.Is(err, models.ErrUsernameTaken) {\n\t\t\tutil.RespondWithError(w, http.StatusConflict, err.Error())\n\t\t\treturn\n\t\t}\n\t\t// Check for validation errors\n\t\tif err.Error() == \"invalid username format\" || err.Error() == \"password is too short\" || err.Error() == \"file size exceeds 200KB\" || err.Error() == \"invalid file type\" {\n\t\t\tutil.RespondWithError(w, http.StatusBadRequest, err.Error())\n\t\t\treturn\n\t\t}\n\t\tutil.RespondWithError(w, http.StatusInternalServerError, \"Failed to update profile\")\n\t\treturn\n\t}\n\n\tutil.RespondWithJSON(w, http.StatusOK, user)\n}\n",
  "backend/adapter/middleware/auth.go": "package middleware\n\nimport (\n\t\"chat-app/backend/adapter/util\"\n\t\"context\"\n\t\"net/http\"\n\t\"strings\"\n\n\t\"github.com/golang-jwt/jwt/v5\"\n\t\"github.com/google/uuid\"\n)\n\ntype contextKey string\n\nconst UserIDKey contextKey = \"userID\"\n\ntype AuthMiddleware struct {\n\tjwtSecret string\n}\n\nfunc NewAuthMiddleware(jwtSecret string) *AuthMiddleware {\n\treturn \u0026AuthMiddleware{jwtSecret: jwtSecret}\n}\n\nfunc (m *AuthMiddleware) Validate(next http.Handler) http.Handler {\n\treturn http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\tauthHeader := r.Header.Get(\"Authorization\")\n\t\tif authHeader == \"\" {\n\t\t\tutil.RespondWithError(w, http.StatusUnauthorized, \"Authorization header required\")\n\t\t\treturn\n\t\t}\n\n\t\ttokenString := strings.TrimPrefix(authHeader, \"Bearer \")\n\t\tif tokenString == authHeader {\n\t\t\tutil.RespondWithError(w, http.StatusUnauthorized, \"Bearer token required\")\n\t\t\treturn\n\t\t}\n\n\t\ttoken, err := jwt.Parse(tokenString, func(token *jwt.Token) (interface{}, error) {\n\t\t\tif _, ok := token.Method.(*jwt.SigningMethodHMAC); !ok {\n\t\t\t\treturn nil, jwt.ErrSignatureInvalid\n\t\t\t}\n\t\t\treturn []byte(m.jwtSecret), nil\n\t\t})\n\n\t\tif err != nil || !token.Valid {\n\t\t\tutil.RespondWithError(w, http.StatusUnauthorized, \"Invalid or expired token\")\n\t\t\treturn\n\t\t}\n\n\t\tclaims, ok := token.Claims.(jwt.MapClaims)\n\t\tif !ok {\n\t\t\tutil.RespondWithError(w, http.StatusUnauthorized, \"Invalid token claims\")\n\t\t\treturn\n\t\t}\n\n\t\tuserIDStr, ok := claims[\"user_id\"].(string)\n\t\tif !ok {\n\t\t\tutil.RespondWithError(w, http.StatusUnauthorized, \"Invalid user ID in token\")\n\t\t\treturn\n\t\t}\n\n\t\tuserID, err := uuid.Parse(userIDStr)\n\t\tif err != nil {\n\t\t\tutil.RespondWithError(w, http.StatusUnauthorized, \"Invalid user ID format in token\")\n\t\t\treturn\n\t\t}\n\n\t\tctx := context.WithValue(r.Context(), UserIDKey, userID)\n\t\tnext.ServeHTTP(w, r.WithContext(ctx))\n\t})\n}\n",
  "backend/adapter/middleware/logging.go": "package middleware\n\nimport (\n\t\"log\"\n\t\"net/http\"\n\t\"time\"\n)\n\nfunc Logging(next http.Handler) http.Handler {\n\treturn http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\tstart := time.Now()\n\t\tnext.ServeHTTP(w, r)\n\t\tlog.Printf(\"%s %s %s\", r.Method, r.RequestURI, time.Since(start))\n\t})\n}\n",
  "backend/adapter/postgres/db.go": "package postgres\n\nimport (\n\t\"chat-app/backend/config\"\n\t\"database/sql\"\n\t\"fmt\"\n\n\t_ \"github.com/lib/pq\"\n)\n\nfunc NewDB(cfg *config.Config) (*sql.DB, error) {\n\tconnStr := fmt.Sprintf(\"host=%s port=%s user=%s password=%s dbname=%s sslmode=%s\",\n\t\tcfg.DBHost, cfg.DBPort, cfg.DBUser, cfg.DBPassword, cfg.DBName, cfg.DBSslMode)\n\n\tdb, err := sql.Open(\"postgres\", connStr)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tif err := db.Ping(); err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn db, nil\n}\n",
  "backend/adapter/postgres/migrations/000001_init.sql": "CREATE EXTENSION IF NOT EXISTS \"uuid-ossp\";\n\nCREATE TABLE users (\n    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),\n    username VARCHAR(50) UNIQUE NOT NULL,\n    password_hash VARCHAR(255) NOT NULL,\n    profile_pic_url VARCHAR(255) DEFAULT '',\n    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()\n);\n\nCREATE INDEX idx_users_username ON users (LOWER(username));\n\nCREATE TABLE sessions (\n    refresh_token UUID PRIMARY KEY,\n    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,\n    expires_at TIMESTAMPTZ NOT NULL\n);\n\nCREATE INDEX idx_sessions_user_id ON sessions (user_id);\n",
  "backend/adapter/postgres/session_repo.go": "package postgres\n\nimport (\n\t\"chat-app/backend/models\"\n\t\"chat-app/backend/repository\"\n\t\"context\"\n\t\"database/sql\"\n\t\"errors\"\n\n\t\"github.com/google/uuid\"\n)\n\ntype postgresSessionRepository struct {\n\tdb *sql.DB\n}\n\nfunc NewPostgresSessionRepository(db *sql.DB) repository.SessionRepository {\n\treturn \u0026postgresSessionRepository{db: db}\n}\n\nfunc (r *postgresSessionRepository) Create(ctx context.Context, session *models.Session) error {\n\tquery := `\n        INSERT INTO sessions (refresh_token, user_id, expires_at)\n        VALUES ($1, $2, $3)\n        ON CONFLICT (refresh_token) DO UPDATE SET\n        expires_at = EXCLUDED.expires_at`\n\t_, err := r.db.ExecContext(ctx, query, session.RefreshToken, session.UserID, session.ExpiresAt)\n\treturn err\n}\n\nfunc (r *postgresSessionRepository) Find(ctx context.Context, refreshToken uuid.UUID) (*models.Session, error) {\n\tquery := `SELECT refresh_token, user_id, expires_at FROM sessions WHERE refresh_token = $1`\n\tsession := \u0026models.Session{}\n\terr := r.db.QueryRowContext(ctx, query, refreshToken).Scan(\u0026session.RefreshToken, \u0026session.UserID, \u0026session.ExpiresAt)\n\tif err != nil {\n\t\tif errors.Is(err, sql.ErrNoRows) {\n\t\t\treturn nil, models.ErrSessionNotFound\n\t\t}\n\t\treturn nil, err\n\t}\n\treturn session, nil\n}\n\nfunc (r *postgresSessionRepository) Delete(ctx context.Context, refreshToken uuid.UUID) error {\n\tquery := `DELETE FROM sessions WHERE refresh_token = $1`\n\t_, err := r.db.ExecContext(ctx, query, refreshToken)\n\treturn err\n}\n\nfunc (r *postgresSessionRepository) DeleteByUserID(ctx context.Context, userID uuid.UUID) error {\n\tquery := `DELETE FROM sessions WHERE user_id = $1`\n\t_, err := r.db.ExecContext(ctx, query, userID)\n\treturn err\n}",
  "backend/adapter/postgres/user_repo.go": "package postgres\n\nimport (\n\t\"chat-app/backend/models\"\n\t\"chat-app/backend/repository\"\n\t\"context\"\n\t\"database/sql\"\n\t\"errors\"\n\t\"strings\"\n\n\t\"github.com/google/uuid\"\n\t\"github.com/lib/pq\"\n)\n\ntype postgresUserRepository struct {\n\tdb *sql.DB\n}\n\nfunc NewPostgresUserRepository(db *sql.DB) repository.UserRepository {\n\treturn \u0026postgresUserRepository{db: db}\n}\n\nfunc (r *postgresUserRepository) Create(ctx context.Context, user *models.User) error {\n\tquery := `INSERT INTO users (id, username, password_hash, profile_pic_url) VALUES ($1, $2, $3, $4)`\n\t_, err := r.db.ExecContext(ctx, query, user.ID, user.Username, user.PasswordHash, user.ProfilePicURL)\n\tif err != nil {\n\t\tif pgErr, ok := err.(*pq.Error); ok \u0026\u0026 pgErr.Code == \"23505\" { // unique_violation\n\t\t\treturn models.ErrUsernameTaken\n\t\t}\n\t\treturn err\n\t}\n\treturn nil\n}\n\nfunc (r *postgresUserRepository) FindByUsername(ctx context.Context, username string) (*models.User, error) {\n\tquery := `SELECT id, username, password_hash, profile_pic_url, created_at FROM users WHERE LOWER(username) = $1`\n\tuser := \u0026models.User{}\n\terr := r.db.QueryRowContext(ctx, query, strings.ToLower(username)).Scan(\u0026user.ID, \u0026user.Username, \u0026user.PasswordHash, \u0026user.ProfilePicURL, \u0026user.CreatedAt)\n\tif err != nil {\n\t\tif errors.Is(err, sql.ErrNoRows) {\n\t\t\treturn nil, models.ErrUserNotFound\n\t\t}\n\t\treturn nil, err\n\t}\n\treturn user, nil\n}\n\nfunc (r *postgresUserRepository) FindByID(ctx context.Context, id uuid.UUID) (*models.User, error) {\n\tquery := `SELECT id, username, password_hash, profile_pic_url, created_at FROM users WHERE id = $1`\n\tuser := \u0026models.User{}\n\terr := r.db.QueryRowContext(ctx, query, id).Scan(\u0026user.ID, \u0026user.Username, \u0026user.PasswordHash, \u0026user.ProfilePicURL, \u0026user.CreatedAt)\n\tif err != nil {\n\t\tif errors.Is(err, sql.ErrNoRows) {\n\t\t\treturn nil, models.ErrUserNotFound\n\t\t}\n\t\treturn nil, err\n\t}\n\treturn user, nil\n}\n\nfunc (r *postgresUserRepository) Update(ctx context.Context, user *models.User) error {\n\tquery := `UPDATE users SET username = $1, password_hash = $2, profile_pic_url = $3 WHERE id = $4`\n\t_, err := r.db.ExecContext(ctx, query, user.Username, user.PasswordHash, user.ProfilePicURL, user.ID)\n\tif err != nil {\n\t\tif pgErr, ok := err.(*pq.Error); ok \u0026\u0026 pgErr.Code == \"23505\" {\n\t\t\treturn models.ErrUsernameTaken\n\t\t}\n\t\treturn err\n\t}\n\treturn nil\n}\n",
  "backend/adapter/util/password.go": "package util\n\nimport \"golang.org/x/crypto/bcrypt\"\n\nfunc HashPassword(password string) (string, error) {\n\tbytes, err := bcrypt.GenerateFromPassword([]byte(password), 14)\n\treturn string(bytes), err\n}\n\nfunc CheckPasswordHash(password, hash string) bool {\n\terr := bcrypt.CompareHashAndPassword([]byte(hash), []byte(password))\n\treturn err == nil\n}\n",
  "backend/adapter/util/response.go": "package util\n\nimport (\n\t\"encoding/json\"\n\t\"net/http\"\n)\n\nfunc RespondWithError(w http.ResponseWriter, code int, message string) {\n\tRespondWithJSON(w, code, map[string]string{\"error\": message})\n}\n\nfunc RespondWithJSON(w http.ResponseWriter, code int, payload interface{}) {\n\tresponse, _ := json.Marshal(payload)\n\tw.Header().Set(\"Content-Type\", \"application/json\")\n\tw.WriteHeader(code)\n\tw.Write(response)\n}\n",
  "backend/adapter/util/token.go": "package util\n\nimport (\n\t\"time\"\n\n\t\"github.com/golang-jwt/jwt/v5\"\n\t\"github.com/google/uuid\"\n)\n\ntype TokenGenerator interface {\n\tGenerateAccessToken(userID uuid.UUID) (string, error)\n\tGenerateRefreshToken() (uuid.UUID, time.Time, error)\n\tGetRefreshTokenExp() time.Duration\n}\n\ntype tokenGenerator struct {\n\tjwtSecret       string\n\taccessTokenExp  time.Duration\n\trefreshTokenExp time.Duration\n}\n\nfunc NewTokenGenerator(secret string, accessExp, refreshExp time.Duration) TokenGenerator {\n\treturn \u0026tokenGenerator{\n\t\tjwtSecret:       secret,\n\t\taccessTokenExp:  accessExp,\n\t\trefreshTokenExp: refreshExp,\n\t}\n}\n\nfunc (t *tokenGenerator) GenerateAccessToken(userID uuid.UUID) (string, error) {\n\tclaims := jwt.MapClaims{\n\t\t\"user_id\": userID.String(),\n\t\t\"exp\":     time.Now().Add(t.accessTokenExp).Unix(),\n\t\t\"iat\":     time.Now().Unix(),\n\t}\n\ttoken := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)\n\treturn token.SignedString([]byte(t.jwtSecret))\n}\n\nfunc (t *tokenGenerator) GenerateRefreshToken() (uuid.UUID, time.Time, error) {\n\trefreshToken := uuid.New()\n\texpiresAt := time.Now().Add(t.refreshTokenExp)\n\treturn refreshToken, expiresAt, nil\n}\n\nfunc (t *tokenGenerator) GetRefreshTokenExp() time.Duration {\n\treturn t.refreshTokenExp\n}\n",
  "backend/adapter/util/validation.go": "package util\n\nimport (\n\t\"errors\"\n\t\"mime/multipart\"\n\t\"regexp\"\n)\n\nvar usernameRegex = regexp.MustCompile(`^[a-z0-9_]{4,50}$`)\n\nfunc ValidateUsername(username string) error {\n\tif !usernameRegex.MatchString(username) {\n\t\treturn errors.New(\"invalid username format\")\n\t}\n\treturn nil\n}\n\nfunc ValidatePassword(password string) error {\n\tif len(password) \u003c 8 {\n\t\treturn errors.New(\"password is too short\")\n\t}\n\treturn nil\n}\n\nfunc ValidateProfilePic(header *multipart.FileHeader) error {\n\t// Max size: 200 KB\n\tif header.Size \u003e 200*1024 {\n\t\treturn errors.New(\"file size exceeds 200KB\")\n\t}\n\n\t// Allowed formats: png, jpg, jpeg, webp\n\tallowedTypes := map[string]bool{\n\t\t\"image/png\":  true,\n\t\t\"image/jpeg\": true,\n\t\t\"image/webp\": true,\n\t}\n\tcontentType := header.Header.Get(\"Content-Type\")\n\tif !allowedTypes[contentType] {\n\t\treturn errors.New(\"invalid file type\")\n\t}\n\n\treturn nil\n}\n```",
  "backend/cmd/server/main.go": "package main\n\nimport (\n\t\"chat-app/backend/adapter/filesystem\"\n\t\"chat-app/backend/adapter/handler/http\"\n\t\"chat-app/backend/adapter/middleware\"\n\t\"chat-app/backend/adapter/postgres\"\n\t\"chat-app/backend/adapter/util\"\n\t\"chat-app/backend/config\"\n\t\"chat-app/backend/usecase\"\n\t\"fmt\"\n\t\"log\"\n\t\"net/http\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"strings\"\n\n\t\"github.com/go-chi/chi/v5\"\n\tchi_middleware \"github.com/go-chi/chi/v5/middleware\"\n\t\"github.com/go-chi/cors\"\n)\n\nfunc main() {\n\tcfg, err := config.Load()\n\tif err != nil {\n\t\tlog.Fatalf(\"failed to load config: %v\", err)\n\t}\n\n\tdb, err := postgres.NewDB(cfg)\n\tif err != nil {\n\t\tlog.Fatalf(\"failed to connect to database: %v\", err)\n\t}\n\tdefer db.Close()\n\n\t// Repositories\n\tuserRepo := postgres.NewPostgresUserRepository(db)\n\tsessionRepo := postgres.NewPostgresSessionRepository(db)\n\tfileRepo := filesystem.NewLocalStorage(cfg.ProfilePicDir, cfg.ProfilePicRoute)\n\n\t// Usecases\n\ttokenGenerator := util.NewTokenGenerator(cfg.JWTSecret, cfg.AccessTokenExp, cfg.RefreshTokenExp)\n\tauthUsecase := usecase.NewAuthUsecase(userRepo, sessionRepo, tokenGenerator)\n\tuserUsecase := usecase.NewUserUsecase(userRepo, fileRepo)\n\n\t// Handlers\n\tauthHandler := http.NewAuthHandler(authUsecase)\n\tuserHandler := http.NewUserHandler(userUsecase)\n\n\t// Middleware\n\tauthMiddleware := middleware.NewAuthMiddleware(cfg.JWTSecret)\n\n\tr := chi.NewRouter()\n\tr.Use(chi_middleware.Logger)\n\tr.Use(cors.Handler(cors.Options{\n\t\tAllowedOrigins:   []string{\"http://*\", \"https://*\"},\n\t\tAllowedMethods:   []string{\"GET\", \"POST\", \"PUT\", \"DELETE\", \"OPTIONS\"},\n\t\tAllowedHeaders:   []string{\"Accept\", \"Authorization\", \"Content-Type\", \"X-CSRF-Token\"},\n\t\tExposedHeaders:   []string{\"Link\"},\n\t\tAllowCredentials: true,\n\t\tMaxAge:           300,\n\t}))\n\n\t// Serve static files (profile pictures)\n\tfileServer(r, cfg.ProfilePicRoute, http.Dir(cfg.ProfilePicDir))\n\n\t// Public routes\n\tr.Route(\"/api/v1\", func(r chi.Router) {\n\t\tr.Post(\"/register\", userHandler.Register)\n\t\tr.Post(\"/login\", authHandler.Login)\n\t\tr.Post(\"/refresh\", authHandler.Refresh)\n\t\tr.Post(\"/logout\", authHandler.Logout)\n\n\t\tr.Get(\"/users/{username}\", userHandler.GetUserByUsername)\n\n\t\t// Protected routes\n\t\tr.Group(func(r chi.Router) {\n\t\t\tr.Use(authMiddleware.Validate)\n\t\t\tr.Put(\"/profile\", userHandler.UpdateProfile)\n\t\t})\n\t})\n\n\tlog.Printf(\"Server starting on port %s\", cfg.ServerPort)\n\tif err := http.ListenAndServe(\":\"+cfg.ServerPort, r); err != nil {\n\t\tlog.Fatalf(\"failed to start server: %v\", err)\n\t}\n}\n\n// fileServer conveniently sets up a http.FileServer handler to serve\n// static files from a http.FileSystem.\nfunc fileServer(r chi.Router, path string, root http.FileSystem) {\n\tif strings.ContainsAny(path, \"{}*\") {\n\t\tpanic(\"FileServer does not permit URL parameters.\")\n\t}\n\n\tif path != \"/\" \u0026\u0026 path[len(path)-1] != '/' {\n\t\tr.Get(path, http.RedirectHandler(path+\"/\", http.StatusMovedPermanently).ServeHTTP)\n\t\tpath += \"/\"\n\t}\n\tpath += \"*\"\n\n\tr.Get(path, func(w http.ResponseWriter, r *http.Request) {\n\t\trctx := chi.RouteContext(r.Context())\n\t\tpathPrefix := strings.TrimSuffix(rctx.RoutePattern(), \"/*\")\n\t\tfs := http.StripPrefix(pathPrefix, http.FileServer(root))\n\t\tfs.ServeHTTP(w, r)\n\t})\n}\n",
  "backend/config/config.go": "package config\n\nimport (\n\t\"os\"\n\t\"strconv\"\n\t\"time\"\n\n\t\"github.com/joho/godotenv\"\n)\n\ntype Config struct {\n\tServerPort      string\n\tDBHost          string\n\tDBPort          string\n\tDBUser          string\n\tDBPassword      string\n\tDBName          string\n\tDBSslMode       string\n\tRedisAddr       string\n\tJWTSecret       string\n\tAccessTokenExp  time.Duration\n\tRefreshTokenExp time.Duration\n\tProfilePicDir   string\n\tProfilePicRoute string\n}\n\nfunc Load() (*Config, error) {\n\tif err := godotenv.Load(); err != nil {\n\t\t// Ignore error if .env file is not found, for production environments\n\t\tif !os.IsNotExist(err) {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\taccessTokenExpMin, _ := strconv.Atoi(getEnv(\"JWT_ACCESS_TOKEN_EXP_MIN\", \"10\"))\n\trefreshTokenExpHour, _ := strconv.Atoi(getEnv(\"JWT_REFRESH_TOKEN_EXP_HOUR\", \"8\"))\n\n\tcfg := \u0026Config{\n\t\tServerPort:      getEnv(\"SERVER_PORT\", \"8080\"),\n\t\tDBHost:          getEnv(\"DB_HOST\", \"localhost\"),\n\t\tDBPort:          getEnv(\"DB_PORT\", \"5432\"),\n\t\tDBUser:          getEnv(\"DB_USER\", \"user\"),\n\t\tDBPassword:      getEnv(\"DB_PASSWORD\", \"password\"),\n\t\tDBName:          getEnv(\"DB_NAME\", \"quikchat\"),\n\t\tDBSslMode:       getEnv(\"DB_SSLMODE\", \"disable\"),\n\t\tRedisAddr:       getEnv(\"REDIS_ADDR\", \"localhost:6379\"),\n\t\tJWTSecret:       getEnv(\"JWT_SECRET\", \"a_very_secret_key\"),\n\t\tAccessTokenExp:  time.Duration(accessTokenExpMin) * time.Minute,\n\t\tRefreshTokenExp: time.Duration(refreshTokenExpHour) * time.Hour,\n\t\tProfilePicDir:   getEnv(\"PROFILE_PIC_DIR\", \"./uploads/profile_pics\"),\n\t\tProfilePicRoute: getEnv(\"PROFILE_PIC_ROUTE\", \"/static/profile_pics/\"),\n\t}\n\n\t// Ensure profile pic directory exists\n\tif err := os.MkdirAll(cfg.ProfilePicDir, os.ModePerm); err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn cfg, nil\n}\n\nfunc getEnv(key, fallback string) string {\n\tif value, exists := os.LookupEnv(key); exists {\n\t\treturn value\n\t}\n\treturn fallback\n}\n",
  "backend/models/error.go": "package models\n\nimport \"errors\"\n\nvar (\n\tErrUserNotFound      = errors.New(\"user not found\")\n\tErrUsernameTaken     = errors.New(\"username is already taken\")\n\tErrInvalidCredentials = errors.New(\"invalid username or password\")\n\tErrSessionNotFound   = errors.New(\"session not found or expired\")\n\tErrInvalidToken      = errors.New(\"invalid or expired token\")\n\tErrUnauthorized      = errors.New(\"unauthorized\")\n\tErrInternalServer    = errors.New(\"internal server error\")\n\tErrBadRequest        = errors.New(\"bad request\")\n)\n",
  "backend/models/session.go": "package models\n\nimport (\n\t\"time\"\n\n\t\"github.com/google/uuid\"\n)\n\ntype Session struct {\n\tRefreshToken uuid.UUID `json:\"refreshToken\"`\n\tUserID       uuid.UUID `json:\"userId\"`\n\tExpiresAt    time.Time `json:\"expiresAt\"`\n}\n",
  "backend/models/user.go": "package models\n\nimport (\n\t\"time\"\n\n\t\"github.com/google/uuid\"\n)\n\ntype User struct {\n\tID           uuid.UUID `json:\"id\"`\n\tUsername     string    `json:\"username\"`\n\tPasswordHash string    `json:\"-\"`\n\tProfilePicURL string    `json:\"profilePicUrl\"`\n\tCreatedAt    time.Time `json:\"createdAt\"`\n}\n",
  "backend/repository/file_repository.go": "package repository\n\nimport \"mime/multipart\"\n\ntype FileRepository interface {\n\tSave(file multipart.File, header *multipart.FileHeader) (string, error)\n}\n",
  "backend/repository/session_repository.go": "package repository\n\nimport (\n\t\"chat-app/backend/models\"\n\t\"context\"\n\n\t\"github.com/google/uuid\"\n)\n\ntype SessionRepository interface {\n\tCreate(ctx context.Context, session *models.Session) error\n\tFind(ctx context.Context, refreshToken uuid.UUID) (*models.Session, error)\n\tDelete(ctx context.Context, refreshToken uuid.UUID) error\n\tDeleteByUserID(ctx context.Context, userID uuid.UUID) error\n}\n",
  "backend/repository/user_repository.go": "package repository\n\nimport (\n\t\"chat-app/backend/models\"\n\t\"context\"\n\n\t\"github.com/google/uuid\"\n)\n\ntype UserRepository interface {\n\tCreate(ctx context.Context, user *models.User) error\n\tFindByUsername(ctx context.Context, username string) (*models.User, error)\n\tFindByID(ctx context.Context, id uuid.UUID) (*models.User, error)\n\tUpdate(ctx context.Context, user *models.User) error\n}\n",
  "backend/usecase/auth_usecase.go": "package usecase\n\nimport (\n\t\"chat-app/backend/adapter/util\"\n\t\"chat-app/backend/models\"\n\t\"chat-app/backend/repository\"\n\t\"context\"\n\t\"errors\"\n\t\"time\"\n\n\t\"github.com/google/uuid\"\n)\n\ntype AuthUsecase interface {\n\tLogin(ctx context.Context, username, password string) (accessToken string, refreshToken string, err error)\n\tRefresh(ctx context.Context, refreshToken string) (newAccessToken string, err error)\n\tLogout(ctx context.Context, refreshToken string) error\n}\n\ntype authUsecase struct {\n\tuserRepo    repository.UserRepository\n\tsessionRepo repository.SessionRepository\n\ttokenGen    util.TokenGenerator\n}\n\nfunc NewAuthUsecase(userRepo repository.UserRepository, sessionRepo repository.SessionRepository, tokenGen util.TokenGenerator) AuthUsecase {\n\treturn \u0026authUsecase{\n\t\tuserRepo:    userRepo,\n\t\tsessionRepo: sessionRepo,\n\t\ttokenGen:    tokenGen,\n\t}\n}\n\nfunc (a *authUsecase) Login(ctx context.Context, username, password string) (string, string, error) {\n\tuser, err := a.userRepo.FindByUsername(ctx, username)\n\tif err != nil {\n\t\tif errors.Is(err, models.ErrUserNotFound) {\n\t\t\treturn \"\", \"\", models.ErrInvalidCredentials\n\t\t}\n\t\treturn \"\", \"\", err\n\t}\n\n\tif !util.CheckPasswordHash(password, user.PasswordHash) {\n\t\treturn \"\", \"\", models.ErrInvalidCredentials\n\t}\n\n\t// Single device policy: remove old sessions\n\tif err := a.sessionRepo.DeleteByUserID(ctx, user.ID); err != nil {\n\t\t// Log error but continue, as this is not critical for login\n\t\t// log.Printf(\"failed to delete old sessions for user %s: %v\", user.ID, err)\n\t}\n\n\taccessToken, err := a.tokenGen.GenerateAccessToken(user.ID)\n\tif err != nil {\n\t\treturn \"\", \"\", err\n\t}\n\n\trefreshToken, expiresAt, err := a.tokenGen.GenerateRefreshToken()\n\tif err != nil {\n\t\treturn \"\", \"\", err\n\t}\n\n\tsession := \u0026models.Session{\n\t\tRefreshToken: refreshToken,\n\t\tUserID:       user.ID,\n\t\tExpiresAt:    expiresAt,\n\t}\n\n\tif err := a.sessionRepo.Create(ctx, session); err != nil {\n\t\treturn \"\", \"\", err\n\t}\n\n\treturn accessToken, refreshToken.String(), nil\n}\n\nfunc (a *authUsecase) Refresh(ctx context.Context, refreshTokenStr string) (string, error) {\n\trefreshToken, err := uuid.Parse(refreshTokenStr)\n\tif err != nil {\n\t\treturn \"\", models.ErrInvalidToken\n\t}\n\n\tsession, err := a.sessionRepo.Find(ctx, refreshToken)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\tif session.ExpiresAt.Before(time.Now()) {\n\t\t// Clean up expired session\n\t\t_ = a.sessionRepo.Delete(ctx, refreshToken)\n\t\treturn \"\", models.ErrSessionNotFound\n\t}\n\n\t// Sliding window: extend session expiry\n\tsession.ExpiresAt = time.Now().Add(a.tokenGen.GetRefreshTokenExp())\n\tif err := a.sessionRepo.Create(ctx, session); err != nil { // Create will UPSERT\n\t\treturn \"\", err\n\t}\n\n\tnewAccessToken, err := a.tokenGen.GenerateAccessToken(session.UserID)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\treturn newAccessToken, nil\n}\n\nfunc (a *authUsecase) Logout(ctx context.Context, refreshTokenStr string) error {\n\trefreshToken, err := uuid.Parse(refreshTokenStr)\n\tif err != nil {\n\t\treturn models.ErrInvalidToken\n\t}\n\treturn a.sessionRepo.Delete(ctx, refreshToken)\n}\n",
  "backend/usecase/user_usecase.go": "package usecase\n\nimport (\n\t\"chat-app/backend/adapter/util\"\n\t\"chat-app/backend/models\"\n\t\"chat-app/backend/repository\"\n\t\"context\"\n\t\"errors\"\n\t\"mime/multipart\"\n\t\"strings\"\n\n\t\"github.com/google/uuid\"\n)\n\ntype UserUsecase interface {\n\tRegister(ctx context.Context, username, password string) (*models.User, error)\n\tGetByUsername(ctx context.Context, username string) (*models.User, error)\n\tUpdateProfile(ctx context.Context, userID uuid.UUID, username, password *string, profilePic multipart.File, profilePicHeader *multipart.FileHeader) (*models.User, error)\n}\n\ntype userUsecase struct {\n\tuserRepo repository.UserRepository\n\tfileRepo repository.FileRepository\n}\n\nfunc NewUserUsecase(userRepo repository.UserRepository, fileRepo repository.FileRepository) UserUsecase {\n\treturn \u0026userUsecase{\n\t\tuserRepo: userRepo,\n\t\tfileRepo: fileRepo,\n\t}\n}\n\nfunc (u *userUsecase) Register(ctx context.Context, username, password string) (*models.User, error) {\n\tif err := util.ValidateUsername(username); err != nil {\n\t\treturn nil, err\n\t}\n\tif err := util.ValidatePassword(password); err != nil {\n\t\treturn nil, err\n\t}\n\n\texistingUser, err := u.userRepo.FindByUsername(ctx, username)\n\tif err != nil \u0026\u0026 !errors.Is(err, models.ErrUserNotFound) {\n\t\treturn nil, err\n\t}\n\tif existingUser != nil {\n\t\treturn nil, models.ErrUsernameTaken\n\t}\n\n\thashedPassword, err := util.HashPassword(password)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tuser := \u0026models.User{\n\t\tID:           uuid.New(),\n\t\tUsername:     strings.ToLower(username),\n\t\tPasswordHash: hashedPassword,\n\t}\n\n\tif err := u.userRepo.Create(ctx, user); err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn user, nil\n}\n\nfunc (u *userUsecase) GetByUsername(ctx context.Context, username string) (*models.User, error) {\n\treturn u.userRepo.FindByUsername(ctx, username)\n}\n\nfunc (u *userUsecase) UpdateProfile(ctx context.Context, userID uuid.UUID, username, password *string, profilePic multipart.File, profilePicHeader *multipart.FileHeader) (*models.User, error) {\n\tuser, err := u.userRepo.FindByID(ctx, userID)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tif username != nil {\n\t\tif err := util.ValidateUsername(*username); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\t// Check if new username is taken by another user\n\t\texistingUser, err := u.userRepo.FindByUsername(ctx, *username)\n\t\tif err != nil \u0026\u0026 !errors.Is(err, models.ErrUserNotFound) {\n\t\t\treturn nil, err\n\t\t}\n\t\tif existingUser != nil \u0026\u0026 existingUser.ID != userID {\n\t\t\treturn nil, models.ErrUsernameTaken\n\t\t}\n\t\tuser.Username = strings.ToLower(*username)\n\t}\n\n\tif password != nil {\n\t\tif err := util.ValidatePassword(*password); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\thashedPassword, err := util.HashPassword(*password)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tuser.PasswordHash = hashedPassword\n\t}\n\n\tif profilePic != nil {\n\t\tif err := util.ValidateProfilePic(profilePicHeader); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tpicURL, err := u.fileRepo.Save(profilePic, profilePicHeader)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tuser.ProfilePicURL = picURL\n\t}\n\n\tif err := u.userRepo.Update(ctx, user); err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn user, nil\n}\n",
  "docker-compose.yml": "version: '3.8'\n\nservices:\n  postgres:\n    image: postgres:13\n    container_name: quikchat_postgres\n    environment:\n      POSTGRES_USER: ${DB_USER:-user}\n      POSTGRES_PASSWORD: ${DB_PASSWORD:-password}\n      POSTGRES_DB: ${DB_NAME:-quikchat}\n    ports:\n      - \"${DB_PORT:-5432}:5432\"\n    volumes:\n      - postgres_data:/var/lib/postgresql/data\n      - ./backend/adapter/postgres/migrations:/docker-entrypoint-initdb.d\n    restart: unless-stopped\n\n  redis:\n    image: redis:6.2-alpine\n    container_name: quikchat_redis\n    ports:\n      - \"6379:6379\"\n    restart: unless-stopped\n\nvolumes:\n  postgres_data:\n"
}