{
  "Makefile": ".PHONY: up down logs psql migrate-up run build\n\n# Docker Compose commands\nup:\n\t@echo \"Starting Docker containers...\"\n\tdocker-compose up -d\n\ndown:\n\t@echo \"Stopping Docker containers...\"\n\tdocker-compose down\n\nlogs:\n\t@echo \"Tailing logs...\"\n\tdocker-compose logs -f\n\n# Database commands\npsql:\n\t@echo \"Connecting to PostgreSQL container...\"\n\tdocker-compose exec postgres psql -U user -d chatdb\n\nmigrate-up:\n\t@echo \"Applying database migrations...\"\n\tdocker-compose exec -T postgres psql -U user -d chatdb \u003c backend/migrations/000001_create_users_table.up.sql\n\tdocker-compose exec -T postgres psql -U user -d chatdb \u003c backend/migrations/000002_create_sessions_table.up.sql\n\n# Go application commands\nrun:\n\t@echo \"Running the Go application...\"\n\tgo run ./backend/cmd/server/main.go\n\nbuild:\n\t@echo \"Building the Go application...\"\n\tgo build -o ./bin/server ./backend/cmd/server/main.go\n",
  "backend/cmd/server/main.go": "package main\n\nimport (\n\t\"context\"\n\t\"log\"\n\t\"net/http\"\n\t\"time\"\n\n\t\"chat-app/internal/adapter/localfile\"\n\t\"chat-app/internal/adapter/postgres\"\n\t\"chat-app/internal/adapter/redis\"\n\t\"chat-app/internal/delivery/http/handler\"\n\t\"chat-app/internal/delivery/http/router\"\n\t\"chat-app/internal/delivery/websocket\"\n\t\"chat-app/internal/service\"\n\t\"chat-app/pkg/config\"\n)\n\nfunc main() {\n\tlog.Println(\"Starting QuikChat server...\")\n\n\t// Load configuration\n\tcfg := config.Load()\n\n\t// Initialize database connection\n\tdb := postgres.NewDB(cfg.DatabaseURL)\n\t// The attempted content removed explicit error handling here, assuming NewDB handles it internally or panics.\n\tdefer db.Close()\n\tlog.Println(\"Database connection established.\")\n\n\t// Initialize Redis client\n\tredisClient := redis.NewClient(cfg.RedisURL)\n\n\t// Initialize repositories\n\tuserRepo := postgres.NewPostgresUserRepository(db)\n\tsessionRepo := postgres.NewPostgresSessionRepository(db)\n\tfileRepo, err := localfile.NewLocalFileRepository(cfg.UploadDir)\n\tif err != nil {\n\t\tlog.Fatalf(\"Failed to create file repository: %v\", err)\n\t}\n\tredisEventRepo := redis.NewRedisEventRepository(redisClient)\n\tpgEventRepo := postgres.NewPostgresEventRepository(db)\n\n\t// Initialize use cases/services\n\tauthUsecase := service.NewAuthService(userRepo, sessionRepo, cfg)\n\tuserUsecase := service.NewUserService(userRepo, fileRepo)\n\teventUsecase := service.NewEventService(redisEventRepo, pgEventRepo, userRepo)\n\n\t// Initialize WebSocket Hub\n\thub := websocket.NewHub(eventUsecase)\n\tgo hub.Run()\n\n\t// Start background worker for event persistence\n\tgo func() {\n\t\tticker := time.NewTicker(1 * time.Minute) // Run every minute\n\t\tdefer ticker.Stop()\n\t\tfor {\n\t\t\t\u003c-ticker.C\n\t\t\tlog.Println(\"Running background worker to persist events...\")\n\t\t\teventUsecase.PersistBufferedEvents(context.Background())\n\t\t}\n\t}()\n\n\t// Initialize router\n\tr := router.NewRouter(cfg, authUsecase, userUsecase, hub)\n\n\t// Start server\n\tserver := \u0026http.Server{\n\t\tAddr:    \":\" + cfg.Port,\n\t\tHandler: r,\n\t}\n\n\tlog.Printf(\"Server starting on port %s\", cfg.Port)\n\tif err := server.ListenAndServe(); err != nil \u0026\u0026 err != http.ErrServerClosed {\n\t\tlog.Fatalf(\"Failed to start server: %v\", err)\n\t}\n}\n",
  "backend/go.mod": "module chat-app\n\ngo 1.24.0\n",
  "backend/internal/adapter/localfile/file_repository.go": "package localfile\n\nimport (\n\t\"chat-app/internal/repository\"\n\t\"chat-app/pkg/util\"\n\t\"context\"\n\t\"fmt\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"strings\"\n)\n\ntype localFileRepository struct {\n\tuploadDir string\n}\n\nfunc NewLocalFileRepository(uploadDir string) (repository.FileRepository, error) {\n\tif err := os.MkdirAll(uploadDir, os.ModePerm); err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to create upload directory: %w\", err)\n\t}\n\treturn \u0026localFileRepository{uploadDir: uploadDir}, nil\n}\n\nfunc (r *localFileRepository) SaveProfilePicture(_ context.Context, fileData []byte, fileType string) (string, error) {\n\tvar ext string\n\tswitch fileType {\n\tcase \"image/jpeg\", \"image/jpg\":\n\t\text = \".jpg\"\n\tcase \"image/png\":\n\t\text = \".png\"\n\tcase \"image/webp\":\n\t\text = \".webp\"\n\tdefault:\n\t\treturn \"\", fmt.Errorf(\"unsupported file type: %s\", fileType)\n\t}\n\n\tfilename := util.NewUUID() + ext\n\tfilePath := filepath.Join(r.uploadDir, filename)\n\n\terr := os.WriteFile(filePath, fileData, 0644)\n\tif err != nil {\n\t\treturn \"\", fmt.Errorf(\"failed to write file: %w\", err)\n\t}\n\n\treturn filename, nil\n}\n",
  "backend/internal/adapter/postgres/event_repository.go": "package postgres\n\nimport (\n\t\"chat-app/internal/domain\"\n\t\"chat-app/internal/repository\"\n\t\"context\"\n\t\"fmt\"\n\t\"github.com/jackc/pgx/v5/pgxpool\"\n)\n\ntype postgresEventRepository struct {\n\tdb *pgxpool.Pool\n}\n\nfunc NewPostgresEventRepository(db *pgxpool.Pool) repository.EventRepository {\n\treturn \u0026postgresEventRepository{db: db}\n}\n\nfunc (r *postgresEventRepository) StoreEvents(ctx context.Context, events []*domain.Event) error {\n\tif len(events) == 0 {\n\t\treturn nil\n\t}\n\n\ttx, err := r.db.Begin(ctx)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to begin transaction: %w\", err)\n\t}\n\tdefer tx.Rollback(ctx)\n\n\tquery := `INSERT INTO events (id, type, payload, recipient_id, created_at) VALUES ($1, $2, $3, $4, $5)`\n\tfor _, event := range events {\n\t\t_, err := tx.Exec(ctx, query, event.ID, event.Type, event.Payload, event.RecipientID, event.CreatedAt)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"failed to insert event: %w\", err)\n\t\t}\n\t}\n\n\treturn tx.Commit(ctx)\n}\n\nfunc (r *postgresEventRepository) GetUndeliveredEvents(ctx context.Context, userID string) ([]*domain.Event, error) {\n\tquery := `SELECT id, type, payload, recipient_id, is_delivered, created_at FROM events WHERE recipient_id = $1 AND is_delivered = FALSE ORDER BY created_at ASC`\n\trows, err := r.db.Query(ctx, query, userID)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to query undelivered events: %w\", err)\n\t}\n\tdefer rows.Close()\n\n\tvar events []*domain.Event\n\tfor rows.Next() {\n\t\tvar event domain.Event\n\t\tif err := rows.Scan(\u0026event.ID, \u0026event.Type, \u0026event.Payload, \u0026event.RecipientID, \u0026event.IsDelivered, \u0026event.CreatedAt); err != nil {\n\t\t\treturn nil, fmt.Errorf(\"failed to scan event row: %w\", err)\n\t\t}\n\t\tevents = append(events, \u0026event)\n\t}\n\treturn events, nil\n}\n\nfunc (r *postgresEventRepository) MarkEventsAsDelivered(ctx context.Context, eventIDs []string) error {\n\tif len(eventIDs) == 0 {\n\t\treturn nil\n\t}\n\tquery := `UPDATE events SET is_delivered = TRUE WHERE id = ANY($1::uuid[])`\n\t_, err := r.db.Exec(ctx, query, eventIDs)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to mark events as delivered: %w\", err)\n\t}\n\treturn nil\n}\n\n// These methods are for the Redis implementation, so they are no-ops here.\nfunc (r *postgresEventRepository) BufferEvent(ctx context.Context, event *domain.Event) error {\n\treturn nil\n}\nfunc (r *postgresEventRepository) GetBufferedEventsForUser(ctx context.Context, userID string) ([]*domain.Event, error) {\n\treturn nil, nil\n}\nfunc (r *postgresEventRepository) ClearUserBuffer(ctx context.Context, userID string) error {\n\treturn nil\n}\n",
  "backend/internal/adapter/postgres/postgres.go": "package postgres\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"log\"\n\n\t\"github.com/jackc/pgx/v5/pgxpool\"\n)\n\nfunc NewDB(databaseURL string) *pgxpool.Pool {\n\tdbpool, err := pgxpool.New(context.Background(), databaseURL)\n\tif err != nil {\n\t\tlog.Fatalf(\"Unable to create connection pool: %v\\n\", err)\n\t}\n\n\terr = dbpool.Ping(context.Background())\n\tif err != nil {\n\t\tlog.Fatalf(\"Unable to ping database: %v\\n\", err)\n\t}\n\n\tfmt.Println(\"Successfully connected to PostgreSQL!\")\n\treturn dbpool\n}\n",
  "backend/internal/adapter/postgres/session_repository.go": "package postgres\n\nimport (\n\t\"context\"\n\t\"errors\"\n\n\t\"chat-app/internal/domain\"\n\t\"chat-app/internal/repository\"\n\n\t\"github.com/jackc/pgx/v5\"\n\t\"github.com/jackc/pgx/v5/pgxpool\"\n)\n\ntype postgresSessionRepository struct {\n\tdb *pgxpool.Pool\n}\n\nfunc NewPostgresSessionRepository(db *pgxpool.Pool) repository.SessionRepository {\n\treturn \u0026postgresSessionRepository{db: db}\n}\n\nfunc (r *postgresSessionRepository) Store(ctx context.Context, session *domain.Session) error {\n\tquery := `INSERT INTO sessions (id, user_id, expires_at) VALUES ($1, $2, $3)`\n\t_, err := r.db.Exec(ctx, query, session.ID, session.UserID, session.ExpiresAt)\n\treturn err\n}\n\nfunc (r *postgresSessionRepository) GetByID(ctx context.Context, id string) (*domain.Session, error) {\n\tquery := `SELECT id, user_id, expires_at, created_at FROM sessions WHERE id = $1`\n\n\tsession := \u0026domain.Session{}\n\terr := r.db.QueryRow(ctx, query, id).Scan(\n\t\t\u0026session.ID,\n\t\t\u0026session.UserID,\n\t\t\u0026session.ExpiresAt,\n\t\t\u0026session.CreatedAt,\n\t)\n\tif err != nil {\n\t\tif errors.Is(err, pgx.ErrNoRows) {\n\t\t\treturn nil, nil // Not found\n\t\t}\n\t\treturn nil, err\n\t}\n\treturn session, nil\n}\n\nfunc (r *postgresSessionRepository) Delete(ctx context.Context, id string) error {\n\tquery := `DELETE FROM sessions WHERE id = $1`\n\t_, err := r.db.Exec(ctx, query, id)\n\treturn err\n}\n\nfunc (r *postgresSessionRepository) DeleteAllForUser(ctx context.Context, userID string) error {\n\tquery := `DELETE FROM sessions WHERE user_id = $1`\n\t_, err := r.db.Exec(ctx, query, userID)\n\treturn err\n}\n",
  "backend/internal/adapter/postgres/user_repository.go": "package postgres\n\nimport (\n\t\"context\"\n\t\"errors\"\n\n\t\"chat-app/internal/domain\"\n\t\"chat-app/internal/repository\"\n\n\t\"github.com/jackc/pgx/v5\"\n\t\"github.com/jackc/pgx/v5/pgxpool\"\n)\n\ntype postgresUserRepository struct {\n\tdb *pgxpool.Pool\n}\n\nfunc NewPostgresUserRepository(db *pgxpool.Pool) repository.UserRepository {\n\treturn \u0026postgresUserRepository{db: db}\n}\n\nfunc (r *postgresUserRepository) Create(ctx context.Context, user *domain.User) error {\n\tquery := `INSERT INTO users (id, username, password_hash) VALUES ($1, $2, $3)`\n\t_, err := r.db.Exec(ctx, query, user.ID, user.Username, user.PasswordHash)\n\treturn err\n}\n\nfunc (r *postgresUserRepository) GetByUsername(ctx context.Context, username string) (*domain.User, error) {\n\tquery := `SELECT id, username, password_hash, profile_pic_url, created_at, updated_at FROM users WHERE username = $1`\n\tuser := \u0026domain.User{}\n\terr := r.db.QueryRow(ctx, query, username).Scan(\u0026user.ID, \u0026user.Username, \u0026user.PasswordHash, \u0026user.ProfilePicURL, \u0026user.CreatedAt, \u0026user.UpdatedAt)\n\tif err != nil {\n\t\tif errors.Is(err, pgx.ErrNoRows) {\n\t\t\treturn nil, nil\n\t\t}\n\t\treturn nil, err\n\t}\n\treturn user, nil\n}\n\nfunc (r *postgresUserRepository) GetByID(ctx context.Context, id string) (*domain.User, error) {\n\tquery := `SELECT id, username, password_hash, profile_pic_url, created_at, updated_at FROM users WHERE id = $1`\n\tuser := \u0026domain.User{}\n\terr := r.db.QueryRow(ctx, query, id).Scan(\u0026user.ID, \u0026user.Username, \u0026user.PasswordHash, \u0026user.ProfilePicURL, \u0026user.CreatedAt, \u0026user.UpdatedAt)\n\tif err != nil {\n\t\tif errors.Is(err, pgx.ErrNoRows) {\n\t\t\treturn nil, nil\n\t\t}\n\t\treturn nil, err\n\t}\n\treturn user, nil\n}\n\nfunc (r *postgresUserRepository) Update(ctx context.Context, user *domain.User) error {\n\tquery := `UPDATE users SET username = $1, password_hash = $2, profile_pic_url = $3, updated_at = NOW() WHERE id = $4`\n\t_, err := r.db.Exec(ctx, query, user.Username, user.PasswordHash, user.ProfilePicURL, user.ID)\n\treturn err\n}\n",
  "backend/internal/adapter/redis/event_repository.go": "package redis\n\nimport (\n\t\"chat-app/internal/domain\"\n\t\"chat-app/internal/repository\"\n\t\"context\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"github.com/redis/go-redis/v9\"\n\t\"time\"\n)\n\nconst (\n\tuserEventBufferKeyPrefix = \"events:\"\n\tbufferTTL                = 48 * time.Hour\n)\n\ntype redisEventRepository struct {\n\tclient *redis.Client\n}\n\nfunc NewRedisEventRepository(client *redis.Client) repository.EventRepository {\n\treturn \u0026redisEventRepository{client: client}\n}\n\nfunc (r *redisEventRepository) userBufferKey(userID string) string {\n\treturn fmt.Sprintf(\"%s%s\", userEventBufferKeyPrefix, userID)\n}\n\nfunc (r *redisEventRepository) BufferEvent(ctx context.Context, event *domain.Event) error {\n\tkey := r.userBufferKey(event.RecipientID)\n\n\teventJSON, err := json.Marshal(event)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to marshal event: %w\", err)\n\t}\n\n\tpipe := r.client.Pipeline()\n\tpipe.LPush(ctx, key, eventJSON)\n\tpipe.Expire(ctx, key, bufferTTL)\n\n\t_, err = pipe.Exec(ctx)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to execute redis pipeline for buffering event: %w\", err)\n\t}\n\treturn nil\n}\n\nfunc (r *redisEventRepository) GetBufferedEventsForUser(ctx context.Context, userID string) ([]*domain.Event, error) {\n\tkey := r.userBufferKey(userID)\n\teventStrings, err := r.client.LRange(ctx, key, 0, -1).Result()\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to get buffered events from redis: %w\", err)\n\t}\n\n\tevents := make([]*domain.Event, 0, len(eventStrings))\n\tfor _, eventStr := range eventStrings {\n\t\tvar event domain.Event\n\t\tif err := json.Unmarshal([]byte(eventStr), \u0026event); err != nil {\n\t\t\t// Log error but continue processing other events\n\t\t\tfmt.Printf(\"Error unmarshalling event from redis: %v\\n\", err)\n\t\t\tcontinue\n\t\t}\n\t\tevents = append(events, \u0026event)\n\t}\n\treturn events, nil\n}\n\nfunc (r *redisEventRepository) ClearUserBuffer(ctx context.Context, userID string) error {\n\tkey := r.userBufferKey(userID)\n\tif err := r.client.Del(ctx, key).Err(); err != nil {\n\t\treturn fmt.Errorf(\"failed to clear user event buffer in redis: %w\", err)\n\t}\n\treturn nil\n}\n\n// These methods are for the Postgres implementation, so they are no-ops here.\nfunc (r *redisEventRepository) StoreEvents(ctx context.Context, events []*domain.Event) error {\n\treturn nil\n}\nfunc (r *redisEventRepository) GetUndeliveredEvents(ctx context.Context, userID string) ([]*domain.Event, error) {\n\treturn nil, nil\n}\nfunc (r *redisEventRepository) MarkEventsAsDelivered(ctx context.Context, eventIDs []string) error {\n\treturn nil\n}\n",
  "backend/internal/adapter/redis/redis.go": "package redis\n\nimport (\n\t\"context\"\n\t\"github.com/redis/go-redis/v9\"\n\t\"log\"\n)\n\nfunc NewClient(redisURL string) *redis.Client {\n\topts, err := redis.ParseURL(redisURL)\n\tif err != nil {\n\t\tlog.Fatalf(\"Could not parse Redis URL: %v\", err)\n\t}\n\n\tclient := redis.NewClient(opts)\n\n\tif err := client.Ping(context.Background()).Err(); err != nil {\n\t\tlog.Fatalf(\"Could not connect to Redis: %v\", err)\n\t}\n\n\tlog.Println(\"Successfully connected to Redis\")\n\treturn client\n}\n",
  "backend/internal/delivery/http/handler/auth_handler.go": "package handler\n\nimport (\n\t\"encoding/json\"\n\t\"errors\"\n\t\"net/http\"\n\n\t\"chat-app/internal/service\"\n\t\"chat-app/internal/usecase\"\n)\n\ntype AuthHandler struct {\n\tauthUsecase usecase.AuthUsecase\n}\n\nfunc NewAuthHandler(authUsecase usecase.AuthUsecase) *AuthHandler {\n\treturn \u0026AuthHandler{authUsecase: authUsecase}\n}\n\nfunc (h *AuthHandler) SignUp(w http.ResponseWriter, r *http.Request) {\n\tvar input usecase.SignUpInput\n\tif err := json.NewDecoder(r.Body).Decode(\u0026input); err != nil {\n\t\thttp.Error(w, \"Invalid request body\", http.StatusBadRequest)\n\t\treturn\n\t}\n\n\tuser, err := h.authUsecase.SignUp(r.Context(), input)\n\tif err != nil {\n\t\thandleAuthError(w, err)\n\t\treturn\n\t}\n\n\t// Don't return password hash\n\tuser.PasswordHash = \"\"\n\n\tw.Header().Set(\"Content-Type\", \"application/json\")\n\tw.WriteHeader(http.StatusCreated)\n\tjson.NewEncoder(w).Encode(user)\n}\n\nfunc (h *AuthHandler) Login(w http.ResponseWriter, r *http.Request) {\n\tvar input usecase.LoginInput\n\tif err := json.NewDecoder(r.Body).Decode(\u0026input); err != nil {\n\t\thttp.Error(w, \"Invalid request body\", http.StatusBadRequest)\n\t\treturn\n\t}\n\n\ttokens, err := h.authUsecase.Login(r.Context(), input)\n\tif err != nil {\n\t\thandleAuthError(w, err)\n\t\treturn\n\t}\n\n\tw.Header().Set(\"Content-Type\", \"application/json\")\n\tjson.NewEncoder(w).Encode(tokens)\n}\n\nfunc (h *AuthHandler) Refresh(w http.ResponseWriter, r *http.Request) {\n\tvar body struct {\n\t\tRefreshToken string `json:\"refresh_token\"`\n\t}\n\tif err := json.NewDecoder(r.Body).Decode(\u0026body); err != nil {\n\t\thttp.Error(w, \"Invalid request body\", http.StatusBadRequest)\n\t\treturn\n\t}\n\n\ttokens, err := h.authUsecase.Refresh(r.Context(), body.RefreshToken)\n\tif err != nil {\n\t\thandleAuthError(w, err)\n\t\treturn\n\t}\n\n\tw.Header().Set(\"Content-Type\", \"application/json\")\n\tjson.NewEncoder(w).Encode(tokens)\n}\n\nfunc (h *AuthHandler) Logout(w http.ResponseWriter, r *http.Request) {\n\tvar body struct {\n\t\tRefreshToken string `json:\"refresh_token\"`\n\t}\n\tif err := json.NewDecoder(r.Body).Decode(\u0026body); err != nil {\n\t\thttp.Error(w, \"Invalid request body\", http.StatusBadRequest)\n\t\treturn\n\t}\n\n\terr := h.authUsecase.Logout(r.Context(), body.RefreshToken)\n\tif err != nil {\n\t\thandleAuthError(w, err)\n\t\treturn\n\t}\n\n\tw.WriteHeader(http.StatusNoContent)\n}\n\nfunc handleAuthError(w http.ResponseWriter, err error) {\n\tswitch {\n\tcase errors.Is(err, service.ErrUserExists),\n\t\terrors.Is(err, service.ErrInvalidUsername),\n\t\terrors.Is(err, service.ErrInvalidPassword):\n\t\thttp.Error(w, err.Error(), http.StatusBadRequest)\n\tcase errors.Is(err, service.ErrInvalidCredentials),\n\t\terrors.Is(err, service.ErrSessionNotFound),\n\t\terrors.Is(err, service.ErrSessionExpired):\n\t\thttp.Error(w, err.Error(), http.StatusUnauthorized)\n\tdefault:\n\t\thttp.Error(w, \"Internal server error\", http.StatusInternalServerError)\n\t}\n}\n",
  "backend/internal/delivery/http/handler/user_handler.go": "package handler\n\nimport (\n\t\"chat-app/internal/delivery/http/middleware\"\n\t\"chat-app/internal/service\"\n\t\"chat-app/internal/usecase\"\n\t\"encoding/json\"\n\t\"net/http\"\n\n\t\"github.com/go-chi/chi/v5\"\n)\n\ntype UserHandler struct {\n\tuserUsecase usecase.UserUsecase\n}\n\nfunc NewUserHandler(uc usecase.UserUsecase) *UserHandler {\n\treturn \u0026UserHandler{userUsecase: uc}\n}\n\nfunc (h *UserHandler) GetMyProfile(w http.ResponseWriter, r *http.Request) {\n\tuserID, ok := r.Context().Value(middleware.UserIDContextKey).(string)\n\tif !ok {\n\t\thttp.Error(w, \"Unauthorized\", http.StatusUnauthorized)\n\t\treturn\n\t}\n\n\tuser, err := h.userUsecase.GetProfile(r.Context(), userID)\n\tif err != nil {\n\t\thttp.Error(w, \"Internal server error\", http.StatusInternalServerError)\n\t\treturn\n\t}\n\tif user == nil {\n\t\thttp.Error(w, \"User not found\", http.StatusNotFound)\n\t\treturn\n\t}\n\n\tw.Header().Set(\"Content-Type\", \"application/json\")\n\tjson.NewEncoder(w).Encode(user)\n}\n\nfunc (h *UserHandler) GetUserProfile(w http.ResponseWriter, r *http.Request) {\n\tusername := chi.URLParam(r, \"username\")\n\tuser, err := h.userUsecase.GetUserByUsername(r.Context(), username)\n\tif err != nil {\n\t\thttp.Error(w, \"Internal server error\", http.StatusInternalServerError)\n\t\treturn\n\t}\n\tif user == nil {\n\t\thttp.Error(w, \"User not found\", http.StatusNotFound)\n\t\treturn\n\t}\n\n\tw.Header().Set(\"Content-Type\", \"application/json\")\n\tjson.NewEncoder(w).Encode(user)\n}\n\nfunc (h *UserHandler) UpdateMyProfile(w http.ResponseWriter, r *http.Request) {\n\tuserID, ok := r.Context().Value(middleware.UserIDContextKey).(string)\n\tif !ok {\n\t\thttp.Error(w, \"Unauthorized\", http.StatusUnauthorized)\n\t\treturn\n\t}\n\n\tif err := r.ParseMultipartForm(10 \u003c\u003c 20); err != nil { // 10 MB max memory\n\t\thttp.Error(w, \"Invalid request body: \"+err.Error(), http.StatusBadRequest)\n\t\treturn\n\t}\n\n\tvar updateInput usecase.UpdateUserInput\n\tusername := r.FormValue(\"username\")\n\tpassword := r.FormValue(\"password\")\n\n\tif username != \"\" {\n\t\tupdateInput.Username = \u0026username\n\t}\n\tif password != \"\" {\n\t\tupdateInput.Password = \u0026password\n\t}\n\n\tif updateInput.Username != nil || updateInput.Password != nil {\n\t\tif _, err := h.userUsecase.UpdateProfile(r.Context(), userID, updateInput); err != nil {\n\t\t\tswitch err {\n\t\t\tcase service.ErrUserExists, service.ErrInvalidUsername, service.ErrInvalidPassword:\n\t\t\t\thttp.Error(w, err.Error(), http.StatusBadRequest)\n\t\t\tdefault:\n\t\t\t\thttp.Error(w, \"Failed to update profile\", http.StatusInternalServerError)\n\t\t\t}\n\t\t\treturn\n\t\t}\n\t}\n\n\tfile, header, err := r.FormFile(\"profile_pic\")\n\tif err == nil {\n\t\tdefer file.Close()\n\t\tif _, err := h.userUsecase.UpdateProfilePicture(r.Context(), userID, file, header); err != nil {\n\t\t\tswitch err {\n\t\t\tcase service.ErrFileSizeExceeded, service.ErrInvalidFileType:\n\t\t\t\thttp.Error(w, err.Error(), http.StatusBadRequest)\n\t\t\tdefault:\n\t\t\t\thttp.Error(w, \"Failed to update profile picture\", http.StatusInternalServerError)\n\t\t\t}\n\t\t\treturn\n\t\t}\n\t} else if err != http.ErrMissingFile {\n\t\thttp.Error(w, \"Could not process file: \"+err.Error(), http.StatusBadRequest)\n\t\treturn\n\t}\n\n\tupdatedUser, err := h.userUsecase.GetProfile(r.Context(), userID)\n\tif err != nil {\n\t\thttp.Error(w, \"Internal server error\", http.StatusInternalServerError)\n\t\treturn\n\t}\n\n\tw.Header().Set(\"Content-Type\", \"application/json\")\n\tw.WriteHeader(http.StatusOK)\n\tjson.NewEncoder(w).Encode(updatedUser)\n}\n",
  "backend/internal/delivery/http/handler/websocket_handler.go": "package handler\n\nimport (\n\t\"chat-app/internal/delivery/http/middleware\"\n\tws \"chat-app/internal/delivery/websocket\"\n\t\"log\"\n\t\"net/http\"\n\n\t\"github.com/gorilla/websocket\"\n)\n\nvar upgrader = websocket.Upgrader{\n\tReadBufferSize:  1024,\n\tWriteBufferSize: 1024,\n\tCheckOrigin: func(r *http.Request) bool {\n\t\t// Allow all connections for development\n\t\treturn true\n\t},\n}\n\ntype WebSocketHandler struct {\n\thub *ws.Hub\n}\n\nfunc NewWebSocketHandler(hub *ws.Hub) *WebSocketHandler {\n\treturn \u0026WebSocketHandler{hub: hub}\n}\n\nfunc (h *WebSocketHandler) ServeWS(w http.ResponseWriter, r *http.Request) {\n\tuserID, ok := r.Context().Value(middleware.UserIDContextKey).(string)\n\tif !ok {\n\t\thttp.Error(w, \"Unauthorized\", http.StatusUnauthorized)\n\t\treturn\n\t}\n\n\tconn, err := upgrader.Upgrade(w, r, nil)\n\tif err != nil {\n\t\tlog.Println(err)\n\t\treturn\n\t}\n\n\tclient := \u0026ws.Client{\n\t\thub:    h.hub,\n\t\tconn:   conn,\n\t\tsend:   make(chan []byte, 256),\n\t\tuserID: userID,\n\t}\n\tclient.hub.register \u003c- client\n\n\t// Allow collection of memory referenced by the caller by doing all work in\n\t// new goroutines.\n\tgo client.writePump()\n\tgo client.readPump()\n}\n",
  "backend/internal/delivery/http/middleware/auth_middleware.go": "package middleware\n\nimport (\n\t\"context\"\n\t\"net/http\"\n\t\"strings\"\n\n\t\"chat-app/pkg/config\"\n\t\"chat-app/pkg/util\"\n)\n\ntype contextKey string\n\nconst UserIDContextKey = contextKey(\"userID\")\n\nfunc AuthMiddleware(cfg *config.Config) func(next http.Handler) http.Handler {\n\treturn func(next http.Handler) http.Handler {\n\t\treturn http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\t\tauthHeader := r.Header.Get(\"Authorization\")\n\t\t\tif authHeader == \"\" {\n\t\t\t\thttp.Error(w, \"Authorization header required\", http.StatusUnauthorized)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tparts := strings.Split(authHeader, \" \")\n\t\t\tif len(parts) != 2 || parts[0] != \"Bearer\" {\n\t\t\t\thttp.Error(w, \"Invalid authorization header format\", http.StatusUnauthorized)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\ttokenString := parts[1]\n\t\t\tclaims, err := util.ValidateToken(tokenString, cfg.JWTSecret)\n\t\t\tif err != nil {\n\t\t\t\thttp.Error(w, \"Invalid token\", http.StatusUnauthorized)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tctx := context.WithValue(r.Context(), UserIDContextKey, claims.UserID)\n\t\t\tnext.ServeHTTP(w, r.WithContext(ctx))\n\t\t})\n\t}\n}\n",
  "backend/internal/delivery/http/router.go": "package router\n\nimport (\n\t\"net/http\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"strings\"\n\n\t\"chat-app/internal/delivery/http/handler\"\n\t\"chat-app/internal/delivery/http/middleware\"\n\tws \"chat-app/internal/delivery/websocket\"\n\t\"chat-app/internal/usecase\"\n\t\"chat-app/pkg/config\"\n\n\t\"github.com/go-chi/chi/v5\"\n\tchiMiddleware \"github.com/go-chi/chi/v5/middleware\"\n)\n\nfunc NewRouter(cfg *config.Config, authUsecase usecase.AuthUsecase, userUsecase usecase.UserUsecase, hub *ws.Hub) http.Handler {\n\tr := chi.NewRouter()\n\n\tr.Use(chiMiddleware.Logger)\n\tr.Use(chiMiddleware.Recoverer)\n\tr.Use(chiMiddleware.Heartbeat(\"/healthz\"))\n\n\t// Handlers\n\tauthHandler := handler.NewAuthHandler(authUsecase)\n\tuserHandler := handler.NewUserHandler(userUsecase)\n\twsHandler := handler.NewWebSocketHandler(hub)\n\tauthMiddleware := middleware.AuthMiddleware(cfg)\n\n\t// Public routes\n\tr.Route(\"/api/v1/auth\", func(r chi.Router) {\n\t\tr.Post(\"/signup\", authHandler.SignUp)\n\t\tr.Post(\"/login\", authHandler.Login)\n\t\tr.Post(\"/refresh\", authHandler.Refresh)\n\t\tr.Post(\"/logout\", authHandler.Logout)\n\t})\n\n\t// Protected routes\n\tr.Group(func(r chi.Router) {\n\t\tr.Use(authMiddleware)\n\n\t\tr.Get(\"/ws\", wsHandler.ServeWS)\n\n\t\tr.Route(\"/api/v1/users\", func(r chi.Router) {\n\t\t\tr.Get(\"/me\", userHandler.GetMyProfile)\n\t\t\tr.Put(\"/me\", userHandler.UpdateMyProfile)\n\t\t\tr.Get(\"/{username}\", userHandler.GetUserProfile)\n\t\t})\n\t})\n\n\t// Serve frontend files\n\tworkDir, _ := os.Getwd()\n\tfilesDir := http.Dir(filepath.Join(workDir, \"web\"))\n\tFileServer(r, \"/\", filesDir)\n\n\treturn r\n}\n\nfunc FileServer(r chi.Router, path string, root http.FileSystem) {\n\tif strings.ContainsAny(path, \"{}*\") {\n\t\tpanic(\"FileServer does not permit URL parameters.\")\n\t}\n\n\tfs := http.StripPrefix(path, http.FileServer(root))\n\n\tif path != \"/\" \u0026\u0026 path[len(path)-1] != '/' {\n\t\tr.Get(path, http.RedirectHandler(path+\"/\", 301).ServeHTTP)\n\t\tpath += \"/\"\n\t}\n\tpath += \"*\"\n\n\tr.Get(path, func(w http.ResponseWriter, r *http.Request) {\n\t\t// Check if the file exists\n\t\t_, err := root.Open(r.URL.Path)\n\t\tif os.IsNotExist(err) {\n\t\t\t// If not, serve chat.html as the SPA fallback\n\t\t\thttp.ServeFile(w, r, filepath.Join(root.(http.Dir).String(), \"templates/chat.html\"))\n\t\t\treturn\n\t\t}\n\t\tfs.ServeHTTP(w, r)\n\t})\n}\n",
  "backend/internal/delivery/websocket/client.go": "package websocket\n\nimport (\n\t\"bytes\"\n\t\"encoding/json\"\n\t\"log\"\n\t\"time\"\n\n\t\"github.com/gorilla/websocket\"\n)\n\nconst (\n\twriteWait      = 10 * time.Second\n\tpongWait       = 60 * time.Second\n\tpingPeriod     = (pongWait * 9) / 10\n\tmaxMessageSize = 512\n)\n\nvar (\n\tnewline = []byte{'\\n'}\n\tspace   = []byte{' '}\n)\n\n// Client is a middleman between the websocket connection and the hub.\ntype Client struct {\n\thub *Hub\n\n\t// The websocket connection.\n\tconn *websocket.Conn\n\n\t// Buffered channel of outbound messages.\n\tsend chan []byte\n\n\t// Authenticated user ID.\n\tuserID string\n}\n\n// readPump pumps messages from the websocket connection to the hub.\nfunc (c *Client) readPump() {\n\tdefer func() {\n\t\tc.hub.unregister \u003c- c\n\t\tc.conn.Close()\n\t}()\n\tc.conn.SetReadLimit(maxMessageSize)\n\tc.conn.SetReadDeadline(time.Now().Add(pongWait))\n\tc.conn.SetPongHandler(func(string) error { c.conn.SetReadDeadline(time.Now().Add(pongWait)); return nil })\n\tfor {\n\t\t_, message, err := c.conn.ReadMessage()\n\t\tif err != nil {\n\t\t\tif websocket.IsUnexpectedCloseError(err, websocket.CloseGoingAway, websocket.CloseAbnormalClosure) {\n\t\t\t\tlog.Printf(\"error: %v\", err)\n\t\t\t}\n\t\t\tbreak\n\t\t}\n\t\tmessage = bytes.TrimSpace(bytes.Replace(message, newline, space, -1))\n\t\t// For now, we just log incoming messages. In a full app, this would be parsed and handled.\n\t\tlog.Printf(\"Received message from %s: %s\", c.userID, message)\n\t}\n}\n\n// writePump pumps messages from the hub to the websocket connection.\nfunc (c *Client) writePump() {\n\tticker := time.NewTicker(pingPeriod)\n\tdefer func() {\n\t\tticker.Stop()\n\t\tc.conn.Close()\n\t}()\n\tfor {\n\t\tselect {\n\t\tcase message, ok := \u003c-c.send:\n\t\t\tc.conn.SetWriteDeadline(time.Now().Add(writeWait))\n\t\t\tif !ok {\n\t\t\t\t// The hub closed the channel.\n\t\t\t\tc.conn.WriteMessage(websocket.CloseMessage, []byte{})\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tw, err := c.conn.NextWriter(websocket.TextMessage)\n\t\t\tif err != nil {\n\t\t\t\treturn\n\t\t\t}\n\t\t\tw.Write(message)\n\n\t\t\t// Add queued chat messages to the current websocket message.\n\t\t\tn := len(c.send)\n\t\t\tfor i := 0; i \u003c n; i++ {\n\t\t\t\tw.Write(newline)\n\t\t\t\tw.Write(\u003c-c.send)\n\t\t\t}\n\n\t\t\tif err := w.Close(); err != nil {\n\t\t\t\treturn\n\t\t\t}\n\t\tcase \u003c-ticker.C:\n\t\t\tc.conn.SetWriteDeadline(time.Now().Add(writeWait))\n\t\t\tif err := c.conn.WriteMessage(websocket.PingMessage, nil); err != nil {\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t}\n}\n\n// SendEvent sends a domain event to the client.\nfunc (c *Client) SendEvent(event interface{}) {\n\teventBytes, err := json.Marshal(event)\n\tif err != nil {\n\t\tlog.Printf(\"Error marshalling event for client %s: %v\", c.userID, err)\n\t\treturn\n\t}\n\tc.send \u003c- eventBytes\n}\n",
  "backend/internal/delivery/websocket/hub.go": "package websocket\n\nimport (\n\t\"chat-app/internal/usecase\"\n\t\"context\"\n\t\"log\"\n)\n\n// Hub maintains the set of active clients and broadcasts messages to the\n// clients.\ntype Hub struct {\n\t// Registered clients.\n\tclients map[string]*Client\n\n\t// Inbound messages from the clients.\n\tbroadcast chan []byte\n\n\t// Register requests from the clients.\n\tregister chan *Client\n\n\t// Unregister requests from clients.\n\tunregister chan *Client\n\n\teventUsecase usecase.EventUsecase\n}\n\nfunc NewHub(eventUsecase usecase.EventUsecase) *Hub {\n\treturn \u0026Hub{\n\t\tbroadcast:  make(chan []byte),\n\t\tregister:   make(chan *Client),\n\t\tunregister: make(chan *Client),\n\t\tclients:    make(map[string]*Client),\n\t\teventUsecase: eventUsecase,\n\t}\n}\n\nfunc (h *Hub) Run() {\n\tfor {\n\t\tselect {\n\t\tcase client := \u003c-h.register:\n\t\t\th.clients[client.userID] = client\n\t\t\tlog.Printf(\"Client connected: %s. Total clients: %d\", client.userID, len(h.clients))\n\t\t\t// TODO: Fetch and send undelivered events\n\t\tcase client := \u003c-h.unregister:\n\t\t\tif _, ok := h.clients[client.userID]; ok {\n\t\t\t\tdelete(h.clients, client.userID)\n\t\t\t\tclose(client.send)\n\t\t\t\tlog.Printf(\"Client disconnected: %s. Total clients: %d\", client.userID, len(h.clients))\n\t\t\t}\n\t\tcase message := \u003c-h.broadcast:\n\t\t\t// This is a simple broadcast. A real app would target specific users.\n\t\t\tfor _, client := range h.clients {\n\t\t\t\tselect {\n\t\t\t\tcase client.send \u003c- message:\n\t\t\t\tdefault:\n\t\t\t\t\tclose(client.send)\n\t\t\t\t\tdelete(h.clients, client.userID)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n// BroadcastEvent sends an event to a specific user if they are online,\n// otherwise it buffers the event.\nfunc (h *Hub) BroadcastEvent(ctx context.Context, eventType string, payload interface{}, recipientID string) {\n\tif client, ok := h.clients[recipientID]; ok {\n\t\t// User is online, send directly\n\t\tclient.SendEvent(map[string]interface{}{\"type\": eventType, \"payload\": payload})\n\t} else {\n\t\t// User is offline, buffer the event\n\t\terr := h.eventUsecase.CreateAndBufferEvent(ctx, eventType, payload, recipientID)\n\t\tif err != nil {\n\t\t\tlog.Printf(\"Error buffering event for offline user %s: %v\", recipientID, err)\n\t\t}\n\t}\n}\n",
  "backend/internal/domain/event.go": "package domain\n\nimport (\n\t\"encoding/json\"\n\t\"time\"\n)\n\ntype Event struct {\n\tID          string          `json:\"id\"`\n\tType        string          `json:\"type\"`\n\tPayload     json.RawMessage `json:\"payload\"`\n\tRecipientID string          `json:\"recipient_id\"`\n\tIsDelivered bool            `json:\"is_delivered\"`\n\tCreatedAt   time.Time       `json:\"created_at\"`\n}\n",
  "backend/internal/domain/session.go": "package domain\n\nimport \"time\"\n\ntype Session struct {\n\tID        string    `json:\"id\"` // This is the Refresh Token\n\tUserID    string    `json:\"user_id\"`\n\tExpiresAt time.Time `json:\"expires_at\"`\n\tCreatedAt time.Time `json:\"created_at\"`\n}\n",
  "backend/internal/domain/user.go": "package domain\n\nimport \"time\"\n\ntype User struct {\n\tID            string    `json:\"id\"`\n\tUsername      string    `json:\"username\"`\n\tPasswordHash  string    `json:\"-\"` // Do not expose password hash\n\tProfilePicURL string    `json:\"profile_pic_url\"`\n\tCreatedAt     time.Time `json:\"created_at\"`\n\tUpdatedAt     time.Time `json:\"updated_at\"`\n}\n",
  "backend/internal/repository/event_repo.go": "package repository\n\nimport (\n\t\"context\"\n\t\"chat-app/internal/domain\"\n)\n\ntype EventRepository interface {\n\t// Redis operations\n\tBufferEvent(ctx context.Context, event *domain.Event) error\n\tGetBufferedEventsForUser(ctx context.Context, userID string) ([]*domain.Event, error)\n\tClearUserBuffer(ctx context.Context, userID string) error\n\n\t// Postgres operations\n\tStoreEvents(ctx context.Context, events []*domain.Event) error\n\tGetUndeliveredEvents(ctx context.Context, userID string) ([]*domain.Event, error)\n\tMarkEventsAsDelivered(ctx context.Context, eventIDs []string) error\n}\n",
  "backend/internal/repository/file_repo.go": "package repository\n\nimport (\n\t\"context\"\n)\n\ntype FileRepository interface {\n\tSaveProfilePicture(ctx context.Context, fileData []byte, fileType string) (filename string, err error)\n}\n",
  "backend/internal/repository/session_repo.go": "package repository\n\nimport (\n\t\"context\"\n\t\"chat-app/internal/domain\"\n)\n\ntype SessionRepository interface {\n\tStore(ctx context.Context, session *domain.Session) error\n\tGetByID(ctx context.Context, id string) (*domain.Session, error)\n\tDelete(ctx context.Context, id string) error\n\tDeleteAllForUser(ctx context.Context, userID string) error\n}\n",
  "backend/internal/repository/user_repo.go": "package repository\n\nimport (\n\t\"chat-app/internal/domain\"\n\t\"context\"\n)\n\ntype UserRepository interface {\n\tCreate(ctx context.Context, user *domain.User) error\n\tGetByUsername(ctx context.Context, username string) (*domain.User, error)\n\tGetByID(ctx context.Context, id string) (*domain.User, error)\n\tUpdate(ctx context.Context, user *domain.User) error\n}\n",
  "backend/internal/service/auth_service.go": "package service\n\nimport (\n\t\"context\"\n\t\"errors\"\n\t\"regexp\"\n\t\"strings\"\n\t\"time\"\n\n\t\"chat-app/internal/domain\"\n\t\"chat-app/internal/repository\"\n\t\"chat-app/internal/usecase\"\n\t\"chat-app/pkg/config\"\n\t\"chat-app/pkg/util\"\n)\n\nvar (\n\tErrUserExists         = errors.New(\"user with this username already exists\")\n\tErrUserNotFound       = errors.New(\"user not found\")\n\tErrInvalidCredentials = errors.New(\"invalid username or password\")\n\tErrInvalidUsername    = errors.New(\"username format is invalid\")\n\tErrInvalidPassword    = errors.New(\"password is too short\")\n\tErrSessionNotFound    = errors.New(\"session not found or expired\")\n\tErrSessionExpired     = errors.New(\"session has expired\")\n)\n\ntype authService struct {\n\tuserRepo    repository.UserRepository\n\tsessionRepo repository.SessionRepository\n\tcfg         *config.Config\n}\n\nfunc NewAuthService(userRepo repository.UserRepository, sessionRepo repository.SessionRepository, cfg *config.Config) usecase.AuthUsecase {\n\treturn \u0026authService{\n\t\tuserRepo:    userRepo,\n\t\tsessionRepo: sessionRepo,\n\t\tcfg:         cfg,\n\t}\n}\n\nfunc (s *authService) SignUp(ctx context.Context, input usecase.SignUpInput) (*domain.User, error) {\n\t// Validate username\n\tif err := validateUsername(input.Username); err != nil {\n\t\treturn nil, err\n\t}\n\t// Validate password\n\tif len(input.Password) \u003c 8 {\n\t\treturn nil, ErrInvalidPassword\n\t}\n\n\t// Check if user exists\n\texistingUser, err := s.userRepo.GetByUsername(ctx, input.Username)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif existingUser != nil {\n\t\treturn nil, ErrUserExists\n\t}\n\n\t// Hash password\n\thashedPassword, err := util.HashPassword(input.Password)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Create user\n\tuser := \u0026domain.User{\n\t\tID:           util.NewUUID(),\n\t\tUsername:     strings.ToLower(input.Username),\n\t\tPasswordHash: hashedPassword,\n\t}\n\n\tif err := s.userRepo.Create(ctx, user); err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn user, nil\n}\n\nfunc (s *authService) Login(ctx context.Context, input usecase.LoginInput) (*usecase.AuthTokens, error) {\n\tuser, err := s.userRepo.GetByUsername(ctx, input.Username)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif user == nil {\n\t\treturn nil, ErrInvalidCredentials\n\t}\n\n\tif !util.CheckPasswordHash(input.Password, user.PasswordHash) {\n\t\treturn nil, ErrInvalidCredentials\n\t}\n\n\t// Single device policy: remove all old sessions\n\tif err := s.sessionRepo.DeleteAllForUser(ctx, user.ID); err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn s.createSession(ctx, user.ID)\n}\n\nfunc (s *authService) Refresh(ctx context.Context, refreshToken string) (*usecase.AuthTokens, error) {\n\tsession, err := s.sessionRepo.GetByID(ctx, refreshToken)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif session == nil {\n\t\treturn nil, ErrSessionNotFound\n\t}\n\n\tif session.ExpiresAt.Before(time.Now()) {\n\t\t// Clean up expired session\n\t\t_ = s.sessionRepo.Delete(ctx, session.ID)\n\t\treturn nil, ErrSessionExpired\n\t}\n\n\t// Sliding window: delete old session and create a new one\n\tif err := s.sessionRepo.Delete(ctx, session.ID); err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn s.createSession(ctx, session.UserID)\n}\n\nfunc (s *authService) Logout(ctx context.Context, refreshToken string) error {\n\treturn s.sessionRepo.Delete(ctx, refreshToken)\n}\n\nfunc (s *authService) createSession(ctx context.Context, userID string) (*usecase.AuthTokens, error) {\n\taccessToken, err := util.GenerateAccessToken(userID, s.cfg.JWTSecret, s.cfg.AccessTokenTTL)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tsession := \u0026domain.Session{\n\t\tID:        util.NewUUID(), // This is the refresh token\n\t\tUserID:    userID,\n\t\tExpiresAt: time.Now().Add(s.cfg.RefreshTokenTTL),\n\t}\n\n\tif err := s.sessionRepo.Store(ctx, session); err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn \u0026usecase.AuthTokens{\n\t\tAccessToken:  accessToken,\n\t\tRefreshToken: session.ID,\n\t}, nil\n}\n\nfunc validateUsername(username string) error {\n\tif len(username) \u003c 4 || len(username) \u003e 50 {\n\t\treturn ErrInvalidUsername\n\t}\n\t// Allowed characters: lowercase letters (a-z), digits (0-9), and underscore (_)\n\tmatch, _ := regexp.MatchString(\"^[a-z0-9_]+$\", username)\n\tif !match {\n\t\treturn ErrInvalidUsername\n\t}\n\treturn nil\n}\n",
  "backend/internal/service/event_service.go": "package service\n\nimport (\n\t\"chat-app/internal/domain\"\n\t\"chat-app/internal/repository\"\n\t\"chat-app/internal/usecase\"\n\t\"chat-app/pkg/util\"\n\t\"context\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"log\"\n\t\"time\"\n)\n\ntype eventService struct {\n\tredisEventRepo repository.EventRepository\n\tpgEventRepo    repository.EventRepository\n\tuserRepo       repository.UserRepository\n}\n\nfunc NewEventService(redisEventRepo, pgEventRepo repository.EventRepository, userRepo repository.UserRepository) usecase.EventUsecase {\n\treturn \u0026eventService{\n\t\tredisEventRepo: redisEventRepo,\n\t\tpgEventRepo:    pgEventRepo,\n\t\tuserRepo:       userRepo,\n\t}\n}\n\nfunc (s *eventService) CreateAndBufferEvent(ctx context.Context, eventType string, payload interface{}, recipientID string) error {\n\tpayloadJSON, err := json.Marshal(payload)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to marshal event payload: %w\", err)\n\t}\n\n\tevent := \u0026domain.Event{\n\t\tID:          util.NewUUID(),\n\t\tType:        eventType,\n\t\tPayload:     payloadJSON,\n\t\tRecipientID: recipientID,\n\t\tCreatedAt:   time.Now(),\n\t}\n\n\treturn s.redisEventRepo.BufferEvent(ctx, event)\n}\n\n// PersistBufferedEvents is intended to be run as a background job.\n// It's a simplified implementation. A real-world scenario would need more robust handling\n// of user lists, locking, and error recovery.\nfunc (s *eventService) PersistBufferedEvents(ctx context.Context) {\n\t// In a real app, you'd get a list of active users with buffered events.\n\t// For this project, we'll assume we can iterate through all users, which is not scalable.\n\t// This is a placeholder for a more complex logic.\n\tlog.Println(\"Background worker: Persisting buffered events from Redis to Postgres is not fully implemented for scalability. This is a conceptual placeholder.\")\n\t// A proper implementation would:\n\t// 1. Get a list of all user IDs that have buffered events (e.g., from a Redis SET).\n\t// 2. For each user:\n\t//    a. Get all buffered events.\n\t//    b. Store them in Postgres.\n\t//    c. Clear the Redis buffer for that user.\n\t// This needs careful implementation to avoid race conditions and data loss.\n}\n",
  "backend/internal/service/user_service.go": "package service\n\nimport (\n\t\"chat-app/internal/domain\"\n\t\"chat-app/internal/repository\"\n\t\"chat-app/internal/usecase\"\n\t\"chat-app/pkg/util\"\n\t\"context\"\n\t\"errors\"\n\t\"io\"\n\t\"mime/multipart\"\n\t\"regexp\"\n)\n\nvar (\n\tErrProfileUpdateFailed = errors.New(\"profile update failed\")\n\tErrInvalidFileType     = errors.New(\"invalid file type for profile picture, allowed: png, jpg, jpeg, webp\")\n\tErrFileSizeExceeded    = errors.New(\"file size exceeds the 200KB limit\")\n)\n\ntype userService struct {\n\tuserRepo repository.UserRepository\n\tfileRepo repository.FileRepository\n}\n\nfunc NewUserService(userRepo repository.UserRepository, fileRepo repository.FileRepository) usecase.UserUsecase {\n\treturn \u0026userService{\n\t\tuserRepo: userRepo,\n\t\tfileRepo: fileRepo,\n\t}\n}\n\nfunc (s *userService) GetProfile(ctx context.Context, userID string) (*domain.User, error) {\n\treturn s.userRepo.GetByID(ctx, userID)\n}\n\nfunc (s *userService) GetUserByUsername(ctx context.Context, username string) (*domain.User, error) {\n\treturn s.userRepo.GetByUsername(ctx, username)\n}\n\nfunc (s *userService) UpdateProfile(ctx context.Context, userID string, input usecase.UpdateUserInput) (*domain.User, error) {\n\tuser, err := s.userRepo.GetByID(ctx, userID)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif user == nil {\n\t\treturn nil, ErrUserNotFound\n\t}\n\n\tif input.Username != nil {\n\t\tif err := validateUsername(*input.Username); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\texistingUser, err := s.userRepo.GetByUsername(ctx, *input.Username)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tif existingUser != nil \u0026\u0026 existingUser.ID != userID {\n\t\t\treturn nil, ErrUserExists\n\t\t}\n\t\tuser.Username = *input.Username\n\t}\n\n\tif input.Password != nil {\n\t\tif len(*input.Password) \u003c 8 {\n\t\t\treturn nil, ErrInvalidPassword\n\t\t}\n\t\thashedPassword, err := util.HashPassword(*input.Password)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tuser.PasswordHash = hashedPassword\n\t}\n\n\tif err := s.userRepo.Update(ctx, user); err != nil {\n\t\treturn nil, ErrProfileUpdateFailed\n\t}\n\n\treturn user, nil\n}\n\nfunc (s *userService) UpdateProfilePicture(ctx context.Context, userID string, file multipart.File, fileHeader *multipart.FileHeader) (string, error) {\n\tif fileHeader.Size \u003e 200*1024 { // 200 KB\n\t\treturn \"\", ErrFileSizeExceeded\n\t}\n\n\tcontentType := fileHeader.Header.Get(\"Content-Type\")\n\tallowedTypes := []string{\"image/png\", \"image/jpeg\", \"image/jpg\", \"image/webp\"}\n\tisValidType := false\n\tfor _, t := range allowedTypes {\n\t\tif contentType == t {\n\t\t\tisValidType = true\n\t\t\tbreak\n\t\t}\n\t}\n\tif !isValidType {\n\t\treturn \"\", ErrInvalidFileType\n\t}\n\n\tfileBytes, err := io.ReadAll(file)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\tfilename, err := s.fileRepo.SaveProfilePicture(ctx, fileBytes, contentType)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\tuser, err := s.userRepo.GetByID(ctx, userID)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\tif user == nil {\n\t\treturn \"\", ErrUserNotFound\n\t}\n\n\tuser.ProfilePicURL = \"/uploads/\" + filename\n\tif err := s.userRepo.Update(ctx, user); err != nil {\n\t\treturn \"\", ErrProfileUpdateFailed\n\t}\n\n\treturn user.ProfilePicURL, nil\n}\n\nfunc validateUsername(username string) error {\n\tif len(username) \u003c 4 || len(username) \u003e 50 {\n\t\treturn ErrInvalidUsername\n\t}\n\tmatch, _ := regexp.MatchString(\"^[a-z0-9_]+$\")\n\tif !match {\n\t\treturn ErrInvalidUsername\n\t}\n\treturn nil\n}\n",
  "backend/internal/usecase/auth_ucase.go": "package usecase\n\nimport (\n\t\"context\"\n\t\"chat-app/internal/domain\"\n)\n\ntype SignUpInput struct {\n\tUsername string `json:\"username\"`\n\tPassword string `json:\"password\"`\n}\n\ntype LoginInput struct {\n\tUsername string `json:\"username\"`\n\tPassword string `json:\"password\"`\n}\n\ntype AuthTokens struct {\n\tAccessToken  string `json:\"access_token\"`\n\tRefreshToken string `json:\"refresh_token\"`\n}\n\ntype AuthUsecase interface {\n\tSignUp(ctx context.Context, input SignUpInput) (*domain.User, error)\n\tLogin(ctx context.Context, input LoginInput) (*AuthTokens, error)\n\tRefresh(ctx context.Context, refreshToken string) (*AuthTokens, error)\n\tLogout(ctx context.Context, refreshToken string) error\n}\n",
  "backend/internal/usecase/event_ucase.go": "package usecase\n\nimport (\n\t\"chat-app/internal/domain\"\n\t\"context\"\n)\n\ntype EventUsecase interface {\n\tCreateAndBufferEvent(ctx context.Context, eventType string, payload interface{}, recipientID string) error\n\tPersistBufferedEvents(ctx context.Context)\n}\n",
  "backend/internal/usecase/user_ucase.go": "package usecase\n\nimport (\n\t\"chat-app/internal/domain\"\n\t\"context\"\n\t\"mime/multipart\"\n)\n\ntype UpdateUserInput struct {\n\tUsername *string\n\tPassword *string\n}\n\ntype UserUsecase interface {\n\tGetProfile(ctx context.Context, userID string) (*domain.User, error)\n\tGetUserByUsername(ctx context.Context, username string) (*domain.User, error)\n\tUpdateProfile(ctx context.Context, userID string, input UpdateUserInput) (*domain.User, error)\n\tUpdateProfilePicture(ctx context.Context, userID string, file multipart.File, fileHeader *multipart.FileHeader) (string, error)\n}\n",
  "backend/migrations/000001_create_users_table.up.sql": "CREATE EXTENSION IF NOT EXISTS \"uuid-ossp\";\nCREATE EXTENSION IF NOT EXISTS \"citext\";\n\nCREATE TABLE IF NOT EXISTS users (\n    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),\n    username CITEXT NOT NULL UNIQUE,\n    password_hash VARCHAR(255) NOT NULL,\n    profile_pic_url VARCHAR(255) DEFAULT '',\n    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),\n    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()\n);\n\nCREATE INDEX IF NOT EXISTS users_username_idx ON users(username);\n",
  "backend/migrations/000002_create_sessions_table.up.sql": "CREATE TABLE IF NOT EXISTS sessions (\n    id UUID PRIMARY KEY,\n    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,\n    expires_at TIMESTAMPTZ NOT NULL,\n    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()\n);\n\nCREATE INDEX IF NOT EXISTS sessions_user_id_idx ON sessions(user_id);\n",
  "backend/migrations/000003_create_events_table.up.sql": "CREATE TABLE IF NOT EXISTS events (\n    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),\n    type VARCHAR(50) NOT NULL,\n    payload JSONB NOT NULL,\n    recipient_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,\n    is_delivered BOOLEAN NOT NULL DEFAULT FALSE,\n    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()\n);\n\nCREATE INDEX IF NOT EXISTS events_recipient_id_is_delivered_idx ON events (recipient_id, is_delivered);\n",
  "backend/pkg/config/config.go": "package config\n\nimport (\n\t\"log\"\n\t\"os\"\n\t\"time\"\n\n\t\"github.com/joho/godotenv\"\n)\n\ntype Config struct {\n\tPort            string\n\tDatabaseURL     string\n\tRedisURL        string\n\tJWTSecret       string\n\tAccessTokenTTL  time.Duration\n\tRefreshTokenTTL time.Duration\n\tUploadDir       string\n}\n\nfunc Load() *Config {\n\tif err := godotenv.Load(); err != nil {\n\t\tlog.Println(\"No .env file found, using environment variables\")\n\t}\n\n\treturn \u0026Config{\n\t\tPort:            getEnv(\"PORT\", \"8080\"),\n\t\tDatabaseURL:     getEnv(\"DATABASE_URL\", \"postgres://user:password@localhost:5432/chatdb?sslmode=disable\"),\n\t\tRedisURL:        getEnv(\"REDIS_URL\", \"redis://localhost:6379/0\"),\n\t\tJWTSecret:       getEnv(\"JWT_SECRET\", \"a-very-secret-key\"),\n\t\tAccessTokenTTL:  10 * time.Minute,\n\t\tRefreshTokenTTL: 8 * time.Hour,\n\t\tUploadDir:       getEnv(\"UPLOAD_DIR\", \"uploads\"),\n\t}\n}\n\nfunc getEnv(key, fallback string) string {\n\tif value, ok := os.LookupEnv(key); ok {\n\t\treturn value\n\t}\n\treturn fallback\n}",
  "backend/pkg/util/hash.go": "package util\n\nimport \"golang.org/x/crypto/bcrypt\"\n\nfunc HashPassword(password string) (string, error) {\n\tbytes, err := bcrypt.GenerateFromPassword([]byte(password), bcrypt.DefaultCost)\n\treturn string(bytes), err\n}\n\nfunc CheckPasswordHash(password, hash string) bool {\n\terr := bcrypt.CompareHashAndPassword([]byte(hash), []byte(password))\n\treturn err == nil\n}\n",
  "backend/pkg/util/jwt.go": "package util\n\nimport (\n\t\"fmt\"\n\t\"time\"\n\n\t\"github.com/golang-jwt/jwt/v5\"\n)\n\ntype Claims struct {\n\tUserID string `json:\"user_id\"`\n\tjwt.RegisteredClaims\n}\n\nfunc GenerateAccessToken(userID, secret string, ttl time.Duration) (string, error) {\n\tclaims := \u0026Claims{\n\t\tUserID: userID,\n\t\tRegisteredClaims: jwt.RegisteredClaims{\n\t\t\tExpiresAt: jwt.NewNumericDate(time.Now().Add(ttl)),\n\t\t\tIssuedAt:  jwt.NewNumericDate(time.Now()),\n\t\t},\n\t}\n\n\ttoken := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)\n\treturn token.SignedString([]byte(secret))\n}\n\nfunc ValidateToken(tokenString, secret string) (*Claims, error) {\n\ttoken, err := jwt.ParseWithClaims(tokenString, \u0026Claims{}, func(token *jwt.Token) (interface{}, error) {\n\t\tif _, ok := token.Method.(*jwt.SigningMethodHMAC); !ok {\n\t\t\treturn nil, fmt.Errorf(\"unexpected signing method: %v\", token.Header[\"alg\"])\n\t\t}\n\t\treturn []byte(secret), nil\n\t})\n\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tif claims, ok := token.Claims.(*Claims); ok \u0026\u0026 token.Valid {\n\t\treturn claims, nil\n\t}\n\n\treturn nil, fmt.Errorf(\"invalid token\")\n}\n",
  "backend/pkg/util/uuid.go": "package util\n\nimport \"github.com/google/uuid\"\n\nfunc NewUUID() string {\n\treturn uuid.New().String()\n}\n\nfunc ParseUUID(s string) (uuid.UUID, error) {\n\treturn uuid.Parse(s)\n}\n```",
  "backend/web/static/css/style.css": "/* Placeholder for compiled Tailwind CSS */\n",
  "backend/web/static/js/api.js": "/**\n * @typedef {object} User\n * @property {string} id\n * @property {string} username\n * @property {string} profile_pic_url\n * @property {string} created_at\n * @property {string} updated_at\n */\n\n/**\n * @typedef {object} AuthTokens\n * @property {string} access_token\n * @property {string} refresh_token\n */\n\nimport { getAccessToken, setTokens, clearTokens } from './store.js';\n\nconst API_BASE = '/api/v1';\n\nasync function request(endpoint, options = {}) {\n    const url = `${API_BASE}${endpoint}`;\n    const headers = {\n        'Content-Type': 'application/json',\n        ...options.headers,\n    };\n\n    const token = getAccessToken();\n    if (token) {\n        headers['Authorization'] = `Bearer ${token}`;\n    }\n\n    // For FormData, let the browser set the Content-Type\n    if (options.body instanceof FormData) {\n        delete headers['Content-Type'];\n    }\n\n    const config = {\n        ...options,\n        headers,\n    };\n\n    const response = await fetch(url, config);\n\n    if (!response.ok) {\n        const errorData = await response.json().catch(() =\u003e ({ message: response.statusText }));\n        throw new Error(errorData.message || 'An API error occurred');\n    }\n\n    if (response.status === 204) {\n        return null;\n    }\n\n    return response.json();\n}\n\n/** @returns {Promise\u003cUser\u003e} */\nexport const signup = (username, password) =\u003e request('/auth/signup', {\n    method: 'POST',\n    body: JSON.stringify({ username, password }),\n});\n\n/** @returns {Promise\u003cAuthTokens\u003e} */\nexport const login = async (username, password) =\u003e {\n    const tokens = await request('/auth/login', {\n        method: 'POST',\n        body: JSON.stringify({ username, password }),\n    });\n    setTokens(tokens.access_token, tokens.refresh_token);\n    return tokens;\n};\n\nexport const logout = async () =\u003e {\n    // Implementation will require refresh token from store\n    // For now, just clear local tokens\n    clearTokens();\n};\n\n/** @returns {Promise\u003cUser\u003e} */\nexport const getMe = () =\u003e request('/users/me');\n\n/** @returns {Promise\u003cUser\u003e} */\nexport const updateProfile = (formData) =\u003e request('/users/me', {\n    method: 'PUT',\n    body: formData,\n});\n\n/** @returns {Promise\u003cUser\u003e} */\nexport const getUserByUsername = (username) =\u003e request(`/users/${username}`);\n",
  "backend/web/static/js/main.js": "import * as api from './api.js';\nimport * as store from './store.js';\nimport * as ui from './ui.js';\nimport * as ws from './ws.js';\n\n/**\n * Handles the submission of login and signup forms.\n * @param {Event} event\n */\nasync function handleAuthFormSubmit(event) {\n    event.preventDefault();\n    const form = event.target;\n    const isLogin = form.id === 'login-form';\n    const username = form.username.value;\n    const password = form.password.value;\n\n    try {\n        if (isLogin) {\n            await api.login(username, password);\n        } else {\n            await api.signup(username, password);\n            // Automatically log in after successful signup\n            await api.login(username, password);\n        }\n        window.location.href = '/chat';\n    } catch (error) {\n        ui.showError(form.id, error.message);\n    }\n}\n\n/**\n * Handles the submission of the profile update form.\n * @param {Event} event\n */\nasync function handleProfileUpdateFormSubmit(event) {\n    event.preventDefault();\n    const form = event.target;\n    const formData = new FormData(form);\n\n    // Remove empty fields from formData\n    for (let [key, value] of [...formData.entries()]) {\n        if (value === '' || (value instanceof File \u0026\u0026 value.size === 0)) {\n            formData.delete(key);\n        }\n    }\n\n    if (Array.from(formData.keys()).length === 0) {\n        ui.showNotification('No changes to update.', 'info');\n        return;\n    }\n\n    try {\n        const updatedUser = await api.updateProfile(formData);\n        store.setCurrentUser(updatedUser);\n        ui.renderProfile(updatedUser);\n        ui.showNotification('Profile updated successfully!', 'success');\n        form.reset();\n    } catch (error) {\n        ui.showNotification(`Error: ${error.message}`, 'error');\n    }\n}\n\n/**\n * Handles user logout.\n */\nasync function handleLogout() {\n    await api.logout();\n    store.clearTokens();\n    window.location.href = '/';\n}\n\n/**\n * Initializes the authentication page (login/signup).\n */\nfunction initAuthPage() {\n    const loginForm = document.getElementById('login-form');\n    const signupForm = document.getElementById('signup-form');\n    const showSignupBtn = document.getElementById('show-signup-form');\n    const showLoginBtn = document.getElementById('show-login-form');\n\n    loginForm?.addEventListener('submit', handleAuthFormSubmit);\n    signupForm?.addEventListener('submit', handleAuthFormSubmit);\n    showSignupBtn?.addEventListener('click', ui.toggleAuthForms);\n    showLoginBtn?.addEventListener('click', ui.toggleAuthForms);\n}\n\n/**\n * Initializes the main chat page.\n */\nasync function initChatPage() {\n    const logoutButton = document.getElementById('logout-button');\n    const profileUpdateForm = document.getElementById('profile-update-form');\n\n    logoutButton?.addEventListener('click', handleLogout);\n    profileUpdateForm?.addEventListener('submit', handleProfileUpdateFormSubmit);\n\n    try {\n        const user = await api.getMe();\n        store.setCurrentUser(user);\n        ui.renderProfile(user);\n        // Connect to WebSocket after successfully fetching user profile\n        ws.connect();\n    } catch (error) {\n        console.error('Failed to fetch user profile:', error);\n        // If fetching fails (e.g., invalid token), redirect to login\n        store.clearTokens();\n        window.location.href = '/';\n    }\n}\n\n// --- Main Execution ---\ndocument.addEventListener('DOMContentLoaded', () =\u003e {\n    const path = window.location.pathname;\n\n    if (path === '/' || path === '/index.html') {\n        initAuthPage();\n    } else if (path === '/chat' || path === '/chat.html') {\n        initChatPage();\n    }\n});\n",
  "backend/web/static/js/store.js": "/**\n * @typedef {import('./api.js').User} User\n */\n\nlet state = {\n    /** @type {User | null} */\n    currentUser: null,\n    accessToken: null,\n    refreshToken: null,\n};\n\n/** @param {User} user */\nexport function setCurrentUser(user) {\n    state.currentUser = user;\n}\n\nexport function getCurrentUser() {\n    return state.currentUser;\n}\n\nexport function setTokens(access, refresh) {\n    state.accessToken = access;\n    state.refreshToken = refresh;\n}\n\nexport function getAccessToken() {\n    return state.accessToken;\n}\n\nexport function getRefreshToken() {\n    return state.refreshToken;\n}\n\nexport function clearTokens() {\n    state.accessToken = null;\n    state.refreshToken = null;\n    state.currentUser = null;\n}\n",
  "backend/web/static/js/ui.js": "/**\n * @typedef {import('./api.js').User} User\n */\n\nexport function toggleAuthForms() {\n    document.getElementById('login-container').classList.toggle('hidden');\n    document.getElementById('signup-container').classList.toggle('hidden');\n}\n\nexport function showError(formId, message) {\n    const errorEl = document.querySelector(`#${formId} .error-message`);\n    if (errorEl) {\n        errorEl.textContent = message;\n        errorEl.classList.remove('hidden');\n    }\n}\n\n/** @param {User} user */\nexport function renderProfile(user) {\n    const profileContainer = document.getElementById('profile-container');\n    if (!profileContainer) return;\n\n    const profilePicUrl = user.profile_pic_url ? user.profile_pic_url : 'https://via.placeholder.com/100';\n\n    profileContainer.innerHTML = `\n        \u003cimg src=\"${profilePicUrl}\" alt=\"Profile Picture\" class=\"w-24 h-24 rounded-full mx-auto mb-4 object-cover\"\u003e\n        \u003ch2 class=\"text-2xl font-bold text-center\"\u003e${user.username}\u003c/h2\u003e\n        \u003cp class=\"text-gray-500 text-center\"\u003eJoined: ${new Date(user.created_at).toLocaleDateString()}\u003c/p\u003e\n    `;\n}\n\nexport function showNotification(message, type = 'info') {\n    const container = document.getElementById('notification-container');\n    if (!container) return;\n\n    const color = type === 'success' ? 'bg-green-500' : type === 'error' ? 'bg-red-500' : 'bg-blue-500';\n\n    const notification = document.createElement('div');\n    notification.className = `fixed bottom-5 right-5 p-4 rounded-lg text-white shadow-lg transition-opacity duration-300 ${color}`;\n    notification.textContent = message;\n\n    container.appendChild(notification);\n\n    setTimeout(() =\u003e {\n        notification.style.opacity = '0';\n        setTimeout(() =\u003e notification.remove(), 300);\n    }, 3000);\n}\n",
  "backend/web/static/js/ws.js": "import { getAccessToken } from './store.js';\nimport { showNotification } from './ui.js';\n\nlet socket = null;\n\n/**\n * Establishes a WebSocket connection.\n */\nfunction connect() {\n    const token = getAccessToken();\n    if (!token) {\n        console.error('No access token found for WebSocket connection.');\n        return;\n    }\n\n    if (socket \u0026\u0026 socket.readyState === WebSocket.OPEN) {\n        console.log('WebSocket is already connected.');\n        return;\n    }\n\n    const protocol = window.location.protocol === 'https' ? 'wss' : 'ws';\n    const host = window.location.host;\n    const wsUrl = `${protocol}://${host}/ws`;\n\n    socket = new WebSocket(wsUrl);\n\n    socket.onopen = () =\u003e {\n        console.log('WebSocket connection established.');\n        // Send authentication token\n        // The backend will get the user ID from the JWT used to establish the connection\n        // so we don't need to send it explicitly.\n        showNotification('Connected to real-time service.', 'success');\n    };\n\n    socket.onmessage = (event) =\u003e {\n        console.log('WebSocket message received:', event.data);\n        try {\n            const parsedEvent = JSON.parse(event.data);\n            handleIncomingEvent(parsedEvent);\n        } catch (error) {\n            console.error('Error parsing incoming WebSocket event:', error);\n        }\n    };\n\n    socket.onclose = (event) =\u003e {\n        console.log('WebSocket connection closed:', event);\n        showNotification('Disconnected from real-time service.', 'error');\n        // Optional: implement reconnection logic here\n        socket = null;\n    };\n\n    socket.onerror = (error) =\u003e {\n        console.error('WebSocket error:', error);\n        showNotification('A real-time connection error occurred.', 'error');\n    };\n}\n\n/**\n * Sends a message over the WebSocket.\n * @param {string} messageType\n * @param {object} payload\n */\nfunction send(messageType, payload) {\n    if (!socket || socket.readyState !== WebSocket.OPEN) {\n        console.error('WebSocket is not connected.');\n        return;\n    }\n    const message = JSON.stringify({ type: messageType, payload });\n    socket.send(message);\n    console.log('WebSocket message sent:', message);\n}\n\n/**\n * Handles incoming events from the WebSocket.\n * @param {object} event\n */\nfunction handleIncomingEvent(event) {\n    // Example event handling\n    switch (event.type) {\n        case 'new_message':\n            // ui.renderMessage(event.payload);\n            showNotification(`New message received!`);\n            break;\n        case 'friend_request_received':\n            // store.addFriendRequest(event.payload);\n            // ui.renderFriendRequests();\n            showNotification(`New friend request from ${event.payload.sender.username}`);\n            break;\n        default:\n            console.log(`Unhandled event type: ${event.type}`);\n            showNotification(`Received a new notification: ${event.type}`);\n    }\n}\n\nexport { connect, send };",
  "backend/web/templates/chat.html": "\u003c!DOCTYPE html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n    \u003cmeta charset=\"UTF-8\"\u003e\n    \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"\u003e\n    \u003ctitle\u003eQuikChat\u003c/title\u003e\n    \u003cscript src=\"https://cdn.tailwindcss.com\"\u003e\u003c/script\u003e\n\u003c/head\u003e\n\u003cbody class=\"bg-gray-100 font-sans\"\u003e\n    \u003cdiv id=\"notification-container\"\u003e\u003c/div\u003e\n    \u003cdiv class=\"flex h-screen\"\u003e\n        \u003c!-- Sidebar --\u003e\n        \u003cdiv class=\"w-1/4 bg-white border-r border-gray-200 p-4 flex flex-col\"\u003e\n            \u003ch1 class=\"text-2xl font-bold mb-4\"\u003eQuikChat\u003c/h1\u003e\n            \n            \u003c!-- Profile Section --\u003e\n            \u003cdiv id=\"profile-container\" class=\"mb-4 p-4 bg-gray-50 rounded-lg\"\u003e\n                \u003c!-- Profile info will be rendered here by JS --\u003e\n            \u003c/div\u003e\n\n            \u003c!-- Profile Update Form --\u003e\n            \u003cdiv class=\"mb-4 p-4 bg-gray-50 rounded-lg\"\u003e\n                \u003ch3 class=\"font-semibold mb-2\"\u003eUpdate Profile\u003c/h3\u003e\n                \u003cform id=\"profile-update-form\"\u003e\n                    \u003cdiv class=\"mb-2\"\u003e\n                        \u003clabel for=\"username\" class=\"block text-sm font-medium text-gray-700\"\u003eNew Username\u003c/label\u003e\n                        \u003cinput type=\"text\" name=\"username\" id=\"username\" class=\"mt-1 block w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm\" placeholder=\"min 4 chars, a-z0-9_\"\u003e\n                    \u003c/div\u003e\n                    \u003cdiv class=\"mb-2\"\u003e\n                        \u003clabel for=\"password\" class=\"block text-sm font-medium text-gray-700\"\u003eNew Password\u003c/label\u003e\n                        \u003cinput type=\"password\" name=\"password\" id=\"password\" class=\"mt-1 block w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm\" placeholder=\"min 8 chars\"\u003e\n                    \u003c/div\u003e\n                    \u003cdiv class=\"mb-4\"\u003e\n                        \u003clabel for=\"profile_pic\" class=\"block text-sm font-medium text-gray-700\"\u003eProfile Picture\u003c/label\u003e\n                        \u003cinput type=\"file\" name=\"profile_pic\" id=\"profile_pic\" accept=\"image/png, image/jpeg, image/webp\" class=\"mt-1 block w-full text-sm text-gray-500 file:mr-4 file:py-2 file:px-4 file:rounded-full file:border-0 file:text-sm file:font-semibold file:bg-indigo-50 file:text-indigo-600 hover:file:bg-indigo-100\"\u003e\n                    \u003c/div\u003e\n                    \u003cbutton type=\"submit\" class=\"w-full bg-indigo-600 text-white py-2 px-4 rounded-md hover:bg-indigo-700\"\u003eUpdate\u003c/button\u003e\n                \u003c/form\u003e\n            \u003c/div\u003e\n\n            \u003cdiv class=\"mt-auto\"\u003e\n                \u003cbutton id=\"logout-button\" class=\"w-full bg-red-500 text-white py-2 px-4 rounded-md hover:bg-red-600\"\u003eLogout\u003c/button\u003e\n            \u003c/div\u003e\n        \u003c/div\u003e\n\n        \u003c!-- Main Chat Area --\u003e\n        \u003cdiv class=\"w-3/4 flex flex-col\"\u003e\n            \u003cdiv class=\"flex-grow p-4\"\u003e\n                \u003ch2 class=\"text-xl font-semibold\"\u003eChat Window\u003c/h2\u003e\n                \u003cp class=\"text-gray-500\"\u003eSelect a conversation to start chatting.\u003c/p\u003e\n            \u003c/div\u003e\n        \u003c/div\u003e\n    \u003c/div\u003e\n\n    \u003cscript type=\"module\" src=\"/static/js/main.js\"\u003e\u003c/script\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n",
  "backend/web/templates/index.html": "\u003c!DOCTYPE html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n    \u003cmeta charset=\"UTF-8\"\u003e\n    \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"\u003e\n    \u003ctitle\u003eWelcome to QuikChat\u003c/title\u003e\n    \u003cscript src=\"https://cdn.tailwindcss.com\"\u003e\u003c/script\u003e\n\u003c/head\u003e\n\u003cbody class=\"bg-gray-100 flex items-center justify-center h-screen\"\u003e\n    \u003cdiv class=\"w-full max-w-md\"\u003e\n        \u003c!-- Login Form --\u003e\n        \u003cdiv id=\"login-container\"\u003e\n            \u003cform id=\"login-form\" class=\"bg-white shadow-md rounded px-8 pt-6 pb-8 mb-4\"\u003e\n                \u003ch1 class=\"text-2xl font-bold text-center mb-6\"\u003eLogin to QuikChat\u003c/h1\u003e\n                \u003cdiv class=\"mb-4\"\u003e\n                    \u003clabel class=\"block text-gray-700 text-sm font-bold mb-2\" for=\"login-username\"\u003e\n                        Username\n                    \u003c/label\u003e\n                    \u003cinput class=\"shadow appearance-none border rounded w-full py-2 px-3 text-gray-700 leading-tight focus:outline-none focus:shadow-outline\" id=\"login-username\" name=\"username\" type=\"text\" placeholder=\"Username\" required\u003e\n                \u003c/div\u003e\n                \u003cdiv class=\"mb-6\"\u003e\n                    \u003clabel class=\"block text-gray-700 text-sm font-bold mb-2\" for=\"login-password\"\u003e\n                        Password\n                    \u003c/label\u003e\n                    \u003cinput class=\"shadow appearance-none border rounded w-full py-2 px-3 text-gray-700 mb-3 leading-tight focus:outline-none focus:shadow-outline\" id=\"login-password\" name=\"password\" type=\"password\" placeholder=\"******************\" required\u003e\n                \u003c/div\u003e\n                \u003cp class=\"error-message text-red-500 text-xs italic mb-4 hidden\"\u003e\u003c/p\u003e\n                \u003cdiv class=\"flex items-center justify-between\"\u003e\n                    \u003cbutton class=\"bg-blue-500 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded focus:outline-none focus:shadow-outline\" type=\"submit\"\u003e\n                        Sign In\n                    \u003c/button\u003e\n                    \u003ca id=\"show-signup-form\" class=\"inline-block align-baseline font-bold text-sm text-blue-500 hover:text-blue-800\" href=\"#\"\u003e\n                        Create an Account\n                    \u003c/a\u003e\n                \u003c/div\u003e\n            \u003c/form\u003e\n        \u003c/div\u003e\n\n        \u003c!-- Signup Form --\u003e\n        \u003cdiv id=\"signup-container\" class=\"hidden\"\u003e\n            \u003cform id=\"signup-form\" class=\"bg-white shadow-md rounded px-8 pt-6 pb-8 mb-4\"\u003e\n                \u003ch1 class=\"text-2xl font-bold text-center mb-6\"\u003eCreate Account\u003c/h1\u003e\n                \u003cdiv class=\"mb-4\"\u003e\n                    \u003clabel class=\"block text-gray-700 text-sm font-bold mb-2\" for=\"signup-username\"\u003e\n                        Username\n                    \u003c/label\u003e\n                    \u003cinput class=\"shadow appearance-none border rounded w-full py-2 px-3 text-gray-700 leading-tight focus:outline-none focus:shadow-outline\" id=\"signup-username\" name=\"username\" type=\"text\" placeholder=\"lowercase, 0-9, _\" required minlength=\"4\" maxlength=\"50\"\u003e\n                \u003c/div\u003e\n                \u003cdiv class=\"mb-6\"\u003e\n                    \u003clabel class=\"block text-gray-700 text-sm font-bold mb-2\" for=\"signup-password\"\u003e\n                        Password\n                    \u003c/label\u003e\n                    \u003cinput class=\"shadow appearance-none border rounded w-full py-2 px-3 text-gray-700 mb-3 leading-tight focus:outline-none focus:shadow-outline\" id=\"signup-password\" name=\"password\" type=\"password\" placeholder=\"******************\" required minlength=\"8\"\u003e\n                \u003c/div\u003e\n                \u003cp class=\"error-message text-red-500 text-xs italic mb-4 hidden\"\u003e\u003c/p\u003e\n                \u003cdiv class=\"flex items-center justify-between\"\u003e\n                    \u003cbutton class=\"bg-green-500 hover:bg-green-700 text-white font-bold py-2 px-4 rounded focus:outline-none focus:shadow-outline\" type=\"submit\"\u003e\n                        Sign Up\n                    \u003c/button\u003e\n                    \u003ca id=\"show-login-form\" class=\"inline-block align-baseline font-bold text-sm text-blue-500 hover:text-blue-800\" href=\"#\"\u003e\n                        Already have an account?\n                    \u003c/a\u003e\n                \u003c/div\u003e\n            \u003c/form\u003e\n        \u003c/div\u003e\n        \u003cp class=\"text-center text-gray-500 text-xs\"\u003e\n            \u0026copy;2024 QuikChat. All rights reserved.\n        \u003c/p\u003e\n    \u003c/div\u003e\n    \u003cscript type=\"module\" src=\"/static/js/main.js\"\u003e\u003c/script\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n```",
  "docker-compose.yml": "version: '3.8'\n\nservices:\n  postgres:\n    image: postgres:13\n    restart: always\n    environment:\n      POSTGRES_USER: user\n      POSTGRES_PASSWORD: password\n      POSTGRES_DB: chatdb\n    ports:\n      - \"5432:5432\"  # Expose Postgres port to host\n    volumes:\n      - postgres_data:/var/lib/postgresql/data\n\n  redis:\n    image: redis:6-alpine\n    restart: always\n    ports:\n      - \"6379:6379\"  # Expose Redis port to host\n    volumes:\n      - redis_data:/data\n\nvolumes:\n  postgres_data:\n  redis_data:\n"
}